 Easytrieve ® Report Generator 11.6
               DEPT    EMPNAME   EMP#      GROSS                       
 
               903     WIMN      12267     373.60                      
               943     BERG      11473     759.20                      
               915     CORNING   02688     146.16                      
               935     NAGLE     00370     554.40                      
               911     ARNOLD    01963     445.50                      
               914     MANHART   11602     344.80                      
               917     TALL      11931     492.26                      
               918     BRANDOW   02200     804.64                      
               911     LARSON    11357     283.92                      
               932     BYER      11467     396.68                      
               921     HUSS      11376     360.80                      
               911     POWELL    11710     243.20                      
               943     MCMAHON   04234     386.40                      
You can generate reports faster with  Easytrieve  than with other programming languages or report generators. The Day 1
Task Checklist show how to start creating  Easytrieve  programs.
Day 1 Task Checklist
To get started using  Easytrieve , review this checklist that summarizes key tasks for creating and running a sample 
Easytrieve  program.
This checklist includes a brief description of the tasks, with links to the procedures. The checklist also identifies the roles
that are typically required to complete the task. This checklist is not all inclusive but represents the top tasks that we
recommend you execute on Day 1.
TIP
It is not necessary to perform these tasks sequentially, but this sequence follows a logical progression to assist
you in developing the basic skills to run programs in  Easytrieve .
For a printable version of this checklist, download an Excel spreadsheet copy of this checklist .
Task Description Role Time Estimate Status
Create and Run a
Sample Easytrieve
ProgramReview a sample program that uses FILE and DEFINE
Statements in the library section, and view Report
Output.Systems
Programmer1 hour Complete, In
progress, or N/
A.
Add Conditional Logic
to your Program
with JOB and IF
StatementsAdd conditional logic and calculations to your program
to compute and store new information. Review JOB and
IF statements, which define and initiate all processing
activities in the sample program to produce a report.Systems
Programmer1 hour Complete, In
progress, or N/
A.
Create and Format a
ReportOnce you have created your first programs with the
first two tasks, you can create a report using a sample
program to use FILE, DEFINE, JOB and IF Statements
and also the INPUT parameter, and PRINT and LINE
Statements.Systems
Programmer1 hour Complete, In
progress, or N/
A.
 201 Easytrieve ® Report Generator 11.6
Task Description RoleTime Estimate Status
Use PRINT Statement
to Optimize Report
ReadabilityUse the PRINT statement in combination with
MASK and HEADING parameters to make reports
more readable. Learn how PRINT activates a
report declaration resulting in a printed report, LINE
determines which fields are printed and in what order,
MASK lets you change the look of fields on your report,
and HEADING enables you to customize column
headings.Systems
Programmer2 hours Complete, In
progress, or N/
A.
Use Statements
to Customize your
ReportUse REPORT, SEQUENCE, CONTROL, SUM,
TITLE, HEADING, and LINE statements to create an 
Easytrieve  report. Learn how REPORT specifies the
type of report and report characteristics, SEQUENCE
defines the order, CONTROL causes a control break,
SUM overrides control totals to sum only specified
fields, TITLE causes the printing of major report titles,
HEADING causes the printing of customized column
headings, and LINE specifies the fields to include on
detail lines and the field order.Systems
Programmer2 hours Complete, In
progress, or N/
A.
Create and Run a Sample Easytrieve Program
Follow the steps in this task to create a sample  Easytrieve  program that you can enter and run on your computer. Use
FILE and DEFINE statements in the Library section and view Report Output.
In this introduction task, we show you a sample  Easytrieve  program that you can enter and run on your computer. You
can follow the task instructions in this tutorial without running the programs to learn the product.
Sample Program
This sample program has only ten lines of code, but it creates a useful report. The program also shows how some of the
most important  Easytrieve  keywords are used. In other programming languages, a more complex program would be
needed to produce the same report.
FILE PERSNL FB(150 1800)                                               
  EMPNAME  17  8  A                                                    
  EMP#      9  5  N                                                    
  DEPT     98  3  N                                                    
  GROSS    94  4  P  2                                                 
JOB INPUT PERSNL NAME FIRST-PROGRAM                                    
  PRINT PAY-RPT                                                        
REPORT PAY-RPT LINESIZE 80                                             
  TITLE 01 'PERSONNEL REPORT EXAMPLE-1'                                
  LINE 01 DEPT EMPNAME EMP# GROSS         
Report Output
The sample program produces the following report, which is an edited display of data from an employee file named
PERSNL.
01/31/18         PERSONNEL REPORT EXAMPLE-1        PAGE    1
 
 
               DEPT    EMPNAME   EMP#      GROSS                       
 
 202 Easytrieve ® Report Generator 11.6
               903     WIMN      12267     373.60                      
               943     BERG      11473     759.20                      
               915     CORNING   02688     146.16                      
               935     NAGLE     00370     554.40                      
               911     ARNOLD    01963     445.50                      
               914     MANHART   11602     344.80   
               917     TALL      11931     492.26                      
               918     BRANDOW   02200     804.64                      
               911     LARSON    11357     283.92                      
               932     BYER      11467     396.68                      
               921     HUSS      11376     360.80                      
               911     POWELL    11710     243.20                      
               943     MCMAHON   04234     386.40      
NOTE
The PERSNL sample file is provided with  Easytrieve . Ask your system administrator where it is stored at your
site. The PERSNL file is created via the JOB08DEM job located in the CBAAJCL library.
Library Section Statements
This section shows the relationship between the sample program and the report, one statement at a time.
The FILE Statement
The first line of our program is:
FILE  PERSNL  FB(150 1800)
The FILE statement contains the FILE keyword. A FILE statement must be included for every file that your program uses
for input or output. The FILE statement tells the program where to get the data that you want processed, and can also
provide information about how that data is stored. To do this, the statement must include a file name. In our example, the
file name is PERSNL.
The remainder of line 1 is optional. FB(150 1800) provides the program with information about how the PERSNL file
is stored, which makes accessing the file more economical. The PERSNL file contains fixed-length records of 150
characters that are stored in 1800 character blocks. This is indicated as one parameter, FB(150 1800), where FB stands
for Fixed, Blocked. 150 indicates the record length and 1800 indicates the block size. Multiple sub-parameters must be
enclosed in parentheses.
The DEFINE Statement
Our program contains four DEFINE statements that describe fields in a PERSNL file record. The word DEFINE does not
need to appear in the statements because it is implied.
EMPNAME   17    8    A                                                 
EMP#       9    5    N                                                 
DEPT      98    3    N                                                 
GROSS     94    4    P    2   
The definitions can also be written with the DEFINE keyword:
DEFINE    EMPNAME  17    8    A                                        
DEFINE    EMP#      9    5    N                                        
DEFINE    DEPT     98    3    N                                        
DEFINE    GROSS    94    4    P    2                                   
 203 Easytrieve ® Report Generator 11.6
NOTE
If you need to define a working storage field outside of the library section, you can use DEFINE statements
within your program logic. When a field is defined there, the DEFINE keyword is required. See Library Section -
Describe and Define Data  for more information about using DEFINE statements.
The previous DEFINE statements describe the four fields in a PERSNL file record that our program uses. DEFINE
statements do not have to describe all the fields in the record or the spaces between fields. You describe only the fields
that the program uses.
The basic components of a field definition are as follows:
Field Name Starting Position in
RecordLength of Field Data  Type Number of Decimal
Positions
EMPNAME 17 8 A
EMP# 9 5 N
DEPT 98 3 N
GROSS 94 4 P 2
When describing a field, you must identify its name, starting position in the record, length, type, and the number of digits to
the right of the decimal point, if any.
The components must be coded in the order that is shown above (left to right) and the components must be separated by
spaces. In our code example, the components are aligned vertically for readability, although alignment is not required.
Field Name
Identifies the field as a unique storage location and is what you use later to refer to your data.
Starting Position
Specifies where the first character of the field begins in the record.
Beginning at the first character of data in a record of the PERSNL file, count nine characters to the right to find the first
character of the EMP# field. The first character of the EMPNAME field is 17 characters to the right of position 1.
                          EMP# field                 EMPNAME field
                        ┌─────┴────────┐        ┌───────────┴───────────┐
│  │  │  │  │  │  │  │  │9 │9 │9 │9 │9 │  │  │  │ X│ X│ X│ X│ X│ X│ X│ X│ ...
└───────────────────────────────────────────────────────────────────────┘──
 1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 . . .
                    A physical record in the PERSNL File
NOTE
Fields do not have to be defined in your program in the same order that they occur in the record. In our example,
we define EMPNAME before EMP# even though it is physically after EMP# in the record.
Field Length
Specifies the number of bytes (characters) of storage that the field occupies in the record. In the previous
example, you can see that EMP# with a field length of 5 occupies 5 bytes or character positions in the PERSNL
record.
Data Type
Describes the kind of data that is stored in a field. In the example, the fields are defined as three different data
types as follows:
Field Data Type Purpose
EMPNAME A - Alphanumeric Stores non-numeric data
 204 Easytrieve ® Report Generator 11.6
EMP# N - Numeric Stores numbers in zoned decimal format
DEPT N - Numeric Stores numbers in zoned decimal format
GROSS P - Packed decimal Stores numbers in internal packed decimal
format
Decimal Positions
In our example, GROSS is the only field that contains numbers to the right of a decimal point. When this field is
printed on your report, it shows up with two numbers to the right of a decimal point (for example, 999.99).
                   Decimal 
                  Positions
                 └─────────┘
                     |
GROSS  94   4   P    2   
Review
In this task, you learned about the FILE and DEFINE statements in the library section. These two statements define the
library of data that is used as input to processing activities:
•FILE describes the data file that the program is accessing (or creating).
•DEFINE describes the fields in the file that the program uses.
NOTE
For more Information about the library section, see Library Section - Describe and Define Data .
Next task
Once you have defined your data, you can continue with processing activities.
The next task is Add Conditional Logic to your Program with JOB and IF statements .
Add Conditional Logic to your Program with JOB and IF Statements
Learn about JOB activity in  Easytrieve , which defines and initiates all processing activities to produce a report as well as
conditional statements and a calculation for salary deductions.
In the previous task, you were introduced to a complete  Easytrieve  program and explained the library section. This task
explains the JOB activity, which defines and initiates all processing activities in our sample program to produce the report.
Conditional statements and a calculation for salary deductions are included in the example.
The JOB Statement
The first line after the library section in our sample program is the JOB statement:
JOB INPUT PERSNL NAME FIRST-PROGRAM
A JOB statement indicates the beginning of processing. The JOB statement can also automatically provide input (if input
is available) to the processing statements that follow it. In our sample statement, the parameters that follow the word JOB
are optional.
 205 Easytrieve ® Report Generator 11.6
Input to a JOB Activity
Typically, processing requires some kind of file input. Most programming languages require you to control the availability
of input files. Usually, files are opened and then an input statement is executed in a loop, with the end-of-file condition
being checked each time the loop is executed.
Although you can control input,  Easytrieve  can also provide automatic input capability.
Automatic Input
The INPUT parameter of the JOB statement indicates that the named file (PERSNL in our example) should be made
automatically available to your program. It is like saying, "I want to use this file" and letting  Easytrieve  do the necessary
steps.
Because our sample program has only one input file (PERSNL), the INPUT parameter on the JOB statement is optional.
Without it, the program looks for input and uses the only file in our library section, PERSNL. If you do not specify INPUT,
the program looks for input and uses the first file described in the library section. However, if the JOB activity is preceded
by a SORT activity, the program uses the output from that SORT.
NOTE
For more information about SORT, see Activity Section - Input and Output .
Naming a JOB Activity
The next parameter after INPUT in our sample program is NAME. This tells the program that a job name follows.
A JOB activity is typically named for documentation purposes only. It helps to give JOB activities a descriptive name,
especially when you have more than one activity in your program. In our example, we named the JOB activity FIRST-
PROGRAM. We did this by typing the parameter NAME followed by a name (FIRST-PROGRAM) of our choice.
Program Logic
In this section, we add logic to our program.
Conditional Processing
So far, our sample program simply extracts data from a file and creates a report. A more complex program contains
conditions. When a condition is encountered, a test is performed to determine the next processing step.
If This, Then That
Suppose the report that you are working on has to include net pay and deductions. This is the program that we have been
working on so far:
FILE PERSNL FB(150 1800)                                               
  EMPNAME  17  8  A                                                    
  EMP#      9  5  N                                                    
  DEPT     98  3  N                                                    
  GROSS    94  4  P  2 
                                                                       
JOB INPUT PERSNL NAME FIRST-PROGRAM                                    
  PRINT PAY-RPT                                                        
REPORT PAY-RPT LINESIZE 80                                             
  TITLE 01 'PERSONNEL REPORT EXAMPLE-1'                                
  LINE 01 DEPT EMPNAME EMP# GROSS  
 206 Easytrieve ® Report Generator 11.6
The program accesses the field named GROSS, which contains employee gross pay. You know that net pay is the gross
pay minus any deductions, and that employees who earn $500 or more get a 28 percent deduction; the rest do not get
any deduction.
The condition described previously can be stated with a simple conditional expression:
IF  GROSS  GE  500
  DEDUCTIONS = .28 * GROSS
  NET-PAY = GROSS - DEDUCTIONS
ELSE
  NET-PAY = GROSS
  DEDUCTIONS = 0
END-IF
In this expression, we say, "If the gross pay is greater than or equal to 500, deduct 28 percent to give the net pay.
Otherwise, if the gross is less than 500, there are no deductions and net pay is the same as gross."  Easytrieve  requires
an END-IF to complete the expression.
Adding Logic to the JOB Activity
Now that we have a logical statement to describe our condition, we simply type it into our program, placing it in the JOB
activity after the JOB statement:
FILE PERSNL FB(150 1800)                                              
  EMPNAME  17  8  A                                                   
  EMP#      9  5  N                                                   
  DEPT     98  3  N                                                   
  GROSS    94  4  P  2                                          
                                                                      
JOB INPUT PERSNL NAME FIRST-PROGRAM                                   
                                                                     
  IF  GROSS  GE  500                                                 
    DEDUCTIONS = .28 * GROSS                                         
    NET-PAY = GROSS - DEDUCTIONS               New
  ELSE                                         Logic
    NET-PAY = GROSS                                                 
    DEDUCTIONS = 0                                                 
 END-IF                                     
                                                                    
  PRINT PAY-RPT                                                       
REPORT PAY-RPT LINESIZE 80                                            
  TITLE 01 'PERSONNEL REPORT EXAMPLE-1'                               
  LINE 01 DEPT EMPNAME EMP# GROSS                                     
There are several details we still need to take care of. We need a place to store the results for our two new variables,
DEDUCTIONS and NET-PAY. They can be stored in a place known as working storage.
Easytrieve  Working Storage
Unlike many other languages,  Easytrieve  makes defining working storage fields easy. You can place them in the library
section of your program or in the activity section before the logic that requires them.
 207 Easytrieve ® Report Generator 11.6
To define a working storage field, you use the same type of attributes used to describe other fields. However, you use the
letter W to replace the numeric value that normally describes the start location.
DEDUCTIONS  W  4  P  2                                                 
NET-PAY     W  4  P  2  
The previous fields can be described as: working storage fields, four characters long, in packed decimal format with two
decimal places. We place these fields in the library section of our program. They are more easily seen in that section than
if they were placed in the activity section.
FILE PERSNL FB(150 1800)                                               
  EMPNAME    17  8  A                                                  
  EMP#        9  5  N                                                  
  DEPT       98  3  N                                                  
  GROSS      94  4  P  2                                              
  DEDUCTIONS  W  4  P  2                 Working
Storage                      
  NET-PAY     W  4  P  2                 Fields                      
                       
JOB INPUT PERSNL NAME FIRST-PROGRAM                                    
                                                                       
  IF  GROSS  GE  500                                                   
    DEDUCTIONS = .28 * GROSS                                           
    NET-PAY = GROSS - DEDUCTIONS                                       
  ELSE                                                                 
    NET-PAY = GROSS                                                    
    DEDUCTIONS = 0                                                     
  END-IF   
                                                                       
  PRINT PAY-RPT                                                        
REPORT PAY-RPT LINESIZE 80                                             
  TITLE 01 'PERSONNEL REPORT EXAMPLE-1'                                
  LINE 01 DEPT EMPNAME EMP# GROSS                                      
So far, we have used some elementary logic, calculated some values, and created a place to store those values.
Review
In this task, you learned how to add conditional logic and calculations to your program to compute new information. You
also learned how to store the new information. You know that:
•JOB initiates program processing activities and can also provide automatic file input.
•IF is a conditional expression that is used to make decisions, based on certain criteria.
•W designates a working storage field on the DEFINE statement.
NOTE
For more Information about the JOB activity section, see Activity Section - Processing and Logic .
Next Task
In the next task, you learn about how to Create an Easytrieve report using a sample Easytrieve program. Review how
to use FILE, DEFINE, JOB and IF Statements, INPUT parameter of the JOB statement, PRINT Statement, and LINE
Statement.
 208 Easytrieve ® Report Generator 11.6
The next task is Create and Format a Report .
Create and Format a Report
Create a report using a sample  Easytrieve  program. Review how to use FILE, DEFINE, JOB and IF Statements,
INPUT parameter of the JOB statement, PRINT Statement, and LINE Statement.
This article includes basic information about creating a report. For more detailed examples and information about the
features and options that are available in all implementations of the product, see the other articles in the Using  section and
the Language Reference  section.
For information about interfacing Easytrieve  programs with programs that are written in other languages such as COBOL,
C, or C++, see the Programming  section.
Because Easytrieve  is a compiled language that runs in many data processing environments, the examples in this article
are generic and do not address variations between different installations. It is beyond the scope of this article to address
the specifics of all the operating environments in which the product can run.
Create a Report
A sample Easytrieve  program follows. You can enter the code and run the program from your terminal.
FILE PERSNL FB(150 1800)                                                
  EMPNAME  17  8  A                                                     
  EMP#      9  5  N                                                     
  DEPT     98  3  N                                                     
  GROSS    94  4  P  2   
JOB INPUT PERSNL NAME FIRST-PROGRAM                                     
  PRINT PAY-RPT                                                         
REPORT PAY-RPT LINESIZE 80                                              
  TITLE 01 'PERSONNEL REPORT EXAMPLE-1'                                 
  LINE 01 DEPT EMPNAME EMP# GROSS     
When specified, this program produces a formatted report including date, page number, title, column headings, properly
spaced detailed lines, and more as follows:
01/31/91            PERSONNEL REPORT EXAMPLE-1               PAGE    1  
                                                                        
                                                                        
               DEPT    EMPNAME   EMP#      GROSS                        
                                                                        
               903     WIMN      12267     373.60                       
               943     BERG      11473     759.20                       
               915     CORNING   02688     146.16                       
               935     NAGLE     00370     554.40                       
               911     ARNOLD    01963     445.50                       
               914     MANHART   11602     344.80                       
               917     TALL      11931     492.26                       
               918     BRANDOW   02200     804.64                       
               911     LARSON    11357     283.92                       
               932     BYER      11467     396.68                       
               921     HUSS      11376     360.80                       
               911     POWELL    11710     243.20                       
 209 Easytrieve ® Report Generator 11.6
               943     MCMAHON   04234     386.40                      
This report is simply an edited display of fields from an employee file named PERSNL.
NOTE
The PERSNL sample file is provided with the product. Ask your system administrator where it is stored at your
site.
The FILE and DEFINE Statements
The FILE  and DEFINE  statements define the library of data that is used as input to any processing activities.
The first line of this program contains the FILE statement. A FILE statement must be included for every file you use as
input to or output from your program. It tells the program where to get the data that you want processed and can also
describe how the data is stored.
There are four DEFINE statements in our sample program. The first definition is EMPNAME. DEFINE statements describe
fields in a record of the PERSNL file.
You do not see the word DEFINE in the previous lines, but it is implied. For example, we could have specified:
DEFINE    EMPNAME  17    8    A                                        
NOTE
You can also use DEFINE statements within the program logic to define working storage. In that case, the
DEFINE keyword is required.
The JOB and IF Statements
The JOB and IF statements define and initiate all processing activities in our sample program. You can also add
conditional statements and calculations for salary deductions.
The JOB statement indicates the beginning of some form of processing. The JOB statement can also automatically
provide input (if input is available) to the processing statements that follow it.
Although Easytrieve  lets you control input, automatic input is provided as an alternative.
Automatic Input
Using the INPUT parameter of the JOB statement indicates that the named file (in this case PERSNL) is to be made
automatically available to your program.
If INPUT is not specified, the program looks for input and uses the first file that is described in the library section, unless
the JOB activity is preceded by a SORT activity. In that case, the program uses the output from that SORT. For more
information about SORT, see Sorting Files . Because our sample program has only one input file (PERSNL), the INPUT
parameter on the JOB statement is optional. Without the INPUT parameter, our sample program checks for input and
uses the first file that is encountered, which is PERSNL (the only file in our library section).
Naming a JOB Activity
The next element after the INPUT parameter in our sample program is the word NAME. NAME indicates that a job name
follows.
The IF Statement
In the previous report program, we have only extracted some data from a file and printed it out. You can also include IF
statements to add conditions to the program.
 210 Easytrieve ® Report Generator 11.6
In the sample program, the program accesses a field called GROSS, which contains employee gross pay. Because net
pay (take home pay) is the gross pay minus any deductions, you realize that you must determine what to deduct. For
example, we deduct 28 percent from employees who earn $500 or more.
You can state this condition as follows with a simple conditional expression:
IF  GROSS  GE  500
  DEDUCTIONS = .28 * GROSS
  NET-PAY = GROSS - DEDUCTIONS
ELSE
  NET-PAY = GROSS
  DEDUCTIONS = 0
END-IF
In the previous expression, if the gross pay is greater than or equal to 500, deduct 28 percent to obtain the net pay.
Otherwise, if the gross is less than 500, there are no deductions and net pay equals gross pay. Easytrieve  requires an
END-IF statement to complete the expression.
To add conditional logic to the program, place it in the JOB activity section after the JOB statement. You can store the
results of the new variables, DEDUCTIONS and NET-PAY, in working storage.
Working Storage
Unlike many other programming languages, the definition of working storage fields in Easytrieve  is easy. You can place
them in the library section of your program, or in the activity section before the logic that uses them.
To define a working storage field, use the same type of attributes that are used to describe other fields. However, use the
letter W to replace the numeric value that typically describes the start location.
DEDUCTIONS  W  4  P  2                                                  
NET-PAY     W  4  P  2                                                 
The code describes two working storage fields, four characters in length, in packed decimal format, with two decimal
places.
The PRINT Statement
When the conditional statements have run against a record in the PERSNL file, the PRINT  statement tells the program to
execute the report definition statements. In the previous PRINT statement example, these statements are identified by a
user-supplied name, PAY RPT. This name ties the PRINT statement to a specific report of the same name as indicated
on the REPORT statement. If the report name is not included, the first report in the JOB activity section is executed
regardless of whether it has a name.
A report declaration consists of a series of statements that define the format and content of a report. These statements
consist of the REPORT statement, report definition statements, and report procedures. So far, we have seen three such
statements in our sample program:
•REPORT
•TITLE
•LINE
When the report statements have been executed, control is returned to the beginning of the JOB activity section where the
next record is processed or end of file processing is performed. All output routines, line counts, and page advances are
handled automatically.
 211 Easytrieve ® Report Generator 11.6
The LINE Statement
The LINE  statement is responsible for printing detail lines on the report. It tells the program what fields to print and the
order in which to print them.
To add DEDUCTIONS and NET PAY to the report output, specify:
LINE  01  DEPT EMPNAME EMP# GROSS NET PAY DEDUCTIONS
New Sample Program
We can run our updated program to generate a report. The updated program with all the changes that we have described
in this article is:
FILE PERSNL FB(150 1800)                                                
  EMPNAME    17  8  A                                                   
  EMP#        9  5  N                                                   
  DEPT       98  3  N                                                   
  GROSS      94  4  P  2                                                
  DEDUCTIONS  W  4  P  2                                                
  NET-PAY     W  4  P  2     
JOB INPUT PERSNL NAME FIRST-PROGRAM                                     
                                                                        
  IF  GROSS  GE  500                                                    
    DEDUCTIONS = .28 * GROSS                                            
    NET-PAY = GROSS - DEDUCTIONS                                        
  ELSE                                                                  
    NET-PAY = GROSS                                                     
    DEDUCTIONS = 0                                                      
  END-IF                                                                
                                                                        
  PRINT PAY-RPT                                                         
REPORT PAY-RPT LINESIZE 80                                              
  TITLE 01 'PERSONNEL REPORT EXAMPLE-1'                                 
  LINE  01  DEPT EMPNAME EMP# GROSS NET-PAY DEDUCTIONS
The sample output from this program follows. Two new columns have been added: NET-PAY and DEDUCTIONS
01/31/91            PERSONNEL REPORT EXAMPLE-1               PAGE    1  
                                                                        
        DEPT   EMPNAME    EMP#      GROSS       NET-PAY    DEDUCTIONS  
                                                                      
        903    WIMN       12267      373.60       373.60         .00   
        943    BERG       11473      759.20       546.63      212.57   
        915    CORNING    02688      146.16       146.16         .00   
        935    NAGLE      00370      554.40       399.17      155.23   
        911    ARNOLD     01963      445.50       445.50         .00   
        914    MANHART    11602      344.80       344.80         .00   
        917    TALL       11931      492.26       492.26         .00   
        918    BRANDOW    02200      804.64       579.35      225.29   
        911    LARSON     11357      283.92       283.92         .00   
        932    BYER       11467      396.68       396.68         .00   
        921    HUSS       11376      360.80       360.80         .00   
 212 Easytrieve ® Report Generator 11.6
        911    POWELL     11710      243.20       243.20         .00   
        943    MCMAHON    04234      386.40       386.40         .00  
Format Report Output
You can format numeric values of your report output with dollar signs by adding an edit mask to the DEFINE statement.
You can also define custom field headings.
Edit Masks
An edit mask is a pattern of characters that specify how numeric data should be printed.
NOTE
Alphanumeric fields cannot be edited.
In the following example, edit masks have been added to the three currency fields in our example program so they print
with dollar signs:
GROSS         94   4   P   2   MASK (A '$$,$$9.99')                    
NET-PAY        W   4   P   2   MASK A                                   
DEDUCTIONS     W   4   P   2   MASK (A BWZ)     
The MASK parameter of the DEFINE statement indicates that an edit mask follows. In the previous example, the actual
mask consists of the characters '$$,$$9.99'. Masks are always enclosed in single quotes.
The effect on our report of adding these masks is as follows:
01/31/91               PERSONNEL REPORT EXAMPLE-1               PAGE   1
                                                                        
         DEPT   EMPNAME    EMP#      GROSS       NET-PAY     DEDUCTIONS 
                                                                        
         903    WIMN       12267      $373.60      $373.60             
         943    BERG       11473      $759.20      $546.63     $212.57 
         915    CORNING    02688      $146.16      $146.16             
         935    NAGLE      00370      $554.40      $399.17     $155.23 
         911    ARNOLD     01963      $445.50      $445.50             
         914    MANHART    11602      $344.80      $344.80             
         917    TALL       11931      $492.26      $492.26             
         918    BRANDOW    02200      $804.64      $579.35     $225.29 
         911    LARSON     11357      $283.92      $283.92             
         932    BYER       11467      $396.68      $396.68             
         921    HUSS       11376      $360.80      $360.80             
         911    POWELL     11710      $243.20      $243.20             
         943    MCMAHON    04234      $386.40      $386.40            
NOTE
Any leading zeros are suppressed and each value has a dollar sign. Any all-zero values in the DEDUCTIONS
column are printed as blanks.
Field Headings
So far in our example program, field (or column) headings have come directly from the field names themselves. The
program automatically uses field names specified on the DEFINE statement as column headings, unless column headings
are described separately.
 213 Easytrieve ® Report Generator 11.6
One way to describe alternative column headings is with the HEADING parameter of the DEFINE statement. For example,
you can replace the cryptic heading EMP# with the more readable heading EMPLOYEE NUMBER as follows:
EMPNAME 17    8    A                                                    
EMP#     9    5    N   HEADING ('EMPLOYEE' 'NUMBER')                   
DEPT    98    3    N                              
Placing each word in single quotes indicates that the headings should be printed on separate lines, one word over the
other.
The following example shows how the new heading prints when the program is run:
01/31/91               PERSONNEL REPORT EXAMPLE-1               PAGE   1
                                                                        
                         EMPLOYEE                                       
       DEPT   EMPNAME     NUMBER      GROSS       NET-PAY     DEDUCTIONS
You can include headings on the DEFINE statement for any fields that need better identification than the field name.
Next Task
In the next task, you learn about the LINE statement and the PRINT statement, which initiates printing of your report. The
MASK and HEADING parameters that let you edit and label your data are also explained.
The next task is Use PRINT Statement to Optimize Report Readability .
Use PRINT Statement to Optimize Report Readability
This task introduces you to the PRINT statement in  Easytrieve  which activates the report statements that result in a
printed report.
A report declaration that follows the PRINT statement consists of a series of statements that define the format and content
of a report. These statements consist of the REPORT statement, report definition statements, and report procedures. So
far, we have seen three such statements in our sample program:
•REPORT
•TITLE
•LINE
In our sample program, the PRINT statement is placed directly after the conditional statements that we added in task 3:
  END-IF                                                               
 
  PRINT PAY-RPT                                                        
REPORT PAY-RPT LINESIZE 80  
Once the conditional statements have been run against a record of the PERSNL file, the PRINT statement tells 
Easytrieve  to execute the report definition statements. In the previous PRINT statement example, these statements are
identified by a user-supplied name, PAY-RPT. This name ties the PRINT statement to a specific report of the same name
as indicated on the REPORT statement. If the report name is not included, the first report in the JOB activity section is
executed, regardless of whether it has a name.
After the report statements have been executed, control is returned to the beginning of the JOB activity section where the
next record is processed or end-of-file processing is performed. All output routines, line counts, and page advances are
handled automatically when the PRINT statement is executed.
 214 Easytrieve ® Report Generator 11.6
LINE Statement
The last line in the program is currently:
LINE  01  DEPT EMPNAME EMP# GROSS                                      
This line causes the detail lines of the report to be printed. The LINE statement specifies the fields to print and the order in
which to print them.
To add DEDUCTIONS and NET-PAY to the report output, we add the field names in the order that they should appear in
the report:
LINE  01  DEPT EMPNAME EMP# GROSS NET-PAY DEDUCTIONS    
The program with all the changes that we have made is as follows:
FILE PERSNL FB(150 1800)                                               
  EMPNAME    17  8  A                                                  
  EMP#        9  5  N                                                  
  DEPT       98  3  N                                                  
  GROSS      94  4  P  2                                               
  DEDUCTIONS  W  4  P  2                                               
  NET-PAY     W  4  P  2      
 
JOB INPUT PERSNL NAME FIRST-PROGRAM                                    
 
  IF  GROSS  GE  500                                                   
    DEDUCTIONS = .28 * GROSS                                           
    NET-PAY = GROSS - DEDUCTIONS                                       
  ELSE                                                                 
    NET-PAY = GROSS                                                    
    DEDUCTIONS = 0                                                     
  END-IF  
 
  PRINT PAY-RPT                                                        
REPORT PAY-RPT LINESIZE 80                                             
  TITLE 01 'PERSONNEL REPORT EXAMPLE-1'                                 LINE 01 DEPT EMPNAME EMP# GROSS NET-
PAY DEDUCTIONS 
The sample output from this program follows. As you can see, the NET-PAY and DEDUCTIONS columns have been
added.
01/31/18            PERSONNEL REPORT EXAMPLE-1               PAGE    1 
                                                                       
  DEPT   EMPNAME    EMP#      GROSS        NET-PAY     DEDUCTIONS 
  
  903    WIMN       12267      373.60       373.60
.00  
  943    BERG       11473      759.20       546.63        212.57   
  915    CORNING    02688      146.16       146.16           .00   
  935    NAGLE      00370      554.40       399.17        155.23  
  911    ARNOLD     01963      445.50       445.50           .00   
  914    MANHART    11602      344.80       344.80           .00   
  917    TALL       11931      492.26       492.26           .00   
  918    BRANDOW    02200      804.64       579.35        225.29   
 215 Easytrieve ® Report Generator 11.6
  911    LARSON     11357      283.92       283.92           .00  
  932    BYER       11467      396.68       396.68           .00   
  921    HUSS       11376      360.80       360.80           .00   
  911    POWELL     11710      243.20       243.20           .00   
  943    MCMAHON    04234      386.40       386.40           .00
Editing Your Report Output
In the previous section, we added NET-PAY and DEDUCTIONS to our report. Those values and GROSS are dollar
values. Until now, dollar values have printed as ordinary numbers with decimal places. We can modify the field definitions
by adding an edit mask so that the values in the report have dollar signs.
Edit Mask
An edit mask is a pattern of characters that specifies how numeric data should appear in the report.
NOTE
Alphanumeric fields cannot have an edit mask.
For example, we have added edit masks to the three currency fields in our example program so that they print with dollar
signs:
GROSS         94   4   P   2   MASK (A '$$,$$9.99')  
NET-PAY        W   4   P   2   MASK A 
DEDUCTIONS     W   4   P   2   MASK (A BWZ)
MASK is a parameter of the DEFINE statement that indicates that an edit mask follows. Edit masks are enclosed in single
quotes. In this code segment, the edit mask named A consists of the characters '$$,$$9.99'. Naming the mask lets you
use the same mask for other fields without defining it each time.
Adding the edit masks affects our report as follows:
01/31/18               PERSONNEL REPORT EXAMPLE-1               PAGE   1
 
         DEPT   EMPNAME    EMP#      GROSS       NET-PAY     DEDUCTIONS
 
         903    WIMN       12267      $373.60     $373.60 
         943    BERG       11473      $759.20     $546.63       $212.57
         915    CORNING    02688      $146.16     $146.16  
         935    NAGLE      00370      $554.40     $399.17       $155.23
         911    ARNOLD     01963      $445.50     $445.50  
         914    MANHART    11602      $344.80     $344.80  
         917    TALL       11931      $492.26     $492.26  
         918    BRANDOW    02200      $804.64     $579.35       $225.29
         911    LARSON     11357      $283.92     $283.92  
         932    BYER       11467      $396.68     $396.68  
         921    HUSS       11376      $360.80     $360.80  
         911    POWELL     11710      $243.20     $243.20  
         943    MCMAHON    04234      $386.40     $386.40 
NOTE
Leading zeros are suppressed and each value has a dollar sign. The BWZ parameter causes any all-zero values
in the DEDUCTIONS column to appear as blanks.
The following explanations and rules apply to the edit masks in our example:
 216 Easytrieve ® Report Generator 11.6
•Each digit in a field must be designated in the edit mask. Because a four-byte packed decimal field is capable of
containing seven digits, we need to designate seven digits in the mask. This is done with $$$$999.
•Dollar signs ($) in the edit mask indicate that a dollar sign is to be printed prior to the first non-zero digit of the printed
field. This is called a floating dollar sign. It means that, if one or more high-order zeros are stored in the positions
where a dollar sign appears in the mask, they are suppressed and replaced with a single dollar sign. For example:
Mask Field Value Resulting Output
'$$,$$9.99' 1234567 $12,345.67
0123456 $1,234.56
0012345 $123.45
0001234 $12.34
0000123 $1.23
0000012 $0.12
•As the number of leading zeros increases, the dollar sign automatically floats to the right.
•The digit 9 indicates that any value occurring in that position is printed as a digit. In the above example, all values
(including zeros) in the ones column or to the right of the decimal are printed as digits.
•Commas and decimal points are printed just as indicated. In the above example, you can see that commas are
suppressed along with high-order zeros for numbers less than 1000.
•When the same mask is to be used on more than one field, you can avoid coding the mask more than once by naming
it, and then specifying only the name on subsequent fields. Names can be any letter from A to Y.
In our example, we named the mask used on the GROSS field A. Then we specified the letter A on the NET-PAY
and DEDUCTIONS fields instead of coding the mask again. Remember, multiple parameters and subparameters are
enclosed in parentheses.
•To suppress all-zero values from printing (if you find that desirable) simply code BWZ (blank when zero) after the mask
or mask name. Because some employees in our report can have zero deductions, we included BWZ.
Field Headings
So far in our example program, field (or column) headings have come directly from the field names themselves. 
Easytrieve  uses field names specified on the DEFINE statement as column headings by default, unless column headings
are described.
One way to describe alternative column headings for better identification is with the HEADING parameter of the field
definition. For example, you can replace the default heading EMP# with the more descriptive heading EMPLOYEE
NUMBER as follows:
EMPNAME 17    8    A                                                   
EMP#     9    5    N   HEADING ('EMPLOYEE' 'NUMBER')  
DEPT    98    3    N    
By placing each word in single quotes, you indicate that the heading should be stacked, one word over the other.
The following report segment shows the effect of adding the HEADING parameter:
01/31/18               PERSONNEL REPORT EXAMPLE-1               PAGE   1                                  
                         EMPLOYEE                                       
       DEPT   EMPNAME     NUMBER      GROSS       NET-PAY     DEDUCTIONS  
        
 217 Easytrieve ® Report Generator 11.6
Review
In this task, you learned how the PRINT statement works and also how to use the MASK and HEADING parameters to
make your reports more readable. You have learned that:
•PRINT activates a report declaration resulting in a printed report.
•LINE determines which fields are printed on your report and in what order they are printed.
•MASK lets you change the look of fields on your report.
•HEADING enables you to customize column headings on your report.
In this task, we have made some minor changes to our ongoing program example. Here is how our program currently
looks:
FILE PERSNL FB(150 1800)                                               
  EMPNAME    17  8  A                                                  
  EMP#        9  5  N HEADING ('EMPLOYEE' 'NUMBER')                  
  DEPT       98  3  N                                                  
  GROSS      94  4  P   2   MASK (A '$$,$$9.99')                       
  NET-PAY     W  4  P   2   MASK A                                     
  DEDUCTIONS  W  4  P   2   MASK (A BWZ) 
 
JOB INPUT PERSNL NAME FIRST-PROGRAM                                    
 
  IF  GROSS  GE  500                                                   
    DEDUCTIONS = .28 * GROSS                                           
    NET-PAY = GROSS - DEDUCTIONS                                       
  ELSE                                                                 
    NET-PAY = GROSS                                                    
    DEDUCTIONS = 0                                                     
  END-IF 
 
  PRINT PAY-RPT                                                        
REPORT PAY-RPT LINESIZE 80                                             
  TITLE 01 'PERSONNEL REPORT EXAMPLE-1'                                
  LINE  01  DEPT EMPNAME EMP# GROSS NET-PAY DEDUCTIONS                 
NOTE
For more Information, see Activity Section - Input and Output  about the PRINT statement.
Next Task
In the next task, you will learn about report declarations.
The next task is Use Statements to Customize your Report .
Use Statements to Customize your Report
Learn how to use the following statements and add them to your Easytrieve program: SEQUENCE, CONTROL, SUM,
HEADING.
The example program that we have been discussing currently has only three statements in its report declaration:
REPORT, TITLE, and LINE.
REPORT  PAY-RPT  LINESIZE  80                                          
 218 Easytrieve ® Report Generator 11.6
  TITLE  01  'PERSONNEL REPORT EXAMPLE-1'                              
  LINE   01  DEPT EMPNAME EMP# GROSS NET-PAY DEDUCTIONS  
In this task, we introduce the following statements and add them to our program:
•SEQUENCE
•CONTROL
•SUM
•HEADING
The REPORT Statement
The REPORT Statement must be the first statement in your report declaration. This statement precedes the report
description, and identifies the type of report and its various physical characteristics.
In our sample program, we identify the report by name (PAY-RPT) and also specify a LINESIZE of 80, but both of these
properties are optional. Because our program has only one report, we could have left the report name off both the PRINT
and the REPORT statements. A line size of 80 restricts report output to 80 characters to each printed line. If you enter
programs as we proceed and review the output at your terminal, then 80 characters per line is appropriate. Most terminals
display only 80 characters on a screen.
Report Definition Statements
Report definition statements define the contents of a report. These statements are presented in the order they must
occur in your report declaration. We add new statements to our example program as we go, showing the effects on report
output.
There are six report definition statements in  Easytrieve . When used, they must occur after the REPORT statement in the
following order:
•SEQUENCE
•CONTROL
•SUM
•TITLE
•HEADING
•LINE
A mnemonic for these statements and their order is:
    Siblings  Can  Sometimes  Tell  Horrible  Lies  
    E         O    U          I     E         I 
    Q         N    M          T     A         N 
    U         T               L     D         E 
    E         R               E     I   
    N         O                     N   
    C         L                     G   
    E   
Brief explanations of these statements follow. The order in which the statements are written is logical.
The SEQUENCE Statement
The SEQUENCE statement causes your report to be sorted on a specified key in ascending or descending order. In our
example, the report output should be sequenced on department in ascending order. We accomplish this by placing the
SEQUENCE statement and the field name DEPT after the REPORT statement:
 219 Easytrieve ® Report Generator 11.6
REPORT   PAY-RPT   LINESIZE   80                                       
  SEQUENCE DEPT                                                         
  TITLE 01 'PERSONNEL REPORT EXAMPLE-1'                                
  LINE  01 DEPT EMPNAME EMP# GROSS NET-PAY DEDUCTIONS     
Ascending order is the default for the SEQUENCE statement. For descending order, enter D after the field name,
separated by a space.
When we run our program, this report is produced:
01/31/18               PERSONNEL REPORT EXAMPLE-1               PAGE   1
                                                                       
                         EMPLOYEE                                      
       DEPT   EMPNAME     NUMBER      GROSS       NET-PAY     DEDUCTIONS
                                                                       
       901    WALTERS     11211        $424.00      $424.00            
       903    WIMN        12267        $373.60      $373.60            
       912    LOYAL       04225        $295.20      $295.20            
       914    MANHART     11602        $344.80      $344.80            
       914    VETTER      01895        $279.36      $279.36            
       914    GRECO       07231      $1,004.00      $722.88      $281.12
       914    CROCI       08262        $376.00      $376.00            
       914    RYAN        10961        $399.20      $399.20            
       915    CORNING     02688        $146.16      $146.16            
       917    TALL        11931        $492.26      $492.26            
       918    BRANDOW     02200        $804.64      $579.35      $225.29
       918    EPERT       07781        $310.40      $310.40            
       919    DENNING     02765        $135.85      $135.85            
       920    MILLER      05914        $313.60      $313.60            
NOTE
The records are now in order by department number. When you use the SEQUENCE statement, you do not
need to define any extra files or additional input/output commands in your program.
The CONTROL Statement
The CONTROL statement defines a control break on a specified field that is called the control field . The CONTROL
statement causes all quantitative fields (that is, fields with decimal positions) to be totaled at the time of the control break
and for a grand totals to appear at the end of the report.
Because we have sequenced our report by the DEPT field, we can also request a control break on the same field. This
gives us totals of GROSS, NET-PAY, and DEDUCTIONS for each department. To accomplish this, we add the CONTROL
statement and the field name DEPT after the SEQUENCE statement:
REPORT  PAY-RPT LINESIZE 80                                            
  SEQUENCE DEPT                                                        
  CONTROL DEPT 
  TITLE 01 'PERSONNEL REPORT EXAMPLE-1'                                
  LINE  01 DEPT EMPNAME EMP# GROSS NET-PAY DEDUCTIONS    
With that additional statement, gross and net pay totals are shown for each department with grand totals at the end of the
report:
 220 Easytrieve ® Report Generator 11.6
01/31/18             PERSONNEL REPORT EXAMPLE-1              PAGE      1
                                                                       
                     EMPLOYEE                                          
   DEPT   EMPNAME     NUMBER      GROSS          NET-PAY      DEDUCTIONS
                                                                       
   901    WALTERS     11211         $424.00         $424.00            
   901                              $424.00         $424.00            
                                                                       
   903    WIMN        12267         $373.60         $373.60            
   903                              $373.60         $373.60            
                                                            
                                                                       
   912    LOYAL       04225         $295.20         $295.20            
   912                              $295.20         $295.20            
                                                                  
   914    MANHART     11602         $344.80         $344.80            
          VETTER      01895         $279.36         $279.36            
          GRECO       07231       $1,004.00         $722.88      $281.12
          CROCI       08262         $376.00         $376.00            
          RYAN        10961         $399.20         $399.20            
   914                            $2,403.36        $2,122.24       $281.12
                                                                       
                                  $3,496.16        $3,215.04 
The SUM Statement
Suppose that you do not want totals for GROSS, NET-PAY, and DEDUCTIONS at each control break. You only want a
total for GROSS so you can get an idea of what the salary expense is. You can override the CONTROL statement that
normally totals all quantitative fields with the SUM statement.
The SUM statement specifies the quantitative fields that you want totaled on a control break. Using a SUM statement
ensures that only fields that are specified on the SUM statement are totaled. We have modified the program so that only
the gross pay has a total:
REPORT  PAY-RPT  LINESIZE  80                                          
  SEQUENCE DEPT                                                        
  CONTROL  DEPT                                                        
  SUM GROSS 
  TITLE 01 'PERSONNEL REPORT EXAMPLE-1'                                
  LINE  01 DEPT EMPNAME EMP# GROSS NET-PAY DEDUCTIONS   
Now, GROSS is the only field that is totaled:
01/31/18                PERSONNEL REPORT EXAMPLE-1             PAGE    1
                                                                       
                        EMPLOYEE                                       
      DEPT   EMPNAME     NUMBER      GROSS        NET-PAY     DEDUCTIONS
                                                                       
      901    WALTERS     11211         $424.00      $424.00            
 221 Easytrieve ® Report Generator 11.6
      901                              $424.00                         
                                                                       
      903    WIMN        12267         $373.60      $373.60            
      903                              $373.60                         
                                                            
                                                                       
      912    LOYAL       04225         $295.20      $295.20            
      912                              $295.20                         
                 
      914    MANHART     11602         $344.80      $344.80            
             VETTER      01895         $279.36      $279.36            
             GRECO       07231       $1,004.00      $722.88      $281.12
             CROCI       08262         $376.00      $376.00            
             RYAN        10961         $399.20      $399.20            
  914 $2,403.36   
The TITLE Statement
The TITLE statement causes the title to appear in our report. We have been calling our report PERSONNEL REPORT
EXAMPLE-1 throughout the tutorial.
REPORT  PAY-RPT  LINESIZE  80                                          
  SEQUENCE DEPT                                                        
  CONTROL  DEPT                                                        
  SUM      GROSS                                                       
  TITLE 01 'PERSONNEL REPORT EXAMPLE-1' 
  LINE  01 DEPT EMPNAME EMP# GROSS NET-PAY DEDUCTIONS 
You can change it to any appropriate title. Include the word TITLE followed by a title number, followed by your title in
single quotes. If you have only one title, you can omit the title number; it defaults to 01. When you want more than one
title, you must number all TITLE statements in ascending order.
The result of the TITLE statement follows.
01/31/18                PERSONNEL REPORT EXAMPLE-1           PAGE      1
                                                                       
                        EMPLOYEE                                       
      DEPT   EMPNAME     NUMBER      GROSS        NET-PAY     DEDUCTIONS
                                                                       
      901    WALTERS     11211         $424.00      $424.00            
      901                              $424.00         
                                                                       
      903    WIMN        12267         $373.60      $373.60            
      903                              $373.60                         
The system date and the page number are automatically printed on the same line. The Activity Section -- Reporting
section explains how to override this feature.
 222 Easytrieve ® Report Generator 11.6
The HEADING Statement
The HEADING statement, like the HEADING parameter of the DEFINE statement, prints user-defined column headings
for specified fields. It overrides the HEADING parameter of the DEFINE statement if one already exists for the field that
you are describing. For more information, see Report Output with PRINT Statement.
We have added this statement to our program to show you how this statement works. Suppose that we have decided
the field name EMPNAME is not really a good column heading. We want EMPLOYEE NAME instead. As we did with the
EMP# field, we can change our existing column heading.
We do so by typing the word HEADING followed by the field name EMPNAME, followed by the new column heading:
REPORT  PAY-RPT  LINESIZE  80                                          
  SEQUENCE DEPT                                                        
  CONTROL  DEPT                                                        
  SUM      GROSS                                                       
  TITLE 01 'PERSONNEL REPORT EXAMPLE-1'                                
  HEADING EMPNAME ('EMPLOYEE' 'NAME')                                  
  LINE  01 DEPT EMPNAME EMP# GROSS NET-PAY DEDUCTIONS  
To be consistent with our other heading, EMPLOYEE NUMBER, we have described our new heading so that it stacks
EMPLOYEE on top of NAME. To do this, type single quotes around each word in the heading. The parentheses are
required because the two words, each in single quotes, are treated the same as any other multiple parameters. Here's
how it prints:
01/31/18                PERSONNEL REPORT EXAMPLE-1            PAGE     1
                                                                       
             EMPLOYEE    EMPLOYEE                                       
      DEPT     NAME      NUMBER     GROSS        NET-PAY     DEDUCTIONS
                                                                       
      901    WALTERS     11211        $424.00      $424.00             
      901                             $424.00                          
                                                                       
      903    WIMN        12267        $373.60      $373.60             
      903                             $373.60                          
                                                      
                                                                      
      912    LOYAL       04225        $295.20      $295.20             
      912                             $295.20                          
                                                                       
      914    MANHART     11602        $344.80      $344.80             
             VETTER      01895        $279.36      $279.36             
             GRECO       07231      $1,004.00      $722.88      $281.12
             CROCI       08262        $376.00      $376.00             
             RYAN        10961        $399.20      $399.20             
      914                           $2,403.36                          
The LINE Statement
The LINE statement defines the contents of a printed line (detail line) in your report.
NOTE
You must include the LINE statement in your report declaration.
 223 Easytrieve ® Report Generator 11.6
In our example program, it defines which fields we want printed on a line and the order in which we want them printed:
REPORT  PAY-RPT  LINESIZE  80                                          
  SEQUENCE DEPT                                                        
  CONTROL  DEPT                                                        
  SUM      GROSS                                                       
  TITLE 01 'PERSONNEL REPORT EXAMPLE-1'                                
  HEADING EMPNAME ('EMPLOYEE' 'NAME')                                  
  LINE DEPT EMPNAME EMP# GROSS NET-PAY DEDUCTIONS         
Review
You have learned how the REPORT, SEQUENCE, CONTROL, SUM, TITLE, HEADING, and LINE statements are used in
the creation of an  Easytrieve  report.
In summary:
•REPORT designates the beginning of a report declaration and can specify the type of report and report characteristics.
•SEQUENCE puts your report in alphabetical or numerical order, based on the contents of a field or fields.
•CONTROL causes a control break, based on the contents of a field. It causes the printing of control totals and grand
totals for all quantitative fields.
•SUM overrides control totals and causes totals only for specified fields.
•TITLE causes the printing of major report titles.
•HEADING causes the printing of customized column headings.
•LINE specifies the fields to include on detail lines and the field order.
NOTE
For more information about report declarations, see Activity Section - Reporting .
This concludes the tasks in the Day 1 Task Checklist. You can now create your own standard reports using what you have
learned.
Library Section - Describe and Define Data
Create  Easytrieve  programs that use input or output files by describing and defining how data is stored before
processing with FILE and DEFINE statements.
Easytrieve  Syntax Rules
The free-form English language structure of  Easytrieve  makes it easy for you to develop an efficient, flexible
programming style. To avoid programming errors, follow these syntax rules.
Statement Area
All  Easytrieve  source statements are records of 80 characters each. The default statement area is in columns 1 through
72. You can place your  Easytrieve  code anywhere within these columns. You can indent or line up certain statements for
readability, but it is not required.
Multiple Statements
The statement area typically contains a single statement. However, you can enter multiple statements on a single line.
A period followed by a space indicates the end of a statement. The next  Easytrieve  statement can start at the next
available position of the statement area (after the space). For example, the following two  Easytrieve  statements are on
one line:
 224 Easytrieve ® Report Generator 11.6
 COST = FIXED + VARIABLE.  PRICE = COST + PROFIT
 
Comments
When the first non-blank character of a statement is an asterisk (*), the remainder of that line is considered to be a
comment that is ignored by the  Easytrieve  compiler. You can use comment statements any place within a program,
except within a continued statement. A statement containing all blanks is also treated as a comment.
To place a comment on the same line as a statement, code a period (.), one or more spaces, an asterisk (*), then the
comment.
Continuations
The last non-blank character of a statement terminates the statement unless that character is a minus (-) or a plus sign
(+).
•The - indicates that the statement continues at the start of the next statement area.
•The + indicates that the statement continues with the first non-blank character in the next statement area.
The difference between - and + is important only when continuing a line in the middle of a word. Continuation of a line
between words is the same for both. The following continued statements produce identical results:
 FIELD-NAME   W   6   A   +                                   
              VALUE   'ABC -                                  
 DEF'                                                         
  
 FIELD-NAME   W   6   A   +                                   
              VALUE   'ABC +                                  
                       DEF'                                   
 
Words and Delimiters
One or more words make up each  Easytrieve  statement. A word can be a keyword, field name, literal, or symbol. All
words begin with a non-blank character. A delimiter or the end of the statement area terminates these words. Delimiters
make statements readable but are not considered part of the attached word.  Easytrieve  delimiters are shown in the
following table:
Delimiter Description
space The basic delimiter within each statement.
' single quote Encloses literals that are alphanumeric.
. period Terminates a statement.
, comma Used optionally for readability.
() parentheses Enclose multiple parameters and portions of arithmetic
expressions (the left parenthesis acts as a basic delimiter).
: colon Used as a delimiter for file, record, and field qualifications.
At least one space must follow all delimiters, except the left parenthesis and colon {( and :}. The word RECORD-COUNT
is shown below with various delimiters:
 RECORD-COUNT
 FILEONE:RECORD-COUNT
 (RECORD-COUNT)
 225 Easytrieve ® Report Generator 11.6
 'RECORD-COUNT'
 RECORD-COUNT,
 RECORD-COUNT.
 
Keywords
Keywords are words having specific meaning to  Easytrieve . Some keywords are reserved words. You can use non-
reserved keywords in the appropriate context as field names, whereas reserved words cannot be used as field names. For
a list of all reserved keywords, see Symbols and Reserved Words.
Multiple Parameters
You must enclose multiple parameters within parentheses to indicate group relationships. If parentheses are not used,
only one parameter is assumed. The following example is an  Easytrieve  statement with multiple parameters:
 MASK (A  BWZ  '$$,$$9.99')
 
Field Names
Field names are composed of a combination of not more than 128 characters chosen from the following:
•Alphabetic characters A to Z (lower and upper case)
•Decimal digits 0 through 9
•All special characters, except delimiters
The first character of a field name must be an alphabetic character, a decimal digit, or a national character (#, @, $).
In addition, a field name must contain at least one alphabetic or special character to distinguish the field name from a
number. All working storage field names must be unique, as well as all field names within a single file. If you use the same
field name in more than one file, or in a file and in working storage, you must qualify the field name with the file name or
the word WORK. A qualified field name consists of the qualifying word followed by a colon and the field name. You can
use any number of spaces, or no spaces, to separate the colon from either the qualifying word or the field name.
Assume FLD1 occurs in both working storage and the file FILEA. FLD1 can be qualified in the following ways:
 FILEA: FLD1
 FILEA:FLD1
 FILEA : FLD1
 WORK:FLD1
 
Labels
Labels identify specific PROGRAMs, JOBs, PROCedures, REPORTs, SCREENs, and statements. Labels can be 128
characters long, can contain any character other than a delimiter, and can begin with an alphabetic character (A to Z), a
numeric character (0 through 9), or a national character (#, @, $); they cannot consist of all numeric characters.
Identifiers
Identifiers are words that name things (field name, statement labels, etc.) in  Easytrieve . Identifiers cannot contain these
delimiters:
 , comma
 ' single quote
 ( left parenthesis
 226 Easytrieve ® Report Generator 11.6
 ) right parenthesis
 : colon
 
Arithmetic Operators
Easytrieve  arithmetic expressions use the following arithmetic operators:
•multiplication (*)
•division (/)
•addition (+)
•subtraction (-)
See Activity Section - Processing and Logic  for more information.
The arithmetic operator must lie between two spaces.
Alphanumeric Literals
Alphanumeric literals are words that are meant to be taken literally. They are enclosed within single quotes, and can be up
to 254 characters long. An alphanumeric literal can contain alphabetic characters A to Z and numeric characters 0 through
9. Whenever an alphanumeric literal contains an embedded single quote, you must code two single quotes. For example,
the literal O'KELLY is coded as:
 'O''KELLY'
 
Numeric Literals
Numeric literals can contain 18 numeric digits (characters 0 through 9). You can indicate the algebraic sign of a numeric
literal by attaching a plus (+) or a minus (-) prefix to the numeral. Also, you can use a single decimal point to indicate a
maximum precision up to 18 decimal positions. The following examples are valid numeric literals:
 123
 +123
 -123.4321
 
Hexadecimal Literals
Hexadecimal literals are words that are used to code values that contain characters not available on standard data entry
keyboards. Prefix a hexadecimal literal with the letter X and a single quote (X'), and terminate it with a single quote. 
Easytrieve  compresses each pair of digits that you code within the single quotes into one character.  Easytrieve  permits
only the digits 0 through 9 and the letters A to F. The following hexadecimal literal defines two bytes of binary zeros:
 X'0000'
 
Describe Files and Fields
Describe files and fields in your Easytrieve program, define data, file attributes, field data, FILE statements, DEFINE
statement, and other statement parameters.
All of the files, their associated fields, and working storage fields in your Easytrieve  program must be described before
they are referenced.
 227 Easytrieve ® Report Generator 11.6
Defining Data
You typically define data fields in the section of your program called the library. The library defines the data in terms of
fields, records, and files. A typical file layout follows:
               NAME FIELD            ADDRESS FIELD                      
           ┌────────┴───────┐┌────────────┴─────────────┐               
  RECORD { Jones, John J.    16822 Evergreen  Chicago ...      )       
                                                               )       
           Hammond, Martha   422 Ash  Ave.    Evanston ..      )       
                                                               )       
           Gray, Frederick   16 Apple  St.    Lockport ..      )       
                                                               )       
           Freud, William G. 754 Lake  St.    Peotone  ..      )  F     
                                                               )  I     
           ______________________________________________      )  L     
                                                               )  E     
           ______________________________________________      )       
                                                               )       
           ______________________________________________      )       
           .                                                   )       
           .                                                   )       
           .                                                   )       
Defining File Attributes
The FILE statement is used to describe a file or a database.
Defining Field Data
Fields are defined in the library following the FILE statement, or later in the job activity, by using the DEFINE statement.
Two categories of data can be defined:
•File data (fields defined within a record).
•Working storage data (fields defined in working storage).
FILE Statement
The FILE statement describes the files you are using as input to your program and any files your program creates (output)
other than reports. Enter FILE statements at the beginning of the library section.
The FILE statement has the following format:
FILE file-name  [file attributes ]     
FILE
Specifies that a file name and description are to follow. File-name  and file attributes  describe the file you are using
and are typically supplied by your data processing department.
file-name
A 1- to 128-character name used to define your file to Easytrieve . All statements that operate on the file refer to
this name. File-name  is also typically used on your JCL, CLIST, or EXEC statements to reference the file. Every
FILE statement must have a file-name  immediately following the FILE keyword and it must be unique within your
program.
 228 Easytrieve ® Report Generator 11.6
file attributes
The FILE statement has many parameters that describe file attributes . File attributes  are as varied as the methods
and environments available for storing data. Most file attributes are beyond the scope of this article. In general,
they include parameters for describing file type, storage device type, and record format. They are all optional and
depend on the particular environment in which you are operating. For complete FILE statement syntax, see  FILE
Statement .
DEFINE Statement
The DEFINE statement specifies data fields within a record on a file or within working storage:
•Four parameters are always required: field-name , start-location , field-length , and data-type .
•Additional parameters include the number of decimal positions for quantitative fields, HEADING, and MASK.
This statement has the following format:
DEFINE field-name start-location field-length     +            
                                                                  
 data-type   [decimal-positions ]  [HEADING ' heading-literal ']  +    
                                                                  
(         (                                        ))             
(MASK     {[ mask-identifier ] [BWZ] [' mask-literal ']})             
(         (                                        ))             
field-name
You create your own field-names  or use already existing field names (provided to you in a record layout):
•Field-names  must be unique within a file.
•The name cannot be all numeric characters.
•The name can be 1 to 128 alphanumeric characters in length.
•The name must begin with A to Z, 0 to 9, or a national character (#, @, $).
•Special characters, such as dollar sign and hyphen, can be used, but not delimiters.
start-location
The start location is the beginning location of a field in a record, relative to the first position (position 1) of the
record. Start location can be explicitly defined based on its distance from position 1 of the record:
NAME      17   starts in position 17
ADDRESS   37   starts in position 37
PAY-NET   90   starts in position 90
Here is an example of where the NAME field would appear in the previous record:
NAME field
                                               ┌─────────────┴───────────┐
│  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │ X│ X│ X│ X│ X│ X│ X│ X│ ...
└───────────────────────────────────────────────────────────────────────┘───
 1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 ...
field-length
You specify the length of a field in bytes (characters and/or spaces). The length of the NAME field in the previous
example is eight characters.
NAME    17    8
 229 Easytrieve ® Report Generator 11.6
data-type
You describe the type of data a field contains by coding the letter abbreviation for that type after the field-length .
The data-types are:
Type Maximum Field Length
A Alphanumeric 32,767
N Numeric 18
P Packed 10
U Unsigned Packed 9
B Binary 4
The data type of the NAME field (which probably contains only alphabetic characters) is A for alphanumeric:
NAME    17    8    A
decimal-positions
This is an option that specifies the desired number of decimal positions for a field name. By specifying decimal
positions in your field description, you:
•Identify a field to Easytrieve  as being quantitative (a field that contains a quantity, as opposed to a numeric
identifier or code).
•Identify the field to be automatically totaled when specified in a CONTROL report.
•Allow for proper placement of commas and decimals with leading (high-order) zeros suppressed when the field
is printed.
These types of data can have decimal positions:
•N (Numeric)
•P (Packed)
•B (Binary)
•U (Unsigned Packed)
Specify the decimal-positions  by coding an integer (0 to 18) after the data-type . For example:
AMOUNT   40   5   N 2
is a five-byte numeric field with two decimal positions.
HEADING
You use the HEADING parameter to specify an alternative column heading for a field. (The default column
heading is the field-name .) The column heading you specify is automatically used on report output unless
overridden by a HEADING statement in the activity section.
Place the alternate column heading within single quotes. For example:
CL-NAME    5   20   A   HEADING 'CLIENT NAME'
produces the column heading:
CLIENT NAME
To stack a column heading, place each word in single quotes. You now must enclose the words in parentheses.
For example:
CL-NAME   S   20   A   HEADING ('CLIENT' 'NAME')
produces the column heading:
CLIENT
NAME
 230 Easytrieve ® Report Generator 11.6
MASK
Use the MASK parameter to create a customized edit mask. An edit mask is an optional pattern of characters
specifying how numeric data is to be printed. (Alphanumeric fields cannot be edited.) To create an edit mask, use
combinations of the following characters:
Character Meaning
9 Formats digits
Z Suppresses Leading zeros
* Replaces leading zeros with an asterisk
- Prints a minus sign prior to the first non-zero digit of a negative
number
$ Prints a currency symbol prior to the first non-zero digit
Each digit in the field must be designated by a character in the mask. For example:
Edit Mask Field Value Result
$$,$$9 01234 $1,234
$$,$$9 93142 $93,142
For clarity, you can include commas in the edit mask. Commas are printed in whatever location you indicate in the
mask, but are suppressed if the field value does not exceed the number of places to the right of the comma.
Defining Edit Masks
Some standard edit masks you might use in your programs are shown here:
Edit Mask Used For
'(999)999-9999' Telephone Number
'999-99-9999 Social Security number
'Z9/99/99' Date
'$$,$$$,$$9.99 CREDIT' Money (with floating $)
'*,***,***,999.99-' Protected Check Amount
'-,---,--9.99' Negative Number
This statement has the following format:
[MASK   {[ mask-identifier ]  [BWZ]    [' mask-literal' ]}]                
•MASK is the Easytrieve  keyword that indicates an edit mask is to follow.
•Use the mask-identifier  to name the edit mask that follows it. If you name a mask, you can reuse it on other field
definitions by specifying the name only. This means that once you have defined a mask, you don not have to define it
again to use it again. A name can be any single letter from A to Y.
•BWZ (blank when zero) specifies that a field should not be printed if the entire field contains zeros. Simply code the
letters BWZ whenever you want to suppress an all-zero field. BWZ is not carried over to other fields when using a
mask-identifier .
•The mask-literal  is the actual format of the mask. It must be enclosed in single quotes and include one edit character
for each digit in the field being described.
Examples of Edit Masks
 231 Easytrieve ® Report Generator 11.6
Given a numeric field with the contents 012345678, the following masks produce the results shown:
Mask Result
'999-99-9999' 012-34-5678
'Z99,999,999' 12,345,678
'ZZZ,ZZZ,999' 12,345,678
'$$$,$$$,999' $12,345,678
'***,***,999' *12,345,678
Masking Negative Values
Fields that can contain a negative value can be masked so that an negative indicator appears when the value is printed.
An negative indicator, such as minus sign (-), or the letters CR (for credit), or any other chosen indicator, prints only when
the field contains a negative value. To include a negative indicator, mask the field as normal with all digits are accounted
for, and then add the indicator to the right end of the mask.
Given a numeric field with the contents -012345678, the following masks produce the results shown:
Mask Result
'$$$,$$$,999 CREDIT' $12,345,678 CREDIT
'$$$,$$$,999-' $12,345,678-
'Z99,999,999-' 12,345,678-
The indicators CREDIT and minus (-) print only if the field contains a negative value.
Default Edit Masks
Quantitative fields (fields defined with positions to the right of a decimal point) have system default edit masks that
account for the automatic printing of commas and decimal points in printed totals.
Numeric fields with no decimal positions defined are printed without commas or decimal points and are not automatically
totaled on control reports.
Assuming a field named PAY has a value of 1000, the following table gives the corresponding default edit masks and
results for some possible field definitions:
Field Definition Default Mask Result
PAY 10 5 N 0 'ZZ,ZZZ-' 1,000
PAY 10 5 N 2 'ZZZ.99-' 10.00
PAY 10 5 N '99999' 01000
NOTE
The number of decimal positions can be zero (0).
Defining Working Storage
Working storage gives you a method for setting aside a temporary area of storage in the computer memory. Working
storage is a place to keep the results of calculations or other information that is created during the running of an
Easytrieve  program.
 232 Easytrieve ® Report Generator 11.6
Define working storage by specifying W as the start location. The following example defines a numeric working storage
field four characters long with two decimal positions. This field could be defined in the library section or in an activity prior
to being referenced.
WORK-DEDUCT    W   4   N 2
DEFINE Within an Activity
You usually specify file fields and working storage fields in your Easytrieve  library section, but you can also define them
within an activity.
Compare the following two examples. The first shows DEFINE statements in the library section; the second shows
DEFINE statements in an activity section. Remember, the DEFINE keyword is optional when defining fields in the library
section.
The following example shows fields defined in the library section of a program. (The keyword DEFINE is shown but is
optional.) There are no fields defined in the activity section.
               [  FILE PERSNL  FB(150 1800)
               |    DEFINE  EMP#         9    5  N
 Library       {    DEFINE  EMPNAME     17   20  A
 ...           |    DEFINE  EMP-COUNT    W    4  N
               [  *                                
                          
               [  JOB INPUT PERSNL NAME MYPROG
               |    EMP-COUNT = EMP-COUNT + 1
 Activities    {    PRINT REPORT1            
 ...           |  *                  
               |  REPORT REPORT1     
               [    LINE EMP# EMPNAME EMP-COUNT
In contrast to the previous example, this example shows fields defined in the activity section of a program. (The DEFINE
keyword is required.)
               [  FILE PERSNL  FB(150 1800)
 Library       {    SALARY-CODE            134    2 N  
 ...           [  *                          
                    
               {  JOB INPUT PERSNL NAME MYPROG      
               |    DEFINE  EMP#             9    5 N  
 Activities    {    DEFINE  EMPNAME         17   20 A
 ...           |    PRINT REPORT1              
               |  *                 
               |  REPORT REPORT1   
               [    LINE EMP# EMPNAME SALARY-CODE 
When fields are defined within an activity, each field definition must start with the DEFINE keyword and physically be
defined before the field is referenced.
Defining Static Working Storage
Static working storage fields are fields used for storing accumulated values that are printed at the end of a report or are
used to compute some other values at the end of a report or at control breaks, such as averages.
 233 Easytrieve ® Report Generator 11.6
To define static working storage fields in your program, type S in the position on the DEFINE statement where you
typically type the field starting position or a W. For example:
AVG-GROSS  S  8  N  2
Static working storage fields are necessary because of the way Easytrieve  processes reports. In the Activity Section -
Input and Output  article, we explain the PRINT statement and the process that occurs when reports are either sequenced
(by the SEQUENCE statement) or multiple within one JOB activity (more than one REPORT statement is used).
In both cases, data is sent to an intermediary file called a work file or spool file. Work files do not get formatted into reports
(through report definition statements) until they have first been sequenced or until the system printer becomes available.
Due to the use of intermediary work files, two different types of working storage fields are needed. The following
discussion provides the differences between them and helps you to understand the need for these two field types.
Static Versus Non-Static
Unlike static working storage fields (type S), non-static working storage fields (type W) are sent to work files for every
record in the input file. This is done whenever the non-static working storage field is referenced in a REPORT subactivity.
If such a field is used to accumulate values during the processing of an entire file, its value, at the time each record is
sent to the work file, appears on the record in the work file. If the file is then sequenced, the non-static working storage
fields are sequenced with the rest of the fields on the record. This means that accumulated results do not  appear, either
internally or when printed, in the order they were accumulated.
Therefore, any calculations based on the value of a non-static working storage field performed at the time of report
formatting are likely to produce results that are in error. This is true only for non-static working storage fields (type W) used
to accumulate values for sequenced reports. For example:
│  Work File Before SEQUENCE  │        │   Work File After SEQUENCE  │
│─────────────────────────────│        │─────────────────────────────│
│  SEQUENCE   │    W-TYPE     │        │  SEQUENCE   │    W-TYPE     │
│    KEY      │  ACCUMULATOR  │        │    KEY      │  ACCUMULATOR  │
│   FIELD     │     FIELD     │        │   FIELD     │     FIELD     │
│─────────────│───────────────│        │─────────────│───────────────│
│    ZZZ      │       1       │  ───>  │    AAA      │       3       │
│    BBB      │       2       │        │    BBB      │       2       │
│    AAA      │       3       │        │    CCC      │       7       │
│    PPP      │       4       │        │    PPP      │       4       │
│    QQQ      │       5       │        │    QQQ      │       5       │
│    SSS      │       6       │        │    SSS      │       6       │
│    CCC      │       7       │        │    ZZZ      │       1       │
In the previous example, the W-type field is incremented by 1 each time a record is processed. Once the work file has
been sequenced and the report is formatted, the value contained in the W-type field when last processed (output to the
report) is now different than it was prior to sequencing. If you attempted to compute averages, based on this value, your
results would be in error.
Static working storage fields are not sent to work files. This means they are not affected by sequencing. The last value
accumulated into an S-type field remains unchanged regardless of what is done to the work file and is therefore suitable
for any end-of-report calculations such as averaging. For example:
│ Report File Before SEQUENCE │        │  Work File Before SEQUENCE  │
│─────────────────────────────│        │─────────────────────────────│
│  SEQUENCE   │    S-TYPE     │        │  SEQUENCE   │S-FIELD VALUES │
│    KEY      │  ACCUMULATOR  │        │    KEY      │  NOT PASSED   │
 234 Easytrieve ® Report Generator 11.6
│   FIELD     │     FIELD     │        │   FIELD     │ TO WORK FILE  │
│─────────────│───────────────│        │─────────────│───────────────│
│    ZZZ      │       1       │  ───>  │    ZZZ      │               │
│    BBB      │       2       │        │    BBB      │               │
│    AAA      │       3       │        │    AAA      │               │
│    PPP      │       4       │        │    PPP      │               │
│    QQQ      │       5       │        │    QQQ      │               │
│    SSS      │       6       │        │    SSS      │               │
│    CCC      │       7       │        │    CCC      │               │
This example illustrates that static working storage fields are not copied to work files and therefore are not sequenced, as
are non-static (type W) fields. The static field shown in the previous example contains the value seven (7) at the time any
averaging is performed at end-of-report.
Initializing Working Storage Fields
To give working storage fields an initial value at the beginning of your program, use the VALUE option of the DEFINE
statement. The following example assigns an initial value of JANUARY to the alphanumeric working storage field CURR-
MON. When the value clause is not used, numeric working storage fields are automatically initialized to zeros and
alphanumeric working storage fields to blanks.
CURR-MON   W   10   A   VALUE 'JANUARY'                                
Reset Option
The RESET option is used only for W working storage fields. When coded on the field definition for a W field, RESET
returns the field to its initial value whenever JOB or SORT executes. You cannot use RESET for redefine fields (fields
having overlay redefinition).
Redefining a Field
Sometimes it is necessary to break a field into several parts to get the exact information you want. A birth date, for
example, might have been entered originally as one field in a record. Now, you want to access this information by the
month, day, or year.
Explicit Redefinition
You can explicitly redefine the field as follows:
      DATE-OF-BIRTH     103   6   N
         MONTH          103   2   N
         DAY            105   2   N
         YEAR           107   2   N
Explicit redefinition requires the exact starting location of each field. Here is a physical representation of the previously-
defined field:
                   DATE-OF-BIRTH    
                                  
       | | | | | | |0|2|1|0|5|5| | | | |
                                        
                    |   |   |        
       position    103 105 107    
          in                      
 235 Easytrieve ® Report Generator 11.6
       record:                   
In this example, the MONTH (02) starts in position 103 and occupies positions 103 and 104. The DAY starts in 105 and
occupies positions 105 and 106. Finally, the YEAR starts in 107 and occupies positions 107 and 108.
Overlay Redefinition
You can perform overlay redefinition of a field by including the original field-name  as the starting location for all
subsequent fields in the redefinition. This is especially useful when redefining a working storage field that does not have a
numeric starting position. For example:
DATE-OF-BIRTH                   W     6   N
   MONTH        DATE-OF-BIRTH         2   N
   DAY          DATE-OF-BIRTH  +2     2   N
   YEAR         DATE-OF-BIRTH  +4     2   N
To specify the starting position of the redefining field, use the original field name plus any offset (+2 or +4 in the previous
example).
When using overlay redefinition, verify that the redefining fields fit within the storage boundaries of the redefined field.
Implicit Start-location
You can define the start-location  of a field with an implicitly-defined position in the record. Implicitly defining a start-location
eliminates the need to identify the actual start-location  of a field. Implicit start-locations  are most useful when you are
creating output files, because output files generally have contiguous field locations.
Use an asterisk in place of the numeric start-location  when implicitly defining a field. The asterisk implies that the field
begins in the next available starting position (highest location defined so far, plus one). The following example defines
contiguous fields in a record. Because EMP# begins in position 1, NAME begins in position 6, FILLER1 in position 22, and
ADDRESS in position 32. All locations between 1 and 70 are accounted for.
EMP#       1    5  N
NAME       *   16  A
FILLER1    *   10  N
ADDRESS    *   39  A
FILE Statement Revisited
Earlier in this article, we introduced the FILE statement for describing input and output files. We also mentioned that there
are parameters for the FILE statement. In the following sections, we introduce two FILE statement parameters.
Virtual File Manager (VFM)
The VIRTUAL parameter of the FILE statement invokes the virtual file management facility (VFM) of Easytrieve .
This statement has the following format:
               |                 | [F]  
FILE file-name  [VIRTUAL  [RETAIN]]  [V] logical-record-length  
               |                 | [U]     
VFM provides an easy method for establishing temporary work files without special job control or file allocation
statements. By using VFM, you can establish your own extract or temporary files, using only Easytrieve  keywords.
The FILE keyword and a user-defined file name are required.
 236 Easytrieve ® Report Generator 11.6
VIRTUAL
Designates that the named file is to be a temporary VFM file. VFM files consist of a dynamically-allocated space
in memory (64K default). If the allocated space is exhausted, VFM automatically writes the excess data to a single
spill area on disk.
RETAIN
Specifies that the VFM file is to remain in memory until the end of the associated Easytrieve  execution. If RETAIN
is not specified, the VFM file is deleted when it has been read back into your program.
logical-record-length
You must specify a record length for all output files. When specifying record length, you must also specify record
type (F, V, or U). Block size is not required, because VFM files are automatically blocked.
EXIT Parameter
The EXIT parameter on the FILE statement invokes a user routine for every input or output operation performed on the
named file. You can use EXIT to access your own user-written routine to convert non-standard data files that Easytrieve
does not process directly.
NOTE
EXIT is not valid for VFM.
FILE file-name  [EXIT ( program-name   +       
  [       |                 ]      |        
  |USING ({ parm-field-name  }... ) |  [MODIFY] )]  +   
  |       | parm-literal     |      |            
  [       [                 ]      ]    
                                     
  [WORKAREA area-length ]            
The EXIT parameter followed by program-name  indicates the routine or subprogram to be executed.
USING
Specifies any parameters to be passed to the exit routine. It is limited to working storage fields, system-defined
fields, and card literals.
MODIFY
Specifies that Easytrieve  provides input or output services but that the exit can inspect and modify each record
after input and before output.
WORKAREA
Specifies that Easytrieve  sets up a special area of storage to be used as the data buffer for the file. Area-length  is
used to specify the length of the data buffer.
COPY Statement
The COPY statement duplicates the field definitions of a named file. You can copy the field definitions of a given file an
unlimited number of times.
This statement has the following format:
COPY  file-name  
 237 Easytrieve ® Report Generator 11.6
If you copy the same field name into more than one file and the files are used in the same activity, you must qualify the
field when referencing it in your programs; otherwise, Easytrieve  cannot uniquely identify the data reference. You can
qualify fields in  Easytrieve  by preceding them with their file name and a colon. For example, OUTFILE:NAME.
Example of COPY Statement
 FILE PERSNL  FB(150 1800)                                             
   EMPNAME         17      20 A     HEADING ('EMPLOYEE NAME')          
     NAME-LAST  EMPNAME     8 A     HEADING ('FIRST' 'NAME')           
     NAME-FIRST EMPNAME +8 12 A     HEADING ('LAST' 'NAME')            
 FILE SORTWRK FB(150 1800)   VIRTUAL                                   
 COPY PERSNL 
 SORT PERSNL TO SORTWRK USING +                                        
     (NAME-LAST NAME-FIRST) NAME MYSORT                                
 JOB INPUT SORTWRK NAME MYPROG                                         
    PRINT REPORT1                                                      
 *                                                                     
 REPORT REPORT1                                                        
 LINE NAME-FIRST NAME-LAST   
Activity Section - Processing and Logic
The activity section of an  Easytrieve  program is where all processing logic and report declarations reside. The activity
section contains JOB, SORT, and PROGRAM activities.
JOB Activities include the following options:
•JOB Statement
•Conditional Expressions
•Calculations
•Assignment Statement
•MOVE Statement
•MOVE LIKE Statement
•DO/ENDDO Statements
•CASE and END-CASE Statements
•GOTO Statement
•STOP Statement
•User Procedures (PROCs)
•START/FINISH Procedures
•Processing Tables
SORT is an activity that sequences an input file in alphabetical or numerical order based on fields specified as keys.
PROGRAM activities can be used for simple processing activities or to control the execution of JOB, SORT, and SCREEN
activities.
 238 Easytrieve ® Report Generator 11.6
JOB Activities
Easytrieve  supports a spectrum of JOB activities including JOB Statement, Conditional Expressions, Calculations, MOVE
Statements, and User procedures.
JOB Statement
The JOB statement defines and initiates processing activity. This statement also identifies the name of the automatic input
file.
This statement has the following format:
JOB [INPUT file-name ] [NAME job-name ]                                  
JOB statement parameters can be coded in any order.
INPUT
The optional INPUT parameter identifies the automatic input to the activity, whereby all input-related logic, such as
opening the file, checking for end of file, and reading, are all controlled by  Easytrieve .
When you do not specify INPUT,  Easytrieve  automatically provides an input file. If a SORT activity immediately
preceded the current JOB activity, the default input is the output file from that SORT activity. Otherwise, the
default input is the first file that is named in the library section.
file-name
The file-name identifies the automatic input files. This parameter can identify any file that is defined in the library
section of the program eligible for sequential input processing.
NAME job-name
The optional NAME parameter names the JOB activity and is normally used only for documentation purposes.
The job-name :
•Can be up to 128 characters long
•Can contain any character other than a delimiter
•Can begin with A to Z, 0 through 9, or a national character (#, @, $)
•Must not consist of all numeric characters.
The following example shows the location of the JOB statement and the subactivities in an  Easytrieve  program:
                 ** Library **                                               
                 *                                                           
 Activity       JOB INPUT PERSNL NAME EXAMPLE                               
 Logic          IF DEPARTMENT = 911 THRU 914 921                          
                     DEDUCTIONS = GROSS - NET                                
                     PRINT EXAMPLE                                           
                   END-IF                                                    
                 *  
 Report        REPORT EXAMPLE                                              
                   SEQUENCE DEPARTMENT NAME                                  
                   TITLE 1 'EXAMPLE REPORT'                                  
                   LINE 1 EMPNAME DEPARTMENT EMP# GROSS NET DEDUCTIONS
You can use the logic subactivity to examine and manipulate data, initiate printed reports, and write data to a file.
You can use the report subactivity to format the desired report.
 239 Easytrieve ® Report Generator 11.6
Conditional Expressions
Data selection and manipulation takes place in the logic section of an  Easytrieve  program. Logic is coded immediately
after the JOB statement.
IF Statement
Processing within a JOB activity can depend on the conditional (IF) statements present in the program:
•When an IF statement is present, records that are read from the input file are processed according to the conditions it
states.
•Every IF statement must end with END-IF.
                     [EQ  = ]                                           
                     |NE  -=|   #field two              #               
       IF field one  {GT  > }   #literal                #               
                     |GE  >=|   #arithmetic-expression  #               
                     |LT  < |                                           
                     {LE  <=]   
 
          [statements executed for true IF condition]   
                                                                                     
      [ELSE-IF alternate-expression ]                                   
                                                                       
          [statements executed for true ELSE-IF condition]             
                                                                       
      [ELSE]                                                           
                                                                       
          [statements executed for false IF condition]                 
                                                                       
       END-IF  
IF Statement Examples:
•Comparing the value of a field to a literal:
    IF DEPT = 910   
    IF EMPNAME = 'SMITH'    
    IF AMT GE 500   
•Comparing two fields:
    IF DIV = HOLD-DIV   
•Comparing the value of a field to a series or range of values:
    IF STATE = 'GA' 'SC' 'TN'   
    IF CLASS = 'A' THRU 'E' 
    IF AMT  NE 100 THRU 500 
    IF DEPT  = 900 940 THRU 950 960 970 THRU 980    
Arithmetic Operators
 240 Easytrieve ® Report Generator 11.6
These arithmetic operators are valid in conditional statements:
Operators Meaning
EQ = Equal to
NE Ø= Not equal to
GT > Greater than
GE >= Greater than or equal to
LT < Less than
LE <= Less than or equal to
IF/ELSE
ELSE directs  Easytrieve  to perform alternative processing when the condition that is established by the IF
statement is not met:
•For true IFs, all commands up to the ELSE (or END-IF if no ELSE is present) are executed.
•For false IFs, commands between ELSE and END-IF are executed.
•Following END-IF, processing continues regardless of the result of the IF.
IF/ELSE Example :
IF DIVISION = 'A' THRU 'L'
  DEDUCTIONS = GROSS * .15
ELSE
  DEDUCTIONS = GROSS * .18
END-IF
In this example, records with a DIVISION field containing values in the range A to L are processed according to
the statement between the IF and ELSE statements (DEDUCTIONS = GROSS * .15). For records with DIVISION
not in the range A to L, the statement following ELSE (DEDUCTIONS = GROSS * .18) is executed. END-IF
signifies the end of the condition.
In words, we could restate the condition in the above example something like this, "For divisions A to L,
deductions are equal to 15 percent of the gross; for all other divisions, deductions are equal to 18 percent of the
gross."
ELSE-IF
ELSE-IF is optional and identifies a conditional expression to be tested when the previous conditional expression
is false. ELSE-IFs permit multiple conditions to be nested without requiring an END-IF for each condition. You can
code as many ELSE-IFs as necessary.
ELSE-IF Example :
IF DIVISION = 'A' THRU 'L'
  DEDUCTIONS = GROSS * .15
ELSE-IF DIVISION = 'M' THRU 'R'
  DEDUCTIONS = GROSS * .2
ELSE
  DEDUCTIONS = GROSS * .18
END-IF
Special IF Statements
Use special IF statements to check the integrity of the data in your files.
This statement has the following format:
                         ( ALPHABETIC )                
 241 Easytrieve ® Report Generator 11.6
                         ( NULL       )               
                         ( NUMERIC    )             
IF  field-name  [NOT]     ( SPACE      )               
                         ( SPACES     )               
                         ( ZERO       )             
                         ( ZEROS      )             
                         ( ZEROES     )          
Special IF statement keywords check for the following conditions:
Keyword Condition
ALPHABETIC Value containing characters A to Z and blank spaces
NULL No current value
NUMERIC Value containing digits 0 through 9
SPACE
SPACESValue containing all blank spaces
ZERO
ZEROS
ZEROESValue containing all zeros (0)
Special IF Examples:
This statement is true ... for this condition ...
IF AMT NOT NUMERIC AMT does not contain all digits
IF NAME SPACES NAME contains all spaces
IF STATE ALPHABETIC STATE contains all letters and spaces
IF AMT-DUE ZERO AMT-DUE contains all zeros
Combining Conditional Expressions
You can compound conditional expressions by combining them through the logical connectors AND and OR. For example,
if you need to determine a value based on two conditions, you can connect the conditions with a logical connector:
IF DIVISION = 'A' THRU 'L' AND AMOUNT GE 15
This statement is true when DIVISION is equal to a letter in the range A to L and when AMOUNT is also greater than
or equal to 15. Both conditions must be true for the entire statement to be true. The following statement uses the OR
connector:
IF DIVISION = 'A' THRU 'L' OR AMOUNT GE 15
This statement is true when DIVISION is equal to a letter in the range A to L or when AMOUNT is greater than or equal to
15 or when both conditions are true. Either one or both of the conditions can be true to make the entire statement true.
When used together in the same statement, conditions that are connected by AND are examined before conditions
connected by OR. For example:
IF DIVISION = 'A' AND AMOUNT GE 15 OR STATE = 'GA'
 242 Easytrieve ® Report Generator 11.6
In this statement,  Easytrieve  examines the portion "DIVISION = 'A' AND AMOUNT GE 15" first. If both sides of the
AND in that portion are found to be true, then the entire statement is true. If not, then the portion "OR STATE = 'GA'" is
examined and, if it is found to be true, the entire statement is still true. If conditions on both sides of the OR are false, then
the entire statement is false.
The following table helps you visualize the concept of logical connectors. The assumptions for the table are:
DIVISION = A
AMOUNT = 15
STATE = GA
The following IF statement ... is ...
IF DIVISION = 'A' AND AMOUNT GE 15 OR STATE = 'GA' TRUE
IF DIVISION = 'A' AND AMOUNT = 14 OR STATE = 'FL' FALSE
IF DIVISION = 'A' OR AMOUNT = 15 AND STATE = 'FL' TRUE
IF DIVISION = 'B' AND AMOUNT = 15 AND STATE = 'FL' FALSE
IF (DIVISION = 'A' OR AMOUNT = 15) AND STATE = 'FL' FALSE
NOTE
Inserting parentheses around a set of conditions can alter the outcome of the statement. Remember these rules:
•All conditional expressions are considered one statement.
•AND statements are evaluated before OR statements.
•Parentheses may alter the normal order of evaluation.
Calculations
Easytrieve  has four arithmetic operations
•Multiplication (*)
•Division (/)
•Addition (+)
•Subtraction (-)
Multiplication and division are performed before addition and subtraction in order from left to right. There must be a space
before and after the arithmetic operators.
           [   ]           [ * ]             
           | = |           | / |             
 field name {   } value 1 {   } value 2     
           | EQ|           | + |             
           [   ]           [   ]   
Parentheses in Calculations
You can use parentheses to override the normal order of operation. Operations that are contained in parentheses are
performed first. For example:
RESULTS = GROSS - AMT * 1.3
is the same as:
 243 Easytrieve ® Report Generator 11.6
RESULT = GROSS - (AMT * 1.3)
but different from:
RESULT = (GROSS - AMT) * 1.3
You can nest parentheses to further alter the order of operation. Operation proceeds from the innermost set of
parentheses to the outermost:
RESULT = 1.3 * (GROSS - (AMT + DEDUCT))
In this example, AMT and DEDUCT are added before being subtracted from GROSS. After subtraction, the difference is
multiplied by 1.3 and the product of this is assigned to the RESULT field.
Assignment Statement
The assignment statement establishes a value in a field by copying the value from another field or literal. The value on the
right of the equal sign is copied to the field on the left of the equal sign. The assignment statement also accomplishes data
conversion, such as packing or unpacking numeric data.
                    [= ] ì send-field-name       ]
 receive-field-name   {  } í send-literal          }
                    [EQ] î arithmetic expression ]
Simple Assignment Examples:
HOLD-DIV = DIV
DEPT-NAME = 'ACCOUNTING DEPT'
RATE = 1.1
MOVE Statement
Use the MOVE statement to transfer data from one location to another. MOVE is useful for moving data without
conversion and for moving character strings with variable lengths:
•You can move a field or a literal to a field, or move a file to a file.
•A sending field longer than a receiving field is truncated on the right.
•A receiving field longer than the sending field is padded on the right with spaces or an alternative fill character.
•Spaces or zeros can be moved to one or many fields.
The MOVE statement has two formats.
MOVE Format 1
     [send-file-name  ] [           ]    [ receive-file-name  ]
MOVE {send-field-name}  |send-length|  TO {                  } +
     [send-literal    ] [           ]    [ receive-field-name ]
 
[receive-length ]     [FILL fill-character ]
 244 Easytrieve ® Report Generator 11.6
When you specify Format 1, data moves from one field to another, filling with spaces or a specified fill character on the
right. The FILL parameter enables you to place specified characters in the unused spaces of the new field (the default is
blank spaces).
NOTE
The MOVE statement does not convert data as it is moved. To convert the data from the data type in one field to
the data type in another field, use the Assignment statement.
Example 1
MOVE NAME 20 TO HOLD-NAME
This example moves the first 20 characters of the NAME field to the HOLD-NAME field.
Example 2
MOVE NAME CTR TO HOLD-NAME FILL '*'
In this example, a numeric length for the sending field (NAME) is replaced by a field name CTR. CTR contains a numeric
value that determines the number of characters that are moved to HOLD-NAME. Any remaining spaces after the move
(assuming the sending field is smaller than the receiving field) are filled with asterisks.
MOVE Format 2
Syntax
         [ NULL   ]
         | SPACE  |
MOVE     { SPACES }      TO   field-name-1 field-name-n
         | ZERO   |
         | ZEROS  |
         [ ZEROES ]
You can use Format 2 to initialize the receiving field.
Example:
MOVE SPACES TO NAME, HOLD-NAME, HOLD-DIV
This example fills all of the named fields with blank spaces.
MOVE LIKE Statement
MOVE LIKE moves the contents of fields in one file to identically named fields in another file.
Syntax
MOVE LIKE  file-name-1   TO  file-name-2  
It is important to understand that the MOVE LIKE statement creates assignments of each LIKE field. These assignments
perform data conversions, if necessary.
Example:
 245 Easytrieve ® Report Generator 11.6
FILE  INFILE1
  EMPNAME 17  20  A
  DEPT    98   3  N
  AMT     90   4  P  2
FILE OUTFIL1
  AMT      1   7  N  2
  EMPNAME  8  11  A
JOB INPUT INFILE1 NAME MOVE-LIKE-EXAMPLE
  ** Logic **
*
 MOVE LIKE INFILE1 TO OUTFIL1
  ** Logic **
In this example, the EMPNAME field of INFILE1 is moved to the EMPNAME field of OUTFIL1, where the last nine
characters are truncated. The AMT field of INFILE1 is moved to the AMT field of OUTFIL1, where it is converted to
numeric format from packed decimal format.
DO/ENDDO Statements
Use the DO and END-DO statements to provide a controlled loop for repetitive program logic.
Syntax
   [WHILE]                                                      
DO {     } conditional-expressio n                               
   [UNTIL]                                                      
                                                                
    ** Logic **                                                 
                                                                
END-DO                                                          
•[WHILE]
•{ }
•[UNTIL]
A WHILE loop evaluates the condition at the top of a group of statements. The UNTIL loop evaluates the condition at
the bottom of a group of statements.
•conditional-expression
Specifies the condition that is the basis for the continuing execution of the loop. Conditional expressions follow the
rules of IF statements.
•END-DO
Terminates the body of the loop that is associated with the DO statement. An END-DO statement must be specified
after each DO statement and its associated statements.
DO WHILE Example:
JOB INPUT PERSNL NAME DO-EX-1
CTR = 0
 DO WHILE CTR LT 10   CTR = CTR + 1   ** Logic **  END-DO 
This DO WHILE statement causes "CTR = CTR + 1" to repeat until CTR is equal to 10. At that point, control transfers to
the first statement after the END-DO statement.
DO UNTIL Example:
 246 Easytrieve ® Report Generator 11.6
JOB INPUT PERSNL NAME DO-EX-2
 CTR = 0 DO UNTIL CTR GE 10   CTR = CTR + 1   ** Logic **  END-DO 
This DO UNTIL statement causes "CTR = CTR + 1" to execute the logic once, and then repeat until CTR is equal to 10. At
that point, control transfers to the first statement after the END-DO statement.
As you can see from these examples, you can use the WHILE and UNTIL parameters of the DO statement to perform
identical tasks. The rule of thumb to follow when trying to determine which parameter to use is to use UNTIL if you want to
be sure the logic (  Easytrieve  statements) is executed at least once. The UNTIL parameter causes  Easytrieve  to perform
the logic and then evaluate the conditional expression.
Use WHILE if you do not want the logic executed. The WHILE parameter causes  Easytrieve  to evaluate the conditional
expression and perform the logic only if the condition is true.
DO Nesting Example:
You can nest DO statements. (The inner logic loop must be completely within the outer logic loop.)
      JOB INPUT PAYROLL NAME DO-EX-3
        CTR1 = 0
        DO WHILE CTR1 LT 10
          CTR2 = 0
            DO WHILE CTR2 LT 5
              CTR2 = CTR2 + 1
                                   Inner
              ** Logic **          Loop
Outer
            END-DO                              Loop
          CTR1 = CTR1 + 1
 
        ** Logic **
 
        END-DO
In this example, the inner DO WHILE loop executes five times for each single execution of the outer loop. When CTR1 is
equal to 10, control is passed to the first statement following the outer END-DO statement.
CASE and END-CASE Statements
The CASE and END-CASE statements are used to conditionally execute one of several alternative groups of statements,
based on the value of a specific field.
Syntax
CASE   field-name                                                       
                                                                       
  WHEN compare-literal-1  [THRU range-literal-1 ]                        
    (statements)                                                       
                                                                       
  WHEN compare-literal-n  [THRU range-literal-n ]                        
    (statements)                                                       
 247 Easytrieve ® Report Generator 11.6
                                                                       
  [OTHERWISE]                                                          
    (statements)                                                       
                                                                       
END-CASE 
field-name
Specifies a field that contains a value that is compared to the values represented by compare-literal  [THRU
range-literal ]. Field-name can be a field of any type except a varying length alphanumeric field. If field-name  is
alphanumeric, it must be 254 or fewer bytes in length. If field-name  is numeric, it must have zero or no decimal
places.
WHEN
You can specify as many WHEN conditions as necessary. At least one WHEN condition is required. You cannot
code statements between CASE and the first WHEN condition. You must supply a unique set of values to be
compared with field-name  in each WHEN condition.
compare-literal  [THRU range-literal ]
Compare-literal  is the value to be compared with field-name . You can specify a single literal, a series of literals, or
a range of literals. A range is represented by compare-literal  THRU range-literal . A range is satisfied when field-
name  is greater than or equal to the lesser of compare-literal  and range-literal  and is less than or equal to the
greater of compare-literal  and range-literal .
When field-name  is alphanumeric, compare-literal  and range-literal  must also be alphanumeric and must be equal
in length to field-name . When field-name  is defined as a numeric data type, compare-literal  and range-literal  must
also be numeric and must not have any decimal places. Numeric literals need not be equal in length to field-
name .
The set of literal values that are specified for a given WHEN, including the unspecified values that are implied by a
range, must be unique as compared to the literal values of any other WHEN for the same CASE.
OTHERWISE
An optional statement that specifies a group of statements to be executed if no WHEN comparison was satisfied.
If OTHERWISE is not specified and field-name  does not equal any of the specified WHEN conditions, execution
continues with the statement following END-CASE.
END-CASE
Terminates the body of the CASE statement. END-CASE must be specified after each CASE statement and its
associated statements.
Nesting CASE Statements
A CASE statement can be nested within a CASE statement. Other conditional execution statements can also be nested
within a CASE statement. A CASE statement can be nested within any other conditional execution statement.
Example:
The following example uses CASE to compare the value in JOB-CATEGORY to the range specified in the WHEN clauses,
and calculate Christmas bonuses, based on that value:
FILE PERSNL FB (150 1800)                                              
  EMPNAME        17  8  A                                              
  EMP#            9  5  N                                              
  DEPT           98  3  N                                              
  GROSS          94  4  P  2                                           
XMAS-BONUS        W  4  P  2                                           
JOB-CATEGORY    132  2  N  0                                           
JOB INPUT PERSNL NAME COMPUTE-XMAS-BONUS                               
 248 Easytrieve ® Report Generator 11.6
  CASE JOB-CATEGORY                                                    
    WHEN 1 THRU 29                                                     
      XMAS-BONUS = GROSS * 1.03                                    
    WHEN 30 THRU 59                                                    
      XMAS-BONUS = GROSS * 1.05                                    
    OTHERWISE                                                          
      XMAS-BONUS = GROSS * 1.07                                    
END-CASE                                                               
PRINT RPT                                                              
REPORT RPT                                                             
LINE EMPNAME XMAS-BONUS                                              
GOTO Statement
You use the GOTO statement to branch out of the normal top-to-bottom logic flow in a program.
Syntax
[GOTO  ]  [ label ]
{      }  {JOB   }
[GO TO ]  [SCREEN]
This statement directs program control to another area in the program.  Easytrieve  accepts either GOTO or GO TO.
GOTO label
Label  refers to a statement label. GOTO label  transfers control immediately to the first statement following the
named statement label. The statement label can be anywhere in the same activity or procedure. A statement label
can:
•Can be up to 128 characters long
•Can contain any character other than a delimiter
•Can begin with A to Z, 0 through 9, or a national character (#, @, $)
•Must not consist of all numeric characters
GOTO JOB
Transfers control to the top of the current JOB activity. This is useful to stop specific records from further
processing.
GOTO SCREEN
Transfers control to the top of the current SCREEN activity.
Example:
          JOB INPUT PERSNL NAME DIV-LIST  <──────┐ Transfers
            IF DIV = 'A'                         │ Control
              GOTO JOB ──────────────────────────┘
            END-IF
            IF DIV = 'B'
              GOTO CHECK-REG-ROUTINE    ─────────┐
            END-IF                               │
                                                 │ Transfers
               ** Logic **                       │ Control
 249 Easytrieve ® Report Generator 11.6
                                                 │
            CHECK-REG-ROUTINE    <───────────────┘
 
               ** More Logic **
STOP Statement
A STOP statement enables you to terminate an activity.
Syntax
STOP   [EXECUTE]                                                       
•STOP ends the current JOB or SORT activity, completes the report processing for the activity, if any, and then goes on
to the next JOB or SORT activity, if one exists. A FINISH procedure (if one is present) is still executed before going on
to the next JOB or SORT activity.
•STOP EXECUTE immediately terminates all  Easytrieve  execution.
Example:
IF AMT NOT NUMERIC
  STOP
END-IF
User Procedures (PROCs)
A user procedure (also called PROC for short) is a group of user-written  Easytrieve  statements that are designed to
accomplish some task. PROCs are useful when developing structured programs that modularize discrete and repetitive
tasks.
PROCs are invoked by using the PERFORM statement, which has the following format:
PERFORM  proc-name  
proc-name
Specifies the name of a user-defined procedure that is located at the end of the activity in which it is performed.
•Can be up to 128 characters long
•Can contain any character other than a delimiter
•Can begin with A to Z, 0 through 9, or a national character (#, @, $)
•Must not consist of all numeric characters
As mentioned at the beginning of this section, procedures are discrete modules of program code that perform a task.
When coded, procedures must have this format:
proc-name . PROC                                          
                                                            
** Procedure Logic **                                       
                                                            
   END-PROC  
 250 Easytrieve ® Report Generator 11.6
PROC
The PROC keyword must follow the proc-name , separated by a period and a space. Proc-name  is the same
name as on the PERFORM statement.
END-PROC
Every PROC must have an END-PROC, which marks the end of the procedure. At END-PROC, control is
returned to the statement following the PERFORM statement that invoked the PROC.
Procedure Example:
The following example performs two simple procedures, based on the value of a field named CODE:
IF CODE = 1
  PERFORM CODE1-RTN
ELSE
  PERFORM CODE2-RTN
END-IF
 
** Logic **
 
 CODE1-RTN. PROC
  ORDER = 'NO'
END-PROC
CODE2-RTN. PROC
  ORDER = 'YES'
END-PROC
Nesting PROCs
A PERFORM statement within a procedure can invoke another procedure. For example:
IF DEPT = 911
  PERFORM PROCA
END-IF
 
        ** Logic **
  PROCA. PROC
    IF ST = 'NY'
  PERFORM PROCB
    ELSE
      TAX = GROSS * .05
    END-IF
  END-PROC
  PROCB. PROC
    TAX = GROSS * .1
  END-PROC
 251 Easytrieve ® Report Generator 11.6
START/FINISH Procedures
You use the optional START and FINISH parameters of the JOB statement to automatically incorporate procedures into
processing activities.
Syntax
The format for invoking these procedures is as follows:
JOB INPUT file-name  [NAME job-name ]      +                     
                                                               
    [START start-proc-name ] [FINISH finish-proc-name ]  
START start-proc-name
START procedures are used to execute routines prior to execution of the logic in the body of the JOB activity:
•The procedure is invoked automatically after the file is opened but before reading the first input record.
•A typical START procedure might initialize working storage fields or establish a position in a keyed sequenced
file.
FINISH finish-proc-name
FINISH procedures are used to identify a procedure to be executed during the normal termination of the JOB
activity:
•The procedure is invoked after the last input record is processed but before any files are closed.
•A typical FINISH procedure displays control information that is accumulated during execution of the JOB
activity.
•Easytrieve  still executes FINISH  procedures if a STOP statement is encountered during the course of the
program, but not if a STOP EXECUTE is encountered.
Processing Tables
A table is a collection of uniform data records in a form suitable for quick reference.
Much like books in a library, a table has two components; an identifier that helps you find the information that you are
looking for (analogous to a card catalog number) and the information you are looking for (a book). With tables however,
the identifier is called a search argument ; the information you are after is called the description. Each entry in a table must
consist of:
•A search argument that uniquely identifies the entry -- this is defined as a field with the name ARG after the FILE
statement.
•A description (the data) associated with the search argument -- this is defined as a field with the name DESC after the
FILE statement.
Your objective is to obtain the description from a table, based on the search argument. Rules governing the processing of
search arguments are as follows:
•A table file must be arranged in ascending order by search argument.
•No duplicate search arguments can be placed in the file.
•You can use any number of tables in a job.
•A minimum of three entries is required in a table.
The following example shows a table with search arguments and descriptions. The argument is a numeric code that is
used to look up a descriptive state name:
  ARG DESC 
            01            ALABAMA
 252 Easytrieve ® Report Generator 11.6
            02            ALASKA
            03            ARIZONA
            ...
            47            WASHINGTON
            48            WEST VIRGINIA
            49            WISCONSIN
            50            WYOMING
Creation of Table Files
The creation of tables involves the inclusion of certain parameters on the  Easytrieve  FILE statement:
This statement has the following syntax:
                      [INSTREAM         ]                          
FILE file-name  TABLE  |                 |                            
                      [ max-table-entries ]                            
TABLE
The TABLE parameter of the FILE statement declares that the file is the object of an  Easytrieve  SEARCH
statement, which is used to access tables. Tables can be either external (stored in a file outside your program) or
instream (data is included within your program). External table files must be sequentially accessible.
INSTREAM
Denotes that the table file data is within your program. Such data immediately follows the file description after the
ARG and DESC field definitions.
max-table-entries
Specifies the maximum number of entries (records) in an external table. Specify a value here only if the number of
entries is greater than the maximum stored in the Site Options Table.
Instream Table Example:
The word ENDTABLE must be the last entry in an instream table and must be coded in columns 1 through 8:
FILE   STATTBL   TABLE  INSTREAM
  ARG    1   2  N
  DESC   4  15  A
01 ALABAMA
02 ALASKA
03 ARIZONA
 ...
47 WASHINGTON
48 WEST VIRGINIA
49 WISCONSIN
50 WYOMING
ENDTABLE
This example defines a table of state names that can now be looked up according to a two-digit code.
Accessing Table Files
SEARCH Statement
The SEARCH statement is used to perform a search of a table. SEARCH can be:
 253 Easytrieve ® Report Generator 11.6
•Coded any place within a JOB, PROGRAM, or SCREEN activity
•Issued any number of times against any number of tables.
Syntax
The SEARCH statement has this format:
SEARCH file-name     WITH search-field   GIVING result-field  
file-name
The name of the table that appears on the FILE statement.
search-field
The name of a field that contains a value that is compared to the search argument. It must be the same length
and type as the search argument (ARG).
result-field
The name of a field into which the description is placed if a match exists between search-field  and the search
argument. It must be the same length and type as the description (DESC).
After using the SEARCH statement, you can test to determine whether a match was found between the search-field  and
the search argument by using a special IF statement.
The IF statement has this format:
IF [NOT] file-name  
External Table Example:
     FILE PERSNL
       EMPNAME           17  8 A
       STATE             69  2 A
       ZIP               71  5 N
       GROSS-PAY         94  4 P 2
       POST-OFFICE-DESC   W 20 A
     FILE ZIPTABLE TABLE 5000
       ARG      1  5   N
       DESC     7  20  A
     JOB INPUT PERSNL NAME TABLE-SEARCH
       IF STATE = 'DC' 'IL'
  SEARCH ZIPTABLE WITH ZIP GIVING POST-OFFICE-DESC
         IF NOT ZIPTABLE
            POST-OFFICE-DESC = 'BAD ZIP CODE FOUND'
         END-IF
         PRINT STATE-REPORT
       END-IF
     REPORT STATE-REPORT
       SEQUENCE STATE
       CONTROL STATE
       TITLE 1 'REPORT OF EMPLOYEE SALARIES BY STATE'
       LINE 1 STATE EMPNAME GROSS-PAY ZIP POST-OFFICE-DESC
 254 Easytrieve ® Report Generator 11.6
SORT Activities
Use SORT in Easytrieve to sequence an input file in alphabetical or numerical order based on fields specified as keys.
SORT is a separate activity (outside the activity of the JOB statement). You can sort as many fields as your system allows.
The SORT activity uses the sort utility provided by your system.
SORT Statement
Use the SORT statement to specify your sorting requirements.
Syntax
       SORT input-file-name   TO  sorted-file-name    +                  
                                                                       
          USING ( sort-key-field-name  [D] ...)       +                  
                                                                       
          NAME sort-name  
input-file-name
The input file to be sorted.
sorted-file-name
The output file.
USING sort-key-field-name
Identifies those fields from input-file-name that you use as sort keys. Keys are specified in major-to-minor order.
This dictates how information is sorted. For example, you could sort a file of employee records by region, and
then by location under region, and then by department under location. Region would be the major sort key,
location would be minor, and department would be more minor.
D
Optionally sorts the field contents in descending order (ascending order is the default).
NAME sort-name
Like NAME on the JOB statement, this parameter identifies the sort activity and is normally used for
documentation purposes only. Sort-name :
•Can be up to 128 characters long
•Can contain any character other than a delimiter
•Can begin with A to Z, 0 to 9, or a national character (#, @, $)
•Must not consist of all numeric characters
Sort Example
       FILE PERSNL FB(150 1800)
         EMPNAME     1  10  A
         DEPT       11   5  N
         GROSS-PAY  16   4  P 2
       FILE PAYSORT FB(150 1800)
  SORT PERSNL TO PAYSORT +
  USING (DEPT GROSS-PAY) +
  NAME SORT-EXAMPLE-1  
This SORT example sorts the file PERSNL in ascending order, first by DEPT and then by GROSS-PAY under DEPT. This
produces a file containing records in order by department and records with LIKE departments in order by gross pay.
 255 Easytrieve ® Report Generator 11.6
SORT Procedures
Easytrieve  normally sorts all input records and outputs them into the TO file of the SORT statement automatically. The
output file usually has the same format and length as the input file. However, sometimes it is desirable to sort only certain
records or to modify the contents. To do this, you must write a SORT procedure, which must immediately follow the SORT
statement.
A SORT procedure is executed through the BEFORE parameter of the SORT statement.
Syntax
SORT  input-file-name    TO   sorted-file-name   +                
                                                                
   USING  ( sort-key-field-name   [D] ... )      +                
                                                                
   NAME  sort-name                     +                         
                                                                
   [BEFORE proc-name ]        
•A SORT procedure must immediately follow the SORT statement.
•You invoke a SORT procedure with the BEFORE parameter.
•The SORT procedure executes for each record from input-file-name  before passing the record to the sort.
•BEFORE proc-name
Identifies the user-defined procedure you want to execute.  Easytrieve  supplies input records to your SORT procedure
one at a time. If a BEFORE procedure is used, the SELECT statement must be executed for each record that you want
to sort.
–You must execute a SELECT statement for each record that you want returned to the output file.
–A selected record outputs only once, even if selected more than once in the procedure.
–Any record not selected does not go to the sorted file.
The SELECT statement has the following syntax:
SELECT
Sort Procedure Example
This example illustrates the use of the SORT activity and SORT procedures:
FILE PERSNL FB(150 1800)
  EMPNAME 17 16 A
  DEPT 98 3 N
  GROSS-PAY 94 4 P 2
FILE PAYSORT F(120) VIRTUAL
  SORT-NAME 17 16 A
  SORT-DEPT 98 3 N
  SORT-GROSS-PAY 94 4 P 2
JOB INPUT PERSNL NAME ACT-1
SORT PERSNL TO PAYSORT USING (DEPT GROSS-PAY D) +
  BEFORE SELECT-REC NAME SORT-ACTIVITY
  SELECT-REC. PROC
    IF GROSS-PAY GE 500
     SELECT
END-IF
END-PROC
 256 Easytrieve ® Report Generator 11.6
JOB INPUT PAYSORT NAME ACT-2
  PRINT RPT1
REPORT RPT1
  LINE 1 SORT-NAME SORT-DEPT SORT-GROSS-PAY
In this example, SELECT-REC is the name of the SORT procedure. The procedure causes only those records with a
gross pay of greater than or equal to 500 to be selected for sorting.
PROGRAM Activities
You can use a PROGRAM activity for simple processing activities or to control the execution of JOB, SORT, and SCREEN
activities.
Simple PROGRAM Example
The following example illustrates the use of a PROGRAM activity where you merely need to perform an arithmetic
computation, display the results, and then stop processing:
DEFINE RESULT W 4 P 2
 PROGRAM NAME COMPUTE
  RESULT = (2354.54 * 6) / 3.8
  DISPLAY 'THE RESULT IS ' RESULT
Controlling Other Activities
You can use a PROGRAM activity to conditionally initiate JOB, SORT, and SCREEN activities:
    PROGRAM NAME PROCESSOR  
      IF SYSTIME = 09:00:00 THRU 17:00:00   
        EXECUTE PRIME-TIME-JOB  
      ELSE  
        EXECUTE OFF-TIME-JOB    
      END-IF    
    JOB NAME PRIME-TIME-JOB 
      ** Logic **   
    JOB NAME OFF-TIME-JOB   
      ** Logic **   
In this example, the PROGRAM activity controls which JOB activity is executed, based on the time of day. If a PROGRAM
activity had not been specified, the JOB activities would have been executed sequentially from the first JOB activity.
EXECUTE Statement
The EXECUTE statement invokes a JOB, SORT, or SCREEN activity from either a PROGRAM or SCREEN activity. The
EXECUTE statement transfers control to an activity. After the activity is executed, control returns to the next executable
statement following the EXECUTE.
NOTE
You cannot invoke a JOB, SORT, or SCREEN activity within a JOB or SORT activity.
EXECUTE statements within a SCREEN activity can invoke other activities. This is called activity nesting.
Syntax
 257 Easytrieve ® Report Generator 11.6
EXECUTE { job-name  | sort-name  | screen-name }
{job-name  | sort-name  | screen-name }
Names the JOB, SORT, or SCREEN activity to be executed.
Activity Section - Input and Output
Review how file input/output is controlled by Easytrieve  (automatic) or controlled by the user. Several statements are
available to provide input and output under various conditions. All input and output occurs in the activity section of your
programs.
This article includes the following information:
Automatic Input and Output
Easytrieve  gives you the option of letting it take care of input and output for you. All of the usual housekeeping
considerations like opening and closing files, checking for end of file, issuing input and output statements in a loop, can be
taken care of automatically.
Automatic Input with the JOB Statement
The JOB statement lets you identify a file for automatic input to the JOB activity. Simply specify the file name after the
word INPUT; Easytrieve  takes care of all the rest.
Syntax
Here is how the JOB statement looks with automatic input:
JOB [INPUT  file-name ]                                                 
When you specify INPUT and a file name, the records of that file are automatically made available to the logic in your JOB
activity section. However, there are some implied statements being executed, which you do not see in your program. The
following steps are taken when the JOB statement is executed with automatic input:
    IF THERE IS A START PROCEDURE
      THEN PERFORM THE START PROCEDURE
    END-IF
    OPEN FILE(S)
+-> RETRIEVE THE INPUT
|   IF NO MORE INPUT
|    IF THERE IS A FINISH PROCEDURE
|      THEN PERFORM THE FINISH PROCEDURE
|    END-IF
|    WRAP UP THE REPORTS
|    GO TO THE NEXT ACTIVITY
|   ELSE
|    PERFORM LOGIC ACTIVITIES
|   END-IF
+-< GO TO
You can omit the INPUT parameter from the JOB statement. If you do, the automatic input is provided by either the first
file that is described in your library section or the output of a directly previous SORT, if any.
 258 Easytrieve ® Report Generator 11.6
Printing Reports
To initiate the printing of reports, use the Easytrieve  PRINT statement, which looks like this:
Syntax
PRINT [report-name ]
PRINT is not completely automatic, in that it does permit you a certain amount of control. You can execute PRINT
anywhere in your JOB activity logic and you can use conditional logic to determine when it should execute. However,
when PRINT is executed, it activates the designated report declaration and takes care of all output considerations
automatically.
Usually, your reports do not go directly to a printer through a print file. Reports go to an Easytrieve  work file (sometimes
called a spool file) instead. Work files are necessary in two cases:
•When the printer (print file) is already activated by a previous report of the same JOB activity (multiple reports directed
to the same printer).
•When a report requires sequencing (specifically, when a SEQUENCE statement is present).
The following example illustrates how the PRINT statement is executed for reports going to a single printer:
Figure 3: Executing a Print Statement
 259 Easytrieve ® Report Generator 11.6
Work File Processing
If work files are created, as shown in the previous example, they are held until the end of the job activity. At end of job,
they are processed as shown in this example:
Figure 4: Work File Processing
User-Controlled Input and Output
Sequential File Processing
Three statements are provided for sequentially processing files:
DISPLAY
Normally used to display data to your system output device
GET
Used for sequential retrieval of input file records
PUT
Used for sequential output of records to an output file
 260 Easytrieve ® Report Generator 11.6
DISPLAY Statement
A DISPLAY statement sends data to a specified output file or output device. DISPLAY is commonly used:
•For error messages
•For highlighting reports
•For hexadecimal display of selected information
If DISPLAY is used in the logic portion of the JOB activity and output is to a report, the lines to be displayed are
interspersed throughout the report in an unsequenced report or printed at the beginning of a sequenced report (before the
first title). When DISPLAY is used in report procedures, you are permitted to display to the system output device only (not
to a data file). The DISPLAY statement has two different formats.
DISPLAY Format 1
Syntax
                            [                 ] [ [ ]                ] 
DISPLAY [ display-file-name ] [{TITLE | NOTITLE}] [ [+] offset          ]+
                            [SKIP skip-integer ] [ [-]                ] 
                            [                 ] [ [ ]                ] 
                                                [ COL column-number   ] 
                                                [ POS  position-number ] 
                                                [                    ] 
  [            ]     [            ]                                    
  [literal-1    ]     [ literal-n    ]                                    
  [field-name-1]  ... [field-name-n ]                                    
  [            ]     [            ]                                    
display-file-name
If you specify display-file-name , data is printed to the named file. If you do not specify display-file-name , the
default is SYSPRINT.
TITLE | NOTITLE
The TITLE option specifies that a skip to a new page occurs before the data is printed. Any titles and headings
are also produced. NOTITLE specifies that a skip to a new page occurs but titles and headings are not produced.
SKIP skip-integer
The SKIP option specifies that the designated number of lines are skipped before the data is printed.
offset
Coding a positive or negative offset modifies the horizontal spacing between display items.
COL column-number
The COL column-number  option specifies the print column number where the next display item is placed.
POS position-number
When used in report procedures, the POS position-number  option causes the next display item to be positioned
under the corresponding position on the LINE 01 statement.
literal-1,n  or field-name-1,n
Code literals  or field-names  in the order you want them to appear on the printed line.
DISPLAY Example 1
DISPLAY SKIP 2 '**RECORD NOT FOUND FOR KEY' +2 SSN
DISPLAY ERRFILE 'THIS REPORT IS FOR ERRORS +
        THAT WERE FOUND IN THE EDIT PHASE.'
 261 Easytrieve ® Report Generator 11.6
DISPLAY Format 2
Syntax
                            [                 ]     [          ]       
DISPLAY [ display-file-name ] [{TITLE | NOTITLE}] HEX [ file-name  ]       
                            [SKIP skip-integer ]     [field-name ]       
                            [                 ]     [          ]       
In this format, a hexadecimal and character dump of the current record or the specified field-name  is produced. The
parameters, other than HEX, operate the same as in Format 1.
DISPLAY Example 2
DISPLAY HEX NAME
Produces:
CHAR WIMN
 ZONE ECDD4444444444444444
 NUMR 69450000000000000000
      1...5...10...15...20
GET Statement
The GET statement retrieves the next record of the named file into the file input area.
Syntax
GET   file-name  
file-name
Identifies the input file that is defined in the library section.
NOTE
When you use the GET command, you must test for end-of-file (EOF).
GET Example
       FILE MASTER FB(150 1800)
         EMP#     9    5   N
         EMPNAME 17   16   A
         GROSS   94    4   P 2
       JOB INPUT NULL NAME READ-SEQ-MAN
        GET MASTER
         IF EOF MASTER
            STOP
         END-IF
         IF GROSS > 500
            PRINT RPT1
         END-IF
       REPORT RPT1
         LINE 1 EMP# EMPNAME GROSS
 262 Easytrieve ® Report Generator 11.6
You cannot use GET for an automatic input file. To inhibit automatic input, specify INPUT NULL on the JOB statement. For
example:
JOB  INPUT NULL
You might GET a secondary file while automatically accessing a primary file.
PUT Statement
The PUT statement outputs to a file sequentially.
Syntax
PUT  output-file-name  [FROM input-file-name ]
output-file-name
Identifies a file that is defined in the library section to which you are writing data.
FROM input-file-name
Using the FROM option is like performing a MOVE of data from input-file-name  to output-file-name  before
performing the PUT.
PUT Example 1
        FILE PERSNL FB(150 1800)
          EMP#          9   5 N
          EMPNAME      17  16 A
          GROSS        94   4 P 2
        FILE NEWPAY2 F(20)
          EMPNAME       1  16 A
          GROSS        17   4 P 2
        JOB INPUT PERSNL NAME PUT-EXAMPLE
          ** Logic **
        MOVE LIKE PERSNL TO NEWPAY2
         PUT NEWPAY2  
PUT Example 2
       FILE MASTER FB(150 1800)
         EMP#     9   5   N
         EMPNAME 17  16   A
         GROSS   94   4   P 2
       FILE OUTMAST FB(150 1800)
       JOB INPUT MASTER NAME CREATE-SEQ
         IF GROSS > 500
       *
            PUT OUTMAST FROM MASTER
       *
         END-IF
 263 Easytrieve ® Report Generator 11.6
POINT Statement
Use the POINT statement to establish a starting position for sequential processing of a keyed file. This statement is for
use on INDEXED and RELATIVE files.  Easytrieve  does not require that you specify the length or location of the record
key field.
Data becomes available to your program only after the next successful sequential retrieval either by automatic file input or
by a GET statement.
Syntax
                { =  } {              }                              
POINT file-name  { EQ } { field-name    }  [STATUS]                    
                { GE } {              }                              
                { GQ } { literal      }                              
                { >= } {              }                              
file-name
An INDEXED or RELATIVE file that is described on a FILE statement in the library section of your program.
field-name  or literal
Any valid field-name  or literal  can be used as a key search value for the POINT statement. This search value is
compared to the record key value in the file to determine the starting location for sequential access.
STATUS
Causes the system-defined field FILE-STATUS to be set with a return code. By checking FILE-STATUS at some
point in your program after coding STATUS, you can determine whether the input/output request was performed
properly. The FILE-STATUS field normally contains a value of zero after a successful I/O request. This parameter
is also used on the GET, PUT, READ, and WRITE statements.
POINT Example
The following example causes sequential processing of an INDEXED file to begin on a record with a key value of 01963
or, if no such key exists, on a record with the next higher key value:
FILE PERSNL INDEXED                                                    
  EMP#     9  5  N                                                     
  EMPNAME 17  8  A                                                     
  DEPT    98  3  N                                                     
  GROSS 94  4  P  2                                                    
JOB INPUT NULL NAME MYPROG                                             
   POINT PERSNL GE '01963' STATUS 
  IF FILE-STATUS NE 0 OR EOF PERSNL                                    
    DISPLAY 'BAD POINT...FILE STATUS= ' FILE-STATUS                    
    STOP                                                               
  END-IF                                                               
  GET PERSNL STATUS                                                    
  IF FILE-STATUS NE 0                                                  
    DISPLAY 'BAD GET...FILE STATUS= ' FILE-STATUS                      
  ELSE                                                                 
    DISPLAY PERSNL                                                     
  END-IF                                                               
  STOP                                                                 
 264 Easytrieve ® Report Generator 11.6
Random Access Processing
READ Statement
The READ statement provides random access to INDEXED and RELATIVE files.
Syntax
                   { key-field-name }                            
READ file-name  KEY {              }  [STATUS]                  
                   {' key-literal ' }     
file-name
The file name on a FILE statement in the library section of your program.
{key-field-name }                            
{              }  [STATUS]                  
{'key-literal ' }                            
Key-field-name  contains the value of the record key to be found. This key value can also be expressed as a literal for
INDEXED files.
READ Example
The following example involves the use of two files: PAYROLL and MASTER. PAYROLL is a sequential transaction file
containing key values. MASTER is a master file that is keyed for random access.
The PAYROLL file is made available to the program through automatic input. Key values from this file, which is located
in the EMP-NO field, are used to READ the MASTER file. READs returning non-zero FILE-STATUS values cause the
DISPLAY of an error message.
       FILE PAYROLL
         EMP-NO    1   3   N
       FILE MASTER INDEXED
         EMP-NAME   40   10   A
       *
       JOB INPUT PAYROLL NAME READ-EXAMPLE
           READ MASTER KEY EMP-NO STATUS
         IF MASTER:FILE-STATUS NOT ZERO
           DISPLAY 'ERROR READING VSAM  +
                   FILE WITH KEY: '  EMP-NO      +
                    '   FILE-STATUS IS ' MASTER:FILE-STATUS
           GOTO JOB
         END-IF
           ** Logic **
WRITE Statement
Use the WRITE statement to add a new record, update an existing record, or delete a record from an INDEXED or
RELATIVE file.
 265 Easytrieve ® Report Generator 11.6
•When you use WRITE, you must specify the UPDATE parameter on the FILE statement of the file being written to.
•Before you can issue a WRITE to delete or update, you must already have read the record that you are writing.
WRITE Format 1
Use Format 1 when adding to or updating a record.
Syntax
                        [      ]   [                         ]         
WRITE output-file-name   [UPDATE]   [FROM   input-file-name    ] [STATUS]
                        [ADD   ]   [                         ]         
                        [      ]                                       
WRITE Example 1
This example involves two files: TRANS and PAYVS. TRANS is a sequential transaction file containing transaction
records, with a key value located in the EMP-NO field. PAYVS is a master file that is keyed for random access.
The TRANS file is made available to the program through automatic input. The EMP-NO field of the TRANS file is used as
a key to READ the PAYVS file.
The value returned to the FILE-STATUS field after a READ is checked to find out if a record with a matching key value
was found. If no record was found, then an ADD is performed.
If a record was found, then an UPDATE is performed. In either case, procedures (not shown) are performed to check the
FILE-STATUS value for each WRITE statement executed.
       FILE TRANS
         EMP-NO  1  3   N
         GROSS  15  4   P  2
       *
       FILE PAYVS  INDEXED UPDATE
         GROSS  15   4  P  2
       *
       JOB INPUT TRANS NAME UPDATE-PGM
         READ PAYVS KEY EMP-NO STATUS
         IF PAYVS:FILE-STATUS NE 0  . * RECORD NOT FOUND
             WRITE PAYVS ADD FROM TRANS STATUS
           PERFORM ADD-STATUS-CHK
           GOTO JOB
         END-IF
         IF PAYVS:FILE-STATUS = 0  . * RECORD FOUND
           MOVE LIKE TRANS TO PAYVS
             WRITE PAYVS UPDATE STATUS
           PERFORM UPDATE-STATUS-CHK
           GOTO JOB
         END-IF
WRITE Format 2
Use Format 2 for deleting a record.
 266 Easytrieve ® Report Generator 11.6
Syntax
WRITE  output-file-name   DELETE   [STATUS]
WRITE Example 1
       FILE TRANS
         TRANS-KEY   14  3   A
         TRANS-CODE  17  1   A. * TRANS-CODE value of D means Delete
       *
       FILE PAYVS INDEXED UPDATE
       JOB INPUT TRANS NAME VSAM-DELETE
         IF TRANS-CODE = 'D'
           READ PAYVS KEY TRANS-KEY STATUS
             IF FILE-STATUS = 0
                WRITE PAYVS DELETE STATUS
               PERFORM WRITE-STAT-CHECK
             ELSE
               DISPLAY 'ERROR IN STATUS CHECK'
             END-IF
         END-IF
Activity Section - Reporting
Use the reporting facility in  Easytrieve  with the following statements: REPORT, SEQUENCE, CONTROL, SUM, TITLE,
HEADING, and LINE.
Special-named procedures are also available for customizing reports, allowing for greater flexibility and user control.
Standard Reports
The  Easytrieve  report facility includes all of the functions necessary to produce most reports very easily. Using 
Easytrieve  report options, you can produce almost any report format. Most reports, however, are variations of what is
termed the standard report. Standard reports typically consist of the following items:
•Titles
•Headings
•Lines or line groups
The following diagram shows the structure of a standard report:
 
<──────────────────────LINESIZE──────────────────────>       
                                                             
┌────────────────────────────────────────────────────┐       
│                   TOP MARGIN                       │       
│────────────────────────────────────────────────────│    ───
│                   TITLE AREA     (optional)        │      
│             where titles are printed               │     │ 
│────────────────────────────────────────────────────│     P 
│                   HEADING AREA   (optional)        │     A 
│             where headings are printed             │     G 
 267 Easytrieve ® Report Generator 11.6
│────────────────────────────────────────────────────│     E 
│                                                    │     S 
│                                                    │     I 
│                    REPORT BODY                     │     Z 
│                                                    │     E 
│       where lines or line groups are printed       │     │ 
│────────────────────────────────────────────────────│     │ 
│                      BOTTOM MARGIN                 │     ¯ 
└────────────────────────────────────────────────────┘    ───
Titles
The title is the first item printed on each report page. The report title is specified in your program by the TITLE statement.
You can have up to 99 TITLE statements in your program. The following diagram shows the title area of a report.
 
<─────────────────────────LINESIZE────────────────────────>  
                                                             
SYSDATE                                      PAGEWRD  Page   
   │                                            │     count  
   │                                            │       │    
   ¯                                            ¯       ¯    
99/99/99             TITLE 01  items           PAGE  ZZ,ZZ9  
                     TITLE 02  items                         
                     ...                                     
                     TITLE 04  items                         
                     ...                                     
                     TITLE 99  items        
If more than one TITLE statement is coded in your program, TITLE must be followed by sequence numbers
(01 through 99). The following list highlights some points to remember about standard report titles:
•TITLE 01 items are printed at top-of-form.
•The current date and page count are automatically placed at either end of the TITLE 01 line.
•Title lines are centered within the space indicated by the LINESIZE parameter of the REPORT statement.
•The title sequence number controls the vertical spacing of titles relative to the first title.
•The SPACE parameter of the REPORT statement controls the number of blank characters (spaces) between title
items.
The following shows two TITLE statements and the resulting titles:
Statements:
                                                                       
FILE PERSNL FB(150 1800)                                               
  DEPT  W  3  N  VALUE '903'                                           
JOB INPUT PERSNL NAME MYPROG                                           
  PRINT REPORT1                                                        
*                                                                      
REPORT REPORT1 LINESIZE 50                                             
  TITLE 01 'TEMPORARY EMPLOYEES'   TITLE 03 'IN DEPARTMENT' DEPT   LINE 01 ' ' 
 
 268 Easytrieve ® Report Generator 11.6
Produce:
 
 01/09/89 TEMPORARY EMPLOYEES PAGE 1 
 
  IN DEPARTMENT 903  
NOTE
A blank line was inserted where a TITLE 02 item would have otherwise been printed.
Headings
Headings in a report describe the content of line items. Line items are the single pieces of information that make up a line
on a report. Usually, they form vertical columns. Each heading is centered over its associated line item. The following list
highlights points to remember about headings:
•If no headings are defined,  Easytrieve  uses the field names of the DEFINE statement as headings.
•Headings can be specified by HEADING statements in the report subactivity or by HEADING parameters on DEFINE
statements.
•HEADING statements override any HEADING parameters defined for the same field.
•Line items that are literals (do not come from defined fields) do not have headings.
•Headings can be stacked (take up more than one vertical space).
The following diagram shows the positioning of headings in a typical report:
                      T I T L E  A R E A                     
                                              HEADING    
                                              HEADING     Heading
       HEADING                                HEADING     Area
       HEADING       HEADING                  HEADING    
                                                            
        line          line       literal       line         
        item          item         line        item       Report
        ...           ...          item        ...        Body
        ...           ...          ...         ...          
The following example shows how headings can be defined in your program:
Statements:
FILE PERSNL FB(150 1800)                                               
  SSN      4  5  P  HEADING('SOCIAL' 'SECURITY' 'NUMBER') 
  EMPNAME 17  20 A                                                     
  PAY-NET 90  4  P 2                                                   
JOB INPUT PERSNL NAME MYPROG                                           
  PRINT REPORT1                                                        
*                                                                      
 269 Easytrieve ® Report Generator 11.6
REPORT REPORT1 LINESIZE 65                                             
  HEADING PAY-NET ('NET' 'PAY') 
  LINE EMPNAME SSN '* NO OVERTIME *' PAY-NET                           
                                                                       
Produce:
                                                                       
  SOCIAL   SECURITY NET   EMPNAME NUMBER PAY    
                                                                       
   WIMN    GLORIA     025-30-5228   * NO OVERTIME *      251.65        
   BERG    NANCY      121-16-6413   * NO OVERTIME *      547.88        
Line Group
A line is the result of a single LINE statement in your program. Each time a PRINT statement is executed, all of the fields
that are indicated on the LINE statement are sent to the printer as a single formatted line. If there is more than one LINE
statement in your program, then they are output in groups for each PRINT statement issued. All of the LINE statements of
the report make up a line group, which is also called a logical report line:
LINE 01 ...ü
LINE 02 ...ý   line group   (logical report line)
LINE 03 ...þ
 ...
The following example illustrates line item positioning:
 
FILE PERSNL  FB(150 1800)                                       
  SSN            4  5  P   MASK '999-99-9999' +                 
                           HEADING('SOCIAL' 'SECURITY' 'NUMBER')
  EMPNAME       17 20 A    HEADING 'EMPLOYEE NAME'              
  ADDR-STREET   37 20 A    HEADING 'STREET'                     
  ADDR-CITY     57 12 A    HEADING 'CITY'                       
  SEX          127    1 N  HEADING('SEX' 'CODE')                
JOB INPUT PERSNL NAME MYPROG                                    
  PRINT REPORT1                                                 
*     
REPORT REPORT1 LINESIZE 65                                      
  LINE    EMPNAME SSN SEX                                       
  LINE 02 ADDR-STREET ADDR-CITY                                 
                                                                
          item area        item area    item area               
      ┌───────┴────────┐ ┌─────┴─────┐    ┌─┴──┐                
       1   5    10   15   1   5    10      1  4                 
       ...............    ...........      ....                 
                                                                
                             SOCIAL            ü         
                            SECURITY      SEX  ý Heading  
        EMPLOYEE NAME        NUMBER       CODE þ          
 270 Easytrieve ® Report Generator 11.6
                                                          
                                                          
       WIMN    GLORIA      025-30-5228     1   ü Line      
       430 M ST SW 107     BOSTON              ý Group    
                                               þ          
For more information about line item positioning, see IDMS  Database Processing .
Processing of Reports
Easytrieve reports are printed and formatted by statements in the report declaration. Review REPORT and Report
Definition statements and their sub-statements.
The PRINT statement discussed in the Input and Output section identifies records for output to a report and initiates
the execution of a report declaration. This does not directly cause the printing of the report. Reports are printed and
formatted by the statements that make up the report declaration. Sometimes the report is called subactivity, because
report declarations are considered subactivities of the JOB activity.
There are two parts to every report declaration:
REPORT Statement
The REPORT statement is the first statement that is coded in a report declaration. The report statement includes the
keyword REPORT and various report parameters.
Report parameters are keywords that permit you to assign values that alter the physical characteristics of the final report.
Although you can specify many report parameters, you can produce most reports using default (defined by Easytrieve )
parameter values.
Report statement parameters provide you with a simple way to define tailored reports. They can be divided into three
categories:
•Spacing control parameters
•Testing aid parameters
•Format determination parameters
Spacing Control Parameters
The following REPORT statement parameters control spacing on a standard format report:
PAGESIZE
Specifies the lines per page. The default is 58.
LINESIZE
Specifies the length of each line. The default is 132.
SKIP
Specifies the number of blank lines to be inserted between line groups. The default is 0.
SPACE
Specifies the number of blanks inserted (horizontally) between field columns and between fields and literals in title
and detail lines. The default is 3.
TITLESKIP
Specifies the number of blank lines inserted after last title line and before the first heading or detail line. The
default is 3.
 271 Easytrieve ® Report Generator 11.6
SPREAD
Requests that the columns of data be spread evenly over the entire line; overrides the SPACE parameter. The
default is NOSPREAD.
NOADJUST
Requests that title lines and report be left-justified on the page. The default is to center the report on the page.
SPREAD and NOADJUST are mutually exclusive.
NODATE
Inhibits printing the system date in positions one through eight of the first title line.
NOPAGE
Inhibits the printing of a page number.
NOHEADING
Inhibits the printing of column headings.
Spacing control parameters are all optional. When used, they can be coded on the REPORT statement in any order. The
general format for these parameters is:
REPORT  report-name   +                         
                                                
       [PAGESIZE nn]  [LINESIZE nn]  +              
       [SKIP nn] [SPACE nn]  +                      
       [TITLESKIP nn] +                         
                                          Spacing
       SPREAD                             Control
       NOSPREAD     +                     Parameters
                                              
       [NOADJUST]     +                         
                                                
       [NODATE] [NOPAGE]  +                  
       [NOHEADING]    +      
REPORT Statement Example
The following program shows an example of how spacing control parameters can be used on the REPORT statement:
 FILE PERSNL FB(150 1800)                                              
   EMP#        9   5   N                                               
   EMPNAME    17   8   A   HEADING ('EMPLOYEE' 'NAME')                 
   DEPT       98   3   N                                               
   GROSS      94   4   P  2  MASK '$$,$$9.99'                          
 JOB INPUT PERSNL NAME FIRST-PROGRAM                                   
   PRINT PAY-RPT                                                       
  REPORT PAY-RPT PAGESIZE 12 NOPAGE NODATE LINESIZE 70 SKIP 2 + 
 272 Easytrieve ® Report Generator 11.6
  SPREAD TITLESKIP 4 
   TITLE 01 'EXAMPLE  PROGRAM'                                         
   LINE 01 EMPNAME EMP# DEPT GROSS                                     
This program produces the following report (only two pages are shown):
                        EXAMPLE  PROGRAM                       
                                                               
                                                               
     EMPLOYEE                                                  
       NAME           EMP#          DEPT           GROSS       
                                                               
     WIMN             12267         903             $373.60    
                        EXAMPLE  PROGRAM                       
                                                               
                                                               
     EMPLOYEE                                                  
       NAME           EMP#          DEPT           GROSS       
                                                               
     BERG             11473         943             $759.20    
Report Definition Statements
The second part of a report declaration is the report definition statements. These statements define the content of your
report. When you use report definition statements, you must code them immediately after the REPORT statement, in the
following order:
•SEQUENCE
•CONTROL
•SUM
•TITLE
•HEADING
•LINE
SEQUENCE Statement
The SEQUENCE statement lets you specify the order of the lines in a report. For example, you might want reports to be in
alphabetical order by name or in numerical order by employee number.
•You can sequence on any field from any input file or any W working storage field.
•You can sequence on as many fields as your system sort permits.
•Sequence fields are stated in major to minor order.
•The default sequence order is ascending. Coding D after a field-name  reverses the order for that field only.
Syntax
 273 Easytrieve ® Report Generator 11.6
SEQUENCE field-name  [D] ...
SEQUENCE Examples
SEQUENCE CO DIV DEPT GROSS-PAY D
SEQUENCE GROUP AMT D CODE
CONTROL Statement
A CONTROL statement specifies that a report should automatically accumulate and print totals. A control break occurs
whenever the value of any control field changes or end-of-report is reached. Control fields can be any non-quantitative
field from any input file or any W working storage field. At each control break, totals are printed for any quantitative fields
that are specified in the report.
•You can specify an unlimited number of control fields.
•Fields are coded on the CONTROL statement in major to minor order.
Syntax
                                                                   
    CONTROL field-name      NEWPAGE     [NOPRINT]   ...             
              FINAL         RENUM                                  
                                                
•Final totals are automatically provided. You can alter the default by coding FINAL NOPRINT.
•NOPRINT following any field-name suppresses the printing of totals for that field (which are still accumulated) at the
corresponding control break.
•NEWPAGE following any field or FINAL causes a new page after the printing of the control break totals (or, in the case
of FINAL, before the printing of the final totals). Page numbers continue.
•RENUM following any field or FINAL causes a page break and restarts page numbers at 1 after the printing of the
control break totals (or, in the case of FINAL, before the printing of the final totals).
Control Examples
CONTROL COMPANY RENUM DIV DEPT NOPRINT
CONTROL FINAL NOPRINT COMPANY NEWPAGE DIV
SUM Statement
The SUM statement specifies that only certain quantitative fields are to be totaled for a control report. Normally on control
reports, Easytrieve  totals all quantitative fields that are specified on the LINE statement (to be discussed later). The SUM
statement overrides this process; only the fields specified on the SUM statement are totaled.
•You can use SUM only in control reports.
•You can SUM any quantitative field from any active file or any W working storage field.
Syntax
SUM field-name   ...  
SUM Example
SUM GROSS NET
 274 Easytrieve ® Report Generator 11.6
TITLE Statement
The TITLE statement lets you define a title for your report. Up to 99 titles are permitted. You can specify literals and field
names on the TITLE statement.
Syntax
                     {[            ] field-name}                         
                     {[# font-number]           }                         
TITLE [title-number] {[            ] ' literal' } ...                     
                     {+ offset                  }                         
                     {- offset                  }                         
                     {COL column-number        }
•You use ± offset  to alter the normal horizontal spacing between literals or fields on the title lines. Spaces are added to
or subtracted from the SPACE parameter (which normally has a default of 3).
•COL column-number  specifies the print column number where the next title item is to begin.
•If no TITLEs are coded, the date and page number, which are normally automatically included in the title, are not
printed.
TITLE Examples
TITLE 01 'REPORT ONE'
TITLE 03 'THIS PAGE FOR DIV' -2 DIV-NO
TITLE 04 'ABC COMPANY'
prints:
01/31/18          REPORT ONE            PAGE 1
              THIS PAGE FOR DIV 15
                 ABC COMPANY
Control Field Values in Titles
Occasionally, you may want to print control field values in report titles. To do this, use the NEWPAGE parameter of the
CONTROL statement and include a control field name on the TITLE statement. Then control breaks occur on a new page
with the control field value in the title, as shown in the following example.
NOTE
Output has been edited for the purpose of illustration.
Statements:                                                             
                                                                       
    FILE PERSNL FB(150 1800)                                           
      EMPNAME  17   8   A                                              
      STATE    69   2   A                                              
      ZIP      71   5   N                                              
      PAY-NET  90   4   P  2  MASK (A '$$,$$9.99')                     
    JOB INPUT PERSNL NAME MY-PROG                                      
      PRINT REPORT-1                                                   
    REPORT REPORT-1 LINESIZE 65                                        
      SEQUENCE STATE ZIP EMPNAME                                          
 275 Easytrieve ® Report Generator 11.6
  CONTROL STATE NEWPAGE 
 TITLE 01 'REPORT FOR THE STATE OF' STATE 
      LINE 01 EMPNAME STATE ZIP PAY-NET                                
 Produce:                                                              
                                                                       
  1/17/18           REPORT FOR THE STATE OF   DC      PAGE      1      
                                                                       
             EMPNAME    STATE    ZIP       PAY-NET                     
                                                                       
             JUDAR       DC     00000         $459.57                  
             PHILPS             00000         $213.76                  
             CROCI              20002         $215.95                  
             WARD               20002         $141.47                  
                         DC                 $1,030.75                  
                                                                       
  1/17/18           REPORT FOR THE STATE OF   MD      PAGE      2      
                                                                       
             EMPNAME    STATE    ZIP       PAY-NET                     
                                                                       
             MILLER      MD     20014         $222.61                  
             PETRIK             20014         $154.70                  
             LACH               20028         $215.91                  
             VETTER             20028         $189.06                  
                         MD                   $782.28                  
                                                                       
  1/17/18           REPORT FOR THE STATE OF   VA      PAGE      3      
                                                                       
             EMPNAME    STATE    ZIP       PAY-NET                     
                                                                       
             MCMAHON     VA     22202         $283.19                  
             CORNING            22204         $103.43                  
             BYER               22207         $259.80                  
             ARNOLD             22209         $356.87                  
                         VA                   $939.03                  
                                                                       
                                            $2,752.06                  
HEADING Statement
As with the DEFINE statement in the library section, you can define an alternate column heading for a field in the report
declaration. The HEADING statement overrides a HEADING parameter that is coded for the same field in the library
section of the program. If alternative headings are not defined, either by a HEADING statement or by the HEADING
parameter of DEFINE, then the field name is used as the heading.
•Use one HEADING statement per field.
•Words in a heading can be stacked to save space in the column. To do this, place individual words in single quotes.
Syntax
HEADING  field-name  ('heading-literal '...)
HEADING Example 1
 276 Easytrieve ® Report Generator 11.6
HEADING EMP-NO 'EMP NO'
This example prints a column heading on the report that looks like:
EMP NO
HEADING Example 2
HEADING SSN ('SOCIAL' 'SECURITY' 'NUMBER')
This example prints a stacked column heading:
 SOCIAL
SECURITY
 NUMBER
LINE Statement
The LINE statement defines the content of a report line. Multiple LINE statements define a line group. Use LINE 01 to
designate headings for the report columns.
•You can specify up to 99 lines per record.
•You can specify any field from an input file or working storage.
Syntax
                   {[            ] field-name }                           
                   {[# font-number]            }                           
                   {[            ] ' literal'  }                           
LINE [line-number] {+offset                   } ...                       
                   {- offset                   }                           
                   {COL column-number         }                           
                   {POS position -number       }
•If literals are specified, they print on all lines but are not used as headings.
•± offset  is used to alter the normal spacing between line items. nn is added to or subtracted from the SPACE
parameter (which normally has a default of 3).
•COL (column) specifies the print column number where the next field is to begin.
•POS (position) provides for aligning fields under the corresponding column heading positions that are indicated on the
LINE 01 statement.
LINE Example
LINE 01 DEPT DIV EMPNAME
LINE 02 POS 2 CODE POS 3 ADDRESS
LINE 03 POS 3 CITY-STATE
This example prints the field contents in the following format:
DEPT          DIV       EMPNAME
 277 Easytrieve ® Report Generator 11.6
911           02        MATT JONES
              512       2232 HILL
                        ANYWHERE IL
Label Report
Use label report in  Easytrieve  to print mailing labels and other applications that require inserting variable data in
repetitious format. Review Label format and the labels parameter.
A label report is different from a standard report in the following ways:
•Label reports do not have titles and headings.
•Multiple labels can be printed side by side.
•Controlled label reports permit control breaks, but do not automatically total quantitative fields. Totals, however, can be
specified on a SUM statement and processed in BEFORE-BREAK and AFTER-BREAK procedures (discussed later in
this article).
You can use the label report function whenever a complete logical print page is to be produced by each PRINT statement.
Label Format
To specify label reports, use the LABELS option of the REPORT statement. The following diagram illustrates the basic
label report page format:
 
┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐ ─          
│    1    │   │    2    │   │    3    │   │    4    │  DOWN (6) 
└─────────┘   └─────────┘   └─────────┘   └─────────┘ ¯          
┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐ ─          
│    5    │   │    6    │   │    7    │   │    8    │            
└─────────┘   └─────────┘   └─────────┘   └─────────┘            
                                                        
│<─SIZE (30)─>│                                         
                                                        
<─────────────────────LINESIZE──────────────────────>            
                                                                 
                     ACROSS (4)      
A label line consists of one or more labels that are positioned across the label page. In this diagram, labels 1 to 4
compose a label line. A single-line group composes each label. Therefore,  Easytrieve  produces a label for each PRINT
statement execution.  Easytrieve  formats the labels on the page in the order shown in the diagram. DOWN and SIZE
(subparameters of the LABELS option) indicate the dimensions of each label.
LABELS Parameter
Format determination parameters are parameters of the REPORT statement that determine the type of report to be
printed. The LABELS parameter is responsible for formatting reports that print mailing labels.
LABELS specifies that the report is to be in label format rather than the standard report format. It automatically inhibits the
printing of the date, page, headings, and titles. The following subparameters are used with LABELS:
 278 Easytrieve ® Report Generator 11.6
•ACROSS specifies the number of labels printed across the print line (default is 4).
•DOWN specifies the number of lines down from the first line of the first label to the first line of the second label (default
is 6).
•SIZE specifies the number of print positions from the first position on the first label to the first position on the second
label (default is 30).
The LABELS parameter has the following format:
[LABELS ]      +             Format
  ([ACROSS nn]               Determination
   [DOWN nn]                 Parameters
   [SIZE nn])   
REPORT Statement Example
The following program creates the label report shown:
FILE PERSNL FB (150 1800)                                              
  NAME       17   8   A                                                
  ADDRESS    37  39   A                                                
    ADDR-STREET 37  20  A                                              
    ADDR-CITY   57  12  A                                              
    ADDR-STATE  69   2  A                                              
    ADDR-ZIP    71   5  N                                              
                                                                       
JOB INPUT PERSNL NAME FIRST-PROGRAM                                    
  PRINT PAY-RPT                                                        
                                                                       
 REPORT PAY-RPT LABELS (ACROSS 3 SIZE 23) 
  LINE 01 NAME                                                         
  LINE 02 ADDR-STREET                                                  
  LINE 03 ADDR-CITY ADDR-STATE                                         
  LINE 04 ADDR-ZIP          
This program produces the following report:
 WIMN                   BERG                   CORNING                 
 430 M ST SW 107        3710 JENIFER ST N W    3208 S 5TH              
 WASHINGTON     DC      WASHINGTON     DC      ARLINGTON      VA       
 20004                  20015                  22204                   
                                                                       
                                                                       
 NAGLE                  ARNOLD                 MANHART                 
 826 D STREET SE        1569 COLONIAL TERR A   1305 POTOMAC ST N W     
 WASHINGTON     DC      ARLINGTON      VA      WASHINGTON     DC       
 20003                  22209                  20007                   
                                                                       
                                                                       
 279 Easytrieve ® Report Generator 11.6
 TALL                   BRANDOW                LARSON                  
 1412 36TH ST NW        3616 B ST S E          610 H ST SW             
 WASHINGTON     DC      WASHINGTON     DC      WASH           DC       
 20007                  20019                  20024                   
                                                                       
                                                                       
 BYER                   HUSS                   POWELL                  
 3400 NORTH 18TH STRE   1355 TEWKESBURY PLAC   5023 AMES STREET N E    
 ARLINGTON      VA      WASHINGTON     DC      WASHINGTON     DC       
 22207                  20012                  20019                   
Testing Aid Parameters
Testing aid parameters in  Easytrieve  are provided as a testing aid for report development. Run your report programs
against real data while limiting the amount of information printed.
There are two testing aid parameters of the REPORT statement: LIMIT and EVERY.
Testing aid parameters have the following format:
REPORT   [ report-name ]  +                                              
  [LIMIT number-of-records ]                                            
  [EVERY n-number-of-lines ]     
•The LIMIT option limits the number of records that are processed by the report. The value, number-of-records , can be
any integer literal in the range 1 through 32,767.
•The EVERY option enables you to specify that only every nth line is to be printed in the report. The value of n-number-
of-lines  can be any integer literal in the range 1 through 32,767.
Format Determination Parameters
Use the format determination parameter LABELS used on the REPORT statement to format labels reports in  Easytrieve .
There are six other format-related parameters of the REPORT statement. This tutorial discusses the following four
parameters. A summary file can be optionally generated during processing of a control report.
The format of these four parameters is:
 REPORT [ report-name ] +
 [SUMMARY] +
 [SUMFILE summary-file-name ] +
        EVERY  
 DTLCTL FIRST  +
        NONE  
        ALL                  
 SUMCTL ( HIAR DTLCOPY    ) +
        NONE DTLCOPYALL     
        TAG                 
 280 Easytrieve ® Report Generator 11.6
DTLCTL Parameter
The DTLCTL (Detail Control) parameter of REPORT establishes the method for printing control field values on detail lines
of a control report by using the subparameters EVERY, FIRST, and NONE. The following example program uses DTLCTL
options. This program can be run with any of the three options.
FILE FILE1                                                             
  LAST-NAME  1  5 A                                                    
  STATE      6  2 A                                                    
  ZIP        8  5 N                                                    
  PAY-NET   13  5 N 2                                                  
JOB INPUT FILE1 NAME MYPROG                                            
  PRINT REPORT1                                                        
*                                                                      
REPORT REPORT1 LINESIZE 65 + DTLCTL option (* replace with one: EVERY, FIRST, or NONE *) 
  SEQUENCE STATE ZIP LAST-NAME                                         
  CONTROL  STATE ZIP                                                   
  LINE 01  LAST-NAME STATE ZIP PAY-NET                                 
SUMCTL Parameter
The SUMCTL (Sum Control) parameter of REPORT establishes the method for printing control field values on total lines
of a control report by using the subparameters ALL, HIAR, NONE, and TAG. (The DTLCOPY subparameter controls
all non-control non-total field values on total lines and is shown, with the SUMMARY parameter, later in this article.)
The following example program uses these options. This program can be run with any of the four options. For more
information, see Processing of Reports.
FILE FILE1                                                             
  LAST-NAME  1  5 A                                                    
  STATE      6  2 A                                                    
  ZIP        8  5 N                                                    
  PAY-NET    13 5 N 2                                                  
JOB INPUT FILE1 NAME MYPROG                                            
  PRINT REPORT1                                                        
*                                                                      
REPORT REPORT1 LINESIZE 65 + SUMCTL option   (* replace with one: ALL, HIAR, NONE, or TAG *) 
  SEQUENCE STATE ZIP LAST-NAME                                         
  CONTROL  STATE ZIP                                                   
  LINE 01  LAST-NAME STATE ZIP PAY-NET                                 
SUMMARY Reports
SUMMARY is a parameter of the REPORT statement that causes the report to print as a summary report.
Summary reports consist of only total lines, which normally include only control fields and totals. All detail lines are
inhibited from printing.
DTLCOPY Subparameter
It can be helpful on summary reports to have detail field information printed on the total lines to provide greater readability.
The DTLCOPY option of the SUMCTL parameter of the REPORT statement copies detail fields (non-control and non-total
fields), as they appear just before the control break, onto the total lines of the summary report.
The following example shows a program that produces a summary report and includes the DTLCOPY option. If this option
were not used, the LAST-NAME values would not print.
 281 Easytrieve ® Report Generator 11.6
DTLCOPY causes the detail information to be printed only on the first control level of the report. DTLCOPYALL causes the
detail to be printed on all summary lines.
Statements:
 
FILE FILE1                                                          
  LAST-NAME  1  5 A                                                 
  STATE      6  2 A                                                 
  ZIP        8  5 N                                                 
  PAY-NET    13 5 N 2                                               
JOB INPUT FILE1 NAME MYPROG                                         
  PRINT REPORT1                                                     
*                                                                   
REPORT REPORT1 LINESIZE 65 + SUMMARY SUMCTL DTLCOPY 
SEQUENCE STATE ZIP LAST-NAME                                        
  CONTROL  STATE ZIP                                                
  LINE 01  LAST-NAME STATE ZIP PAY-NET     
 
Data:
 BROWNIL6007612345  BROWNIL6007667890  JONESIL6007709876  JONESIL6007754321  SMITHTX7521811111  SMITHTX7521866666  
Report:
  Line  Description LAST-NAME STATE ZIP PAY-NET  ZIP total BROWN IL 60076 802.35  ZIP total JONES IL 60077
 641.97  STATE total IL 1444.32  ZIP total SMITH TX 75218 777.77  STATE total TX 777.77    FINAL total
 2222.09  
Summary Files
A summary file, containing all the control and summed field values at each minor break, can be optionally generated
during processing of a control report. JOB activities in your program can subsequently process the summary file to provide
reports not otherwise available through the standard report facilities of  Easytrieve . To request the summary file, define
the file in the library and then reference it with the REPORT SUMFILE parameter. For more information, see Processing of
Reports .
Multiple Reports
Produce multiple reports in  Easytrieve  to one or more printers.
Multiple Reports to a Single Printer
Several reports can be produced simultaneously with one pass of the input file. No special coding is needed for multiple
reports on the same printer. The following program produces three reports from one input file:
FILE PERSNL FB(150 1800)                                               
  EMPNAME       17   8   A                                             
  DEPARTMENT    98   3   N                                             
  NET           90   4   P 2                                           
  GROSS         94   4   P 2                                           
  DEDUCTIONS     W   4   P 2
JOB INPUT PERSNL NAME MULTRPTS                                         
 282 Easytrieve ® Report Generator 11.6
  PRINT RPT1                                                           
  DEDUCTIONS = GROSS - NET                                             
  PRINT RPT2                                                           
  IF DEPARTMENT = 911                                                  
    PRINT RPT3                                                         
  END-IF                                                               
*                                                                      
REPORT RPT1                                                            
  TITLE 1 'REPORT ONE'                                                 
  LINE 1 EMPNAME DEPARTMENT GROSS NET                                  
*                                                                      
 REPORT RPT2 
  SEQUENCE DEPARTMENT                                                  
  TITLE 1 'REPORT TWO'                                                 
  LINE 1 DEPARTMENT EMPNAME GROSS NET DEDUCTIONS                       
*                                                                      
 REPORT RPT3 
  CONTROL                                                              
  TITLE 1 'REPORT THREE - DEPT 911'                                    
  LINE 1 EMPNAME GROSS NET DEDUCTIONS          
REPORT ONE (RPT1) produces a simple listing of all employees.
REPORT TWO (RPT2) gives the same information as REPORT ONE but includes an additional column with the
deductions printed.
REPORT THREE (RPT3) produces a report that contains information from department 911 only.
Multiple Reports to More Than One Printer
Multiple reports in one program can be sent to multiple output devices or multiple printers. This can be an effective way of
economizing on processing time if your site supports multiple output devices.
FILE Directing Parameters
PRINT
The PRINTER parameter of the REPORT statement directs the report's printed output to a file other than the system
default output device (SYSPRINT/SYSLST). Such files must be defined in the library section by a FILE statement that also
contains a PRINTER parameter.
The REPORT statement must identify the appropriate file-name , using the PRINTER parameter in the following format:
REPORT  report-name                                                     
  [PRINTER  file-name ]  
The following example shows an  Easytrieve  program that produces two reports, each sent to separate printers.
FILE PAYFILE                                                           
  EMPNAME      17      16      A                                       
  ADDRESS      57      20      A                                       
  STREET       37      20      A                                       
  EMP-NUMBER    9       5      N                                       
 283 Easytrieve ® Report Generator 11.6
*                                                                      
 FILE SPFORM PRINTER 
*                                                                      
JOB INPUT PAYFILE NAME MULT-PRINTERS                                   
  IF EMP-NUMBER LE 12345                                               
    PRINT FIRST-REPORT                                                 
    PRINT NORM-REPORT                                                  
  END-IF                                                               
*                                                                      
 REPORT FIRST-REPORT PRINTER SPFORM 
  SEQUENCE EMP-NUMBER                                                  
  LINE 1 EMPNAME                                                       
  LINE 3 STREET                                                        
  LINE 5 ADDRESS                                                       
*                                                                      
 REPORT NORM-REPORT 
  LINE 1 EMPNAME ADDRESS EMP-NUMBER      
The first report declaration produces a report to a print output file designated SPFORM in the second file statement. This
print file gets tied to a physical printer through your Job Control Language (JCL) statements.
The second report declaration produces a report that is output to the default printer used with other  Easytrieve  programs.
Report Procedures (PROCs)
Report procedures (PROCs) in  Easytrieve  are user-defined routines invoked in a report declaration to perform data
manipulation outside the logic subactivity. Review a REPORT-INPUT example.
There are seven report PROCs in  Easytrieve .
Code any report procedures immediately after the last LINE statement of each report in your program. To identify report
procedures in your program, use the . PROC keyword, as shown below:
  REPORT statement                                       
   LINE statement                                        
É                    ù                                    
ê REPORT-INPUT. PROC ú                                    
ê BEFORE-BREAK. PROC ú                                    
ê AFTER-BREAK. PROC  ú                                    
ê BEFORE-LINE. PROC  ú                                    
ê AFTER-LINE. PROC   ú                                    
ê ENDPAGE. PROC      ú                                    
ê TERMINATION. PROC  ú                                    
ë                    û                                    
   ** procedure logic **                                 
  END-PROC                  
•You must code an END-PROC at the end of each procedure.
•Code the logic to be executed in a report PROC the same way you code logic in a JOB activity.
•DISPLAY is the only input or output operation permitted.
•Although you can code these procedures in any order, each procedure can be used only once per report.
 284 Easytrieve ® Report Generator 11.6
REPORT-INPUT. PROC
The REPORT-INPUT. PROC allows for final screening and modification of report input data. It is performed for each
record that is selected for the report that contains the PROC.
•If you code a REPORT-INPUT procedure, then you must execute a SELECT statement in the PROC to cause data to
continue to the report.
•If a report has been sequenced, this procedure is invoked after each record is output from the system sort.
REPORT-INPUT Example
Statements:
                                                                       
FILE PERSNL                                                            
  BRANCH          2   2   N                                            
  EMP#            9   5   N                                            
  EMPNAME        17  20   A                                            
  PAY-NET        90   4   P 2                                          
  TOT-NET         S   5   P 2                                          
  PCT-NET-TO-TOT  W   3   P 1                                          
*                                                                      
JOB INPUT PERSNL NAME RPTINPT                                          
  TOT-NET = TOT-NET + PAY-NET                                          
  PRINT PCT-RPT                                                        
*                                                                      
REPORT PCT-RPT LIMIT 20                                                
  SEQUENCE BRANCH EMP#                                                 
  CONTROL FINAL NOPRINT BRANCH NOPRINT                                 
  TITLE 1 'EXAMPLE OF REPORT-INPUT PROC'                               
  LINE 1 BRANCH EMPNAME EMP# PAY-NET PCT-NET-TO-TOT                    
*                                                                      
 REPORT-INPUT. PROC 
  PCT-NET-TO-TOT = PAY-NET / TOT-NET * 100 + .05 
  SELECT 
END-PROC
Produce:
                                                                       
 01/31/91             EXAMPLE OF REPORT-INPUT PROC           PAGE   1  
                                                                       
                               EMPLOYEE          NET                   
  BRANCH    EMPLOYEE NAME       NUMBER           PAY     PCT-NET-TO-TOT
                                                                       
     1    BRANDOW LYDIA         02200             554.31          4.4  
          HUSS    PATTI         11376             223.71          1.8  
          WIMN    GLORIA        12267             251.65          2.0  
                                                                       
     2    NAGLE   MARY          00370             340.59          2.7  
          KRUSE   MAX           03571             182.09          1.5  
          BERG    NANCY         11473             547.88          4.4  
          POWELL  CAROL         11710             167.96          1.3  
                                                                       
 285 Easytrieve ® Report Generator 11.6
     3    PETRIK  KATHY         00577             154.70          1.2  
          CORNING GEORGE        02688             103.43           .8  
          DENNING RALPH         02765             109.60           .9  
          FORREST BILL          03416              13.19           .1  
          MCMAHON BARBARA       04234             283.19          2.3  
          MANHART VIRGINIA      11602             250.89          2.0  
                                                                       
     4    POST    JEAN          00445             206.60          1.7  
          ARNOLD  LINDA         01963             356.87          2.9  
          LARSON  RODNEY        11357             215.47          1.7  
          BYER    JULIE         11467             259.80          2.1  
          TALL    ELAINE        11931             355.19          2.8  
                                                                       
     5    VETTER  DENISE        01895             189.06          1.5  
          LOYAL   NED           04225             230.50          1.8  
BEFORE-BREAK. PROC
The BEFORE-BREAK. PROC allows for modification of totals and special annotation before total line printing caused by
the CONTROL statement. A system-defined field that is named LEVEL can be tested to determine the appropriate break:
LEVEL = 1 for minor break
      = 2 for next break
      = N + 1 for final totals.
       (N is the number of control fields)
In the following example, the BEFORE-BREAK. PROC causes the DEPARTMENT annotation at each of the breaks and
modifies the total in PCT to be the percentage, based on total amounts:
Statements:
                                                                       
FILE PAYROLL                                                           
  EMP#          9    5 N    HEADING ('EMPLOYEE' 'NUMBER')              
  NET          90    4 P 2  HEADING ('NET' 'PAY')                      
  DEPT         98    3 N                                               
  GROSS        94    4 P 2  HEADING ('GROSS' 'PAY')                    
  DED           W    3 P 2                                             
  PCT           W    4 N 2                                             
JOB INPUT PAYROLL NAME CORRECT-PCT                                     
  IF DEPT = 911 914 921                                                
    DED = GROSS - NET                                                  
    PCT = DED / GROSS * 100                                            
    PRINT PCT-REPORT                                                   
  END-IF                                                               
REPORT PCT-REPORT LINESIZE 73                                          
  SEQUENCE DEPT                                                        
  CONTROL FINAL NOPRINT DEPT NOPRINT                                   
  TITLE 1 'THIS REPORT WILL ILLUSTRATE USE OF'                         
  TITLE 2 'BEFORE-BREAK PROCEDURE'                                     
  LINE DEPT EMP# GROSS NET DED PCT                                     
 BEFORE-BREAK. PROC 
 PCT = DED / GROSS * 100 
 286 Easytrieve ® Report Generator 11.6
 IF LEVEL = 1. * DEPT TOTALS 
 DISPLAY SKIP 1 'DEPARTMENT ' DEPT POS 3 GROSS POS 4 NET + 
 POS 5 DED POS 6 PCT 
 DISPLAY SKIP 1 
 END-IF 
 IF LEVEL = 2. * FINAL TOTALS 
 DISPLAY SKIP 1 'FINAL' POS 3 GROSS POS 4 NET + 
 POS 5 DED POS 6 PCT 
 END-IF 
END-PROC 
Produce:
                                                                       
  01/31/91         THIS REPORT WILL ILLUSTRATE USE OF       PAGE 1     
                         BEFORE-BREAK PROCEDURE                        
                                                                       
                                                                       
             EMPLOYEE    GROSS           NET                           
   DEPT       NUMBER      PAY            PAY        DED       PCT      
                                                                       
   911        00445        292.00         206.60     85.40    29.24    
              11710        243.24         167.96     75.24    30.93    
              11357        283.92         215.47     68.45    24.10    
              01963        445.50         356.87     88.63    19.89    
              09764        121.95          96.64     25.31    20.75    
              04589        313.60         229.69     83.91    26.75    
              05805        174.15         134.03     40.12    23.03    
              03890        386.40         272.53    113.87    29.46    
              12461        313.60         219.91     93.69    29.87    
              12829        365.60         238.04    127.56    34.89    
              01730        315.20         202.43    112.77    35.77    
              03571        242.40         182.09     60.31    24.88    
                                                                       
   DEPARTMENT  911 3,497.52  2,522.26  975.26 27.88    
                                                                       
   914        07231      1,004.00         685.23    318.77    31.75    
              08262        376.00         215.95    160.05    42.56    
              10961        399.20         291.70    107.50    26.92    
              11602        344.80         250.89     93.91    27.23    
              00185        279.36         189.06     90.30    32.32    
                                                                       
   DEPARTMENT  914 2,403.36  1,632.83  770.53 32.06    
                                                                       
   921        00577        220.80         154.70     66.10    29.93    
              11376        360.80         223.71    137.09    37.99    
              05482        183.75         141.47     42.28    23.00    
                                                                       
   DEPARTMENT  921 765.35 519.88 245.47 32.07
 
  FINAL 6,666.23  4,674.97  1991.26 29.87 
 287 Easytrieve ® Report Generator 11.6
AFTER-BREAK. PROC
An AFTER-BREAK procedure can be used to produce a special annotation on control reports. The value of LEVEL (a
system-defined field) can be used to determine which control break is being processed. In the following example, the total
line for the second control field ZIP receives a special annotation.
AFTER-BREAK Example
Statements:
                                                                       
    FILE FILE1                                                         
      LAST-NAME  1  5 A                                                
      STATE      6  2 A                                                
      ZIP        8  5 N                                                
      PAY-NET    13 5 N 2                                              
    JOB INPUT FILE1 NAME MYPROG                                        
      PRINT REPORT1                                                    
    *                                                                  
    REPORT REPORT1 LINESIZE 65 +                                       
      SUMMARY  SUMCTL DTLCOPY                                          
      SEQUENCE STATE ZIP LAST-NAME                                     
      CONTROL  STATE ZIP                                               
      LINE 01  LAST-NAME STATE ZIP PAY-NET                             
    *                                                                  
   AFTER-BREAK. PROC 
  IF LEVEL EQ 2 
  DISPLAY 'TOTALS FOR THE STATE OF ' STATE 
  END-IF 
  END-PROC 
  *  
Data:
                                                                       
    BROWNIL6007612345                                                  
    BROWNIL6007667890                                                  
    JONESIL6007709876                                                  
    JONESIL6007754321                                                  
    SMITHTX7521811111                                                  
    SMITHTX7521866666                                                  
Produce:
                                                                       
              LAST-NAME   STATE    ZIP      PAY-NET                    
                                                                       
                BROWN      IL     60076       802.35                   
                JONES      IL     60077       641.97                   
                           IL                1444.32                   
  TOTALS FOR THE STATE OF IL 
                                                                       
 288 Easytrieve ® Report Generator 11.6
                SMITH      TX     75218       777.77                   
                           TX                 777.77                   
  TOTALS FOR THE STATE OF TX 
                                             2222.09                   
ENDPAGE. PROC
You can use an ENDPAGE procedure to produce page footing information. It is invoked whenever end-of-page is
detected. It is typically used to produce page totals or other annotations, as in the following example of page footer
annotation.
ENDPAGE Example
Statements:
                                                                       
FILE FILE1                                                             
  LAST-NAME  1  5 A                                                    
  STATE      6  2 A                                                    
  ZIP        8  5 N                                                    
  PAY-NET   13  5 N 2                                                  
JOB INPUT FILE1 NAME MYPROG                                            
  PRINT REPORT1                                                        
*                                                                      
REPORT REPORT1 LINESIZE 65 +                                           
  SUMMARY  SUMCTL DTLCOPY                                              
  SEQUENCE STATE ZIP LAST-NAME                                         
  CONTROL  STATE NEWPAGE ZIP                                           
  TITLE 'REPORT FOR THE STATE OF' STATE                                
  LINE 01  LAST-NAME STATE ZIP PAY-NET                                 
*                                                                      
 ENDPAGE. PROC 
 DISPLAY SKIP 2 '* CONFIDENTIAL - FOR INTERNAL USE ONLY *' 
END-PROC 
*  
Data:
                                                                       
BROWNIL6007612345                                                      
BROWNIL6007667890                                                      
JONESIL6007709876                                                      
JONESIL6007754321                                                      
SMITHTX7521811111                                                      
SMITHTX7521866666                                                      
Produce:
                                                                       
...                                                                    
* CONFIDENTIAL - FOR INTERNAL USE ONLY *                               
 ╞══════════════════════════════════════════════════════════╡
 289 Easytrieve ® Report Generator 11.6
...
TERMINATION. PROC
A TERMINATION procedure is invoked at the end of the report. You can use this procedure to print report footing
information, including control totals and distribution information. The following is an example of report footing.
TERMINATION Example
Statements:
                                                                       
FILE FILE1                                                             
  LAST-NAME  1  5 A                                                    
  STATE      6  2 A                                                    
  ZIP        8  5 N                                                    
  PAY-NET   13  5 N 2                                                  
  TOTAL-NET  S  8 N 2                                                  
JOB INPUT FILE1 NAME MYPROG                                            
  TOTAL-NET = TOTAL-NET + PAY-NET                                      
  PRINT REPORT1                                                        
*                                                                      
REPORT REPORT1 LINESIZE 65 +                                           
  SUMMARY  SUMCTL DTLCOPY                                              
  SEQUENCE STATE ZIP LAST-NAME                                         
  CONTROL  STATE NEWPAGE ZIP                                           
  TITLE 'REPORT FOR THE STATE OF' STATE                                
  LINE 01  LAST-NAME STATE ZIP PAY-NET                                 
*                                                                      
 TERMINATION. PROC 
 DISPLAY NOTITLE 
 DISPLAY SKIP 5 TOTAL-NET 'IS THE Y-T-D COMPANY NET PAY' 
 DISPLAY SKIP 5 'PLEASE ROUTE THIS REPORT TO CORPORATE OFFICERS' 
END-PROC 
*  
Data:
                                                                       
BROWNIL6007612345                                                      
BROWNIL6007667890                                                      
JONESIL6007709876                                                      
JONESIL6007754321                                                      
SMITHTX7521811111                                                      
SMITHTX7521866666                                                      
Produce:
... 
╞═════════════════════════════════════════════════════════════════╡
 2222.09 IS THE Y-T-D COMPANY NET PAY 
 PLEASE ROUTE THIS REPORT TO CORPORATE OFFICERS  
 290 Easytrieve ® Report Generator 11.6
BEFORE-LINE. PROC and AFTER-LINE. PROC
A BEFORE-LINE procedure is invoked immediately before, and an AFTER-LINE procedure immediately after, the printing
of each detail line.
A BEFORE-LINE or AFTER-LINE procedure is commonly used to print an annotation before or after a detail line on the
report. The following example shows how you can use an AFTER-LINE procedure to print information after a detail line of
a report:
Statements:
                                                                       
   FILE FILE1                                                          
     LAST-NAME  1  5 A                                                 
     STATE      6  2 A                                                 
     ZIP        8  5 N                                                 
     PAY-NET    13 5 N 2                                               
   JOB INPUT FILE1 NAME MYPROG                                         
     PRINT REPORT1                                                     
   *                                                                   
   REPORT REPORT1 LINESIZE 65 +                                        
     DTLCTL   EVERY                                                    
     SEQUENCE STATE ZIP LAST-NAME                                      
     CONTROL  STATE ZIP                                                
     LINE 01  LAST-NAME STATE ZIP PAY-NET                              
   *                                                                   
   AFTER-LINE. PROC 
  IF PAY-NET GE 500 
  DISPLAY '* EMPLOYEE ' LAST-NAME ' + 
  EXCEEDED WEEKLY SALARY GOAL *' 
  END-IF 
  END-PROC 
  *  
Data:
                                                                       
   BROWNIL6007612345                                                   
   BROWNIL6007667890                                                   
   JONESIL6007709876                                                   
   JONESIL6007754321                                                   
   SMITHTX7521811111                                                   
   SMITHTX7521866666                                                   
Produces:
                 LAST-NAME   STATE    ZIP     PAY-NET                  
                                                                       
                   BROWN      IL     60076      678.90                 
   * EMPLOYEE BROWN EXCEEDED WEEKLY SALARY GOAL * 
                   BROWN      IL     60076      123.45                 
                              IL     60076      802.35                 
 291 Easytrieve ® Report Generator 11.6
                                                                       
                   JONES      IL     60077      543.21                 
   * EMPLOYEE JONES EXCEEDED WEEKLY SALARY GOAL * 
                   JONES      IL     60077       98.76                 
                              IL     60077      641.97                 
                                                                       
                              IL               1444.32                 
                                                                       
                   SMITH      TX     75218      666.66                 
   * EMPLOYEE SMITH EXCEEDED WEEKLY SALARY GOAL * 
                   SMITH      TX     75218      111.11                 
                              TX     75218      777.77                 
                                                                       
                              TX                777.77                 
                                                                       
                                               2222.09                 
System-Defined Fields
System-defined fields are fields that  Easytrieve  automatically defines and maintains internally. You can access these
fields in your program to retrieve data that can be useful in processing, or in certain types of error trapping.
This section covers the following topics:
•General Purpose Fields
–SYSDATE
–SYSDATE-LONG
–SYSTIME
–RETURN-CODE
–UIBFCTR
–UIBDLTR
–UIB-ADDRESS
•File Processing Fields
–RECORDLENGTH
–RECORDCOUNT
–FILESTATUS
–PATH-ID
–IDMSCOM
–SLC
–SQLCA
•Report Processing Fields
–LINE-COUNT
–LINE-NUMBER
–PAGE-COUNT
–PAGE-NUMBER
–TALLY
–LEVEL
–BREAK-LEVEL
 292 Easytrieve ® Report Generator 11.6
General Purpose Fields
Review system-defined fields for general use automatically provided in Easytrieve  including SYSDATE, SYSDATE-LONG,
SYSTIME, RETURN-CODE, UIBFCTR, UIBDLTR, and UIB-ADDRESS.
SYSDATE
SYSDATE is a read-only field that contains the system date at the start of Easytrieve  execution. The DATE option of the
Options Table determines the format of the date. Normally, a slash (/) separates the month, day, and year components of
the date (for example, MM/DD/YY). For more information about the DATE option, see the Language Reference  section.
SYSDATE-LONG
SYSDATE-LONG is a read-only field that contains the system date at the start of Easytrieve  execution and is similar to
SYSDATE, except that it includes the century (for example, MM/DD/YYYY).
SYSTIME
SYSTIME is a read-only field that contains the system time at the start of Easytrieve  execution. Normally, a colon (:)
separates the data into hours, minutes, and seconds (for example, HH:MM:SS).
RETURN-CODE
RETURN-CODE is a field whose contents are returned to the operating system in register 15 when Easytrieve  terminates.
RETURN-CODE is initialized to zero, but you can set it to any value. RETURN-CODE applies only to MVS systems.
UIBFCTR
When processing an IMS/DLI database in a CICS environment, UIBFCTR contains the values from the UIBFCTR fields in
the CICS UIB. For a description of the UIBFCTR fields, see the IBM CICS Application Programmer's Reference Manual .
UIBDLTR
When processing an IMS/DLI database in a CICS environment, UIBDLTR contains the values from the UIBDLTR fields in
the CICS UIB. For a description of the UIBDLTR fields, see the IBM CICS Application Programmer's Reference Manual .
UIB-ADDRESS
When processing an IMS/DLI database in a CICS environment, UIB-ADDRESS contains the address of the CICS UIB. It
only contains the UIB-ADDRESS following the execution of a Format 5 DL/I statement. For a description of the UIB, see
the IBM CICS Application Programmer's Reference Manual .
File Processing Fields
Easytrieve  automatically provides system-defined fields for files including RECORD-LENGTH, RECORD-COUNT, FILE-
STATUS, PATH-ID, IDMSCOM, SLC, and SQLCA.
These fields are stored as part of working storage but can be qualified by file-name. As working storage fields, they are
not subject to invalid file reference errors.
RECORD-LENGTH
RECORD-LENGTH is a field with zero decimal places that is used for all file types to determine or establish the length
of the current data record. For variable-length records, this field contains only the length of the record's actual data.
Easytrieve  automatically adjusts the field to account for the 4-byte record-control word and 4-byte block-control-word. For
 293 Easytrieve ® Report Generator 11.6
variable-length files, assign the length of the record to the RECORD-LENGTH field before the PUT or WRITE statement is
executed.
For SQL files, RECORD-LENGTH contains the sum of the maximum lengths of all fields in the file. For IDMS  and IMS/DLI
files, RECORD-LENGTH contains the sum of the maximum lengths of all records in the file.
RECORD-COUNT
RECORD-COUNT is a read-only field with zero decimal places that contains the number of logical I/O operations that are
performed on a file.
For IDMS  and IMS/DLI files, only automatic input increments RECORD-COUNT.
FILE-STATUS
FILE-STATUS is a read-only field that contains the results of the most recent I/O operation on a file. FILE-STATUS is
available when you code STATUS on the I/O statement. If you do not code STATUS, an appropriate error message is
generated. The error message contains one of these codes.
For IDMS  files using automatic input, FILE-STATUS contains IDMSSTATUS. For IMS/DLI files, FILE-STATUS contains the
status code from the PCB.
FILE-STATUS codes and their meanings are:
0000 Operation successful.
Explanation:  This is not an error condition. It indicates that the last I/O operation was successful. No additional
information is required.
0004 End of file.
Explanation:  This is not an error condition. It indicates that the file position has been moved beyond the last
record in the file.
Cause:  This condition occurs following a GET statement when the current record is the last record in the file. It
can occur for SEQUENTIAL, INDEXED, and RELATIVE files.
Following a GET PRIOR statement, this condition could also indicate the beginning of a file.
0008 Record with a duplicate alternate key exists.
Explanation:  This is not an error condition. It indicates that the key of this record matches the key of the record
that follows it in the sequential order of this file.
Cause:  This condition can occur following a GET or READ statement for an INDEXED file that does not have
unique keys.
Following a GET statement, this condition indicates that at least one more record with a matching key is waiting to
be processed.
Following a READ statement, this condition indicates that there is at least one more record in the file with a
matching key (a GET statement must be used to retrieve any remaining records).
In CICS/VS, MVS (batch and TSO), and CMS/OS, an INDEXED file can have non-unique keys if the associated
data set is a VSAM PATH and the auxiliary index data set was defined with non-unique keys.
0012 Duplicate key.
Explanation:  This error condition indicates that an attempt was made to store a record with a duplicate key, or
that there is a duplicate record for an alternate index with the Unique Key option.
Cause:  This condition can occur following a PUT or WRITE ADD statement for an INDEXED file, or a PUT
statement for a RELATIVE file.
For an INDEXED file, it indicates that the key of the record matches the key of a record already present in the file.
For a RELATIVE file, it indicates that the slot that is designated by the relative record number already contains a
record (the slot is not empty).
This condition can also occur following a WRITE UPDATE statement for a SEQUENTIAL or INDEXED file. It
indicates that:
 294 Easytrieve ® Report Generator 11.6
•There is at least one alternate index that is associated with this file.
•The alternate index was defined with the unique key and the upgrade option.
•The updated record caused a duplicate key condition to occur when the alternate index was updated.
0016 Record not found.
Explanation:  This error condition indicates that the record that is designated by the KEY parameter is not found
in the file.
Cause:  This condition can occur following a READ or POINT statement for an INDEXED or RELATIVE file. For
an INDEXED file, it indicates that no record in the file matches the key that is specified by the statement. For a
RELATIVE file, it indicates that the slot that is designated by the relative record number is empty.
0024 Logical or physical error condition.
Explanation:  This error condition indicates that a logical or physical error condition was detected by the access
method routines that are used to access the file. The specific cause of the error is displayed in a runtime abend
message. For a list of the feedback codes, see Messages and Codes .
PATH-ID
For IDMS  and IMS/DLI files, PATH-ID is field that contains the ID value of the lowest record retrieve in a path, using the
RETRIEVE statement. For more information, see the Programming  section.
IDMSCOM
IDMSCOM contains a set of fields that are defined for the IDMS  Communications Block. For more information, see the
Programming  section.
SLC
SLC contains a set of fields that are defined for a logical record communications block. For more information, see the
Programming  section.
SQLCA
SQLCA contains a set of fields that are defined for the SQL communications Block. For more information, see the
Programming  section.
Report Processing Fields
Easytrieve automatically provides system-defined fields for report generating including LINE-COUNT, LINE-NUMBER,
PAGE-COUNT, PAGE-NUMBER, TALLY, LEVEL, and BREAK-LEVEL.
These fields are stored as part of working storage and are read-only.
LINE-COUNT
LINE-COUNT contains the number of lines printed on the page.
LINE-NUMBER
LINE-NUMBER contains the number of the line being printed within the line group.
PAGE-COUNT
PAGE-COUNT contains the number of pages printed.
 295 Easytrieve ® Report Generator 11.6
Programming
Review  Easytrieve  programming references covered in the following section.
This section is for Easytrieve  programmers. As a programmer, you should be familiar with the Easytrieve  language and
understand basic data processing concepts.
This section has information about:
•Applying Easytrieve  programs to various application tasks
•Creating efficient Easytrieve  programs
•Analyzing and modifying existing Easytrieve  programs
This section can be used with the following implementations of the product:
•Easytrieve  Report Generator
•Easytrieve  in the UNIX, Linux, Windows, and z/OS batch environments
This section and the Language Reference  section can help you write Easytrieve  programs. To learn the basic parts of an
Easytrieve  program, see Getting Started .
Text Conventions and Field Rules
Review text conventions in  Easytrieve  that are used in the syntax examples, and the rules for signed and unsigned
fields.
Text Conventions
The following notations are used in syntax examples:
Notation Meaning
{braces} Mandatory choice of one of these entries.
[brackets] Optional entry or choice of one of these entries.
| (OR bar) Choice of one of these entries.
(parentheses) Multiple parameters must be enclosed in parentheses.
... Ellipses indicate you can code the immediately preceding
parameters multiple times.
BOLD Bold text in program code is used to highlight an example of the
use of a statement.
CAPS All capital letters indicate an Easytrieve  keyword, or within text
descriptions, indicate a name or field that is used in a program
example.
lowercase italics Lowercase italics represent variable information in statement
syntax.
Signed and Unsigned Field Rules
You can use both signed and unsigned fields in Easytrieve  programs.
 515 Easytrieve ® Report Generator 11.6
Signed Fields
If you specify a numeric field with decimal positions (0 through 18), the product considers it a signed (quantitative) field.
The following rules apply to signed fields:
•For binary numbers, the product takes the high-order (leftmost) bit as the sign, regardless of field length. For a positive
value, the high-order bit is zero and the remaining bits contain the value in true binary notation. For a negative value,
the high-order bit is 1 and the remaining bits contain the value in 2’s complement notation. For a value of zero, all bits
are zero.
For example, a 1-byte binary field containing a hexadecimal FF has the numeric value -1. Binary numbers are stored in
IBM mainframe byte order on all platforms. That is, the most significant byte of the value is stored first. This is referred
to as 'big endian' byte order.
•For non-negative, zoned decimal numbers on the left side of an assignment statement, the product sets an F sign if
EBCDIC, or a 3 sign if ASCII. Otherwise, it manipulates the number in packed decimal format.
•Packed decimal numbers are manipulated in packed decimal format. Arithmetic operations that result in a positive
result set a C sign.
•By definition, there is no sign in unsigned packed decimal numbers (U format). When you manipulate these numbers,
the product supplies an F sign.
•For most purposes, integer numbers are the same as binary numbers. The difference is that integer numbers are
stored in the native byte order of the platform.
For example, for the Intel X86 platform, integer numbers are stored with the least significant byte first. This is referred
to as 'little endian' byte order.
Unsigned Fields
If you specify a numeric field with no decimal positions, the product considers that field unsigned (non-quantitative). The
following rules apply to unsigned fields:
•For 4-byte binary numbers, the magnitude of the number must fit within 31 bits or less. The NUMERIC test is not true
for a 4-byte binary field with the high-order bit on. If the high-order bit is on, the remaining 31 bits are treated as a
negative value in 2’s complement notation.
•For 8-byte binary numbers, the magnitude of the number must fit within 63 bits or less. The NUMERIC test is not true
for an 8-byte binary field with the high-order bit on. If the high-order bit is on, the remaining 63 bits are treated as a
negative value in 2’s complement notation.
•For 1-, 2-, 3-, 5-, 6-, and 7-byte binary numbers, the high-order bit contributes to the magnitude of the number. For
example, a 1-byte binary field containing a hexadecimal FF has a numeric value of 255.
•All binary numbers are stored in IBM mainframe byte order. That is, the most significant byte is stored first, in big
endian byte order.
•Both zoned decimal and packed decimal fields follow the same rules. The product packs all zoned decimal fields and
handles them as packed fields. The product uses the actual storage value in the field, but it is your responsibility to
maintain a positive sign. An EBCDIC F sign or an ASCII 3 sign is placed in any unsigned field that is used on the left-
hand side of an assignment statement.
•An unsigned packed decimal field (U format) is always unsigned. When you manipulate the field, The product supplies
an F sign.
•As is the case with signed (quantitative) integer numbers, unsigned (non-quantitative) integer numbers are processed
in the same way as unsigned binary numbers and are subject to the same limitations. The only exception is that
integer numbers are always stored in native byte order.
•For fixed-point ASCII numbers, the actual ASCII numeric data can reside anywhere within the field and can contain
leading and trailing blanks or zeros.
 516 Easytrieve ® Report Generator 11.6
Code Programs
Review ways an application program is developed in  Easytrieve  including designing a program and coding the program
logic.
The organization of this section simulates the way an application program is developed. The basic application
development process steps are:
1.Design the program:
–Determine the task you want the program to accomplish.
–Define the files necessary to read and write the information used by the program.
–Fill in successive levels of the design until you have a program structure that accomplishes the task.
2.Code the program logic as designed:
–Code and test the basic flow of your program before filling in lower levels of the design.
For instructions on compiling, link-editing, and executing your program, see Using .
Structured Programming
Easytrieve  language supports structured programming concepts by requiring you to use defined activities and
special-named procedures. These activities and procedures help you create programs that are efficient, reliable, and
maintainable.
Easytrieve  also lets you practice structured programming concepts when you want to incorporate large sections of
procedural code into your program.
Easytrieve  lets you easily break a large program into manageable modules by using PROGRAM, JOB, SCREEN, and
SORT activities, and REPORT and SCREEN special-named procedures. You can code each module to perform a specific
function for the program. Each specific function is then easily identified and maintained.
Easytrieve  lets you create well-structured programs that can be read easily. To accomplish this, design your program with
the following items in mind:
•Keep modules (procedures) small (small enough to fit on one page of the compile listing).
•Use meaningful comments wherever possible so that others can easily read and modify your program.
•Use the  Easytrieve  control flow structures to make programs more readable and efficient.  Easytrieve  provides two
special GOTO statements that are very useful: GOTO JOB and GOTO SCREEN. These statements provide a well-
defined method to instruct  Easytrieve  to iterate the activity process.
•Use the following structured programming statements to control your program in a clear and logical way:
–IF/ELSE/ELSE-IF
–CASE
–DO WHILE
–DO UNTIL
–EXECUTE
–PERFORM
•Use consistent indentation that shows nesting and control flow. Indent statements that are enclosed in control flow
structures, such as IFs and DOs. When nesting these control flow structures, indent an additional level. For example:
Poor Indentation              Good Indentation
================              ================
FILE FILEA                     FILE FILEA
REGION 1 1 N                     REGION    1  1 N
EMPNAME  17 20 A                 EMPNAME  17 20 A
JOB INPUT FILEA                JOB INPUT FILEA
 517 Easytrieve ® Report Generator 11.6
IF REGION = 1                    IF REGION = 1
PRINT RPT                          PRINT RPT
END-IF                           END-IF
REPORT RPT                       REPORT RPT
LINE REGION EMPNAME                LINE REGION EMPNAME
Program Sections
Easytrieve  programs consist of the following sections: Environment, Library, and Activity. Review this topic for more
information.
Environment Section (Optional)
The environment section lets you customize the operating environment for the duration of a program's compilation and
execution by overriding selected general standards for an  Easytrieve  program.
Some of the standard  Easytrieve  options affect the efficiency of an  Easytrieve  program. There can be minor trade-offs
between the automatic debugging tools provided by  Easytrieve  and the efficiency of the program code.
For example, you can specify that  Easytrieve  record the statement numbers of the statements being executed for display
during an abnormal termination (FLOW). Use of this option, however, does have a minor impact on processing time. You
can turn this option on or off in the environment section of each  Easytrieve  program.
Library Section (Optional)
The library section describes the data to be processed by the program. It describes data files and their associated
fields, as well as working storage requirements of a program. The library section is said to be optional because, on rare
occasions, a program may not be doing any input or output of files. However, in most cases, use of the library definition
section is required.
You can shorten processing time by coding data definitions to avoid unnecessary data conversions.
Activity Section (at least one required)
The executable statements that process your data are coded in one or more activity sections. Executable statements in 
Easytrieve  can be procedural statements or declarative statements.
The activity section is the only required section of your program. There are four types of activities: PROGRAM, SCREEN,
JOB, and SORT.
•A PROGRAM activity is a simple top-down sequence of instructions. You can use a PROGRAM activity to conditionally
execute the other types of activities using the EXECUTE statement.
•SCREEN activities define screen-oriented transactions. Data can be displayed to a terminal operator and received
back into the program. Files can be read and updated. A SCREEN activity can EXECUTE a JOB or SORT activity to
perform a special process such as printing a report.
•JOB activities read information from files, examine and manipulate data, write information to files, and initiate reports.
•SORT activities create sequenced or ordered files.
You can code one or more procedures (PROCs) at the end of each activity. Procedures are separate modules of program
code you use to perform specific tasks.
REPORT subactivities are areas in a JOB activity where reports are described. You can code one or more REPORT
subactivities after the PROCs (if any) at the end of each JOB activity. You must code any PROCs used within a REPORT
subactivity (REPORT PROCs) immediately after the REPORT subactivity in which you use them.
 518 Easytrieve ® Report Generator 11.6
The following exhibit shows some  Easytrieve  keywords and other items in the sections where they are usually located,
and gives the general order of  Easytrieve  statements within a program.
PARM ... Environment
Section
FILE  ...
DEFINE ...
...Library
Section
PROGRAM
(statements)
(program procedures)
SCREEN
(screen procedures)
JOB
(statements)
(job procedures)
REPORT
(report procedures)
SORT
(sort procedures)
...Activity
Section
Define Files and Fields
Define files and fields in an  Easytrieve  program using the DEFINE Statement. Use the FILE Statement to define files.
This article explains how to define files and fields in an Easytrieve  program.
Defining Files
Use the FILE statement to describe a file or a database. FILE statements must describe all files and databases that
your program references. FILE statements are the first statements that are coded in the library section of an  Easytrieve 
program.
The FILE statement can differ greatly, depending on the operating environment and the type of file being processed.
NOTE
For more information about files, see FILE Statement  and File Processing .
Defining Fields
Use the DEFINE statement to define fields. The DEFINE statement specifies data fields within a record or within working
storage. You usually specify file fields and work fields in the library section, but you can also define them within an activity
as the following examples illustrate.
This example shows fields that are defined in the library section:
FILE PERSNL  FB(150 1800)                    
  DEFINE EMP#      9    5   N     Library
  DEFINE EMPNAME  17   20   A                
  DEFINE EMP-COUNT W    4   N                
 519 Easytrieve ® Report Generator 11.6
 JOB INPUT PERSNL NAME MYPROG                 
  EMP-COUNT = EMP-COUNT + 1                   
  PRINT REPORT1                   Activity
*                                            
REPORT REPORT1                               
 LINE EMP# EMPNAME EMP-COUNT                   
This example shows a field that is defined in the activity section:
FILE PERSNL  FB(150 1800)                 
 DEFINE EMP#      9    5   N     Library
 DEFINE EMPNAME  17   20   A                   
*                                         
JOB INPUT PERSNL NAME MYPROG              
  DEFINE EMP-COUNT W    4   N             
  EMP-COUNT = EMP-COUNT + 1               
  PRINT REPORT1                  Activity
*                                         
REPORT REPORT1                            
 LINE EMP# EMPNAME EMP-COUNT                
When fields are defined within an activity, each field definition must start with the DEFINE keyword and physically be
defined before the field is referenced. In the library section, using the DEFINE keyword is optional.
If the same field is defined more than once, the first definition is used and subsequent definitions are ignored.
NOTE
For more information about the DEFINE statement format, see DEFINE Statement .
File Fields
File fields are normally defined immediately following the associated FILE statement in the library section of an  Easytrieve
program. Their rules of usage are:
•Easytrieve  accepts an unlimited number of fields for each file (constrained by available memory).
•Field names must be unique within a file.
•You can define file fields anywhere in a library or activity section, except within a REPORT sub-activity or a SCREEN
declaration.
•For more specific information about defining fields in a database file, see the appropriate SQL or IDMS  documentation.
Working Storage Fields
You can specify two types of working storage fields: S (static) and W (work). Each type is used in a different way,
particularly when used in reporting. It is recommended to ALWAYS use S fields unless you know exactly what W means to
your application and the special processing that is associated with spooled work fields.
Fields that are defined as type S are stored in a static working storage area and are not copied onto report work files. All
references to S fields in a report occur at the time the report is formatted and printed.
Fields that are defined as type W are copied onto the report work files at the time a PRINT statement is executed. A
spooled report is not formatted and printed at the same time the PRINT is executed. Therefore, the value of a W field on a
report is set at the time the report data is selected for printing, not at the time it is printed.
With this in mind, you should use S (static) working storage fields for:
 520 Easytrieve ® Report Generator 11.6
•Temporary work fields for report procedures
•Line annotations that are controlled from report procedures
•Grand total values that are used to calculate percentages
For examples of the use of W and S fields, see Report Processing . Working storage fields are typically defined in the
library section. Their rules of usage are:
•Easytrieve  accepts an unlimited number of working storage fields (constrained by available memory).
•Working storage fields must be uniquely named within working storage.
•You can define working storage fields anywhere in a library section, activity, or procedure.
Data Reference
Every data reference (file or field) in your program must be unique. You can provide uniqueness in one of the following
ways:
Unique name
-- A name is unique if no other file or work field has that name. For example, GROSS-PAY is unique if it appears
as field-name  in only one DEFINE statement (and has never been copied to another file with a COPY statement).
Qualification
-- Qualification occurs when you prefix the optional qualifier file-name : to a field name.  Easytrieve  requires the
use of the qualifier whenever the field name alone cannot uniquely identify the data reference. The qualifier for file
fields is the associated file name or record name. For working storage fields, the qualifier is the keyword WORK.
Default Qualification
-- Through default qualification,  Easytrieve  attempts to determine which field you want to reference when a field
name is not a unique name.
If you are in the library section, the current FILE (if one is coded) and the WORK file are searched for an occurrence of the
field in question. If the field is not found in either the current file or the WORK file, or if the field occurs in both the current
file and the WORK file, an error message is issued, stating that additional qualification is required.
If you are in a SORT or JOB activity, and you code an INPUT filename  on a JOB statement, the input file is searched
for an occurrence of the field in question. For synchronized file processing, all of the files that are coded on the INPUT
parameter of the JOB statement are checked for an occurrence of the field in question. If the field occurs in exactly one of
the input files, that field is used. If the field occurs in more than one of the default files, an error message is issued, stating
that additional qualification is required.
If the field does not occur in any of the default files, each of the remaining files (including WORK) is searched for an
occurrence of the field in question. If the field occurs in exactly one of the remaining files, that field is used. If the field
occurs in more than one of the remaining files, an error message is issued, stating that additional qualification is required.
If you do not specify an INPUT parameter on the JOB statement, a default input file is used. If the JOB activity
immediately follows a SORT activity, the output from the SORT activity is the default input file. If the JOB activity occurs
at any other point, the default input file is the first FILE coded that is not a TABLE file, a PUNCH file, or a PRINTER file.
Once a default input file is selected, default qualification occurs as described previously.
For PROGRAM, SCREEN, and JOB INPUT NULL activities, no default qualification occurs.
Indexing
Indexing is a data reference that results from  Easytrieve  deriving a displacement value to correspond to a particular
occurrence in a field name that is defined with OCCURS. The formula for deriving the index value is: the number of the
desired occurrence minus one, multiplied by the length of the occurring field element. For example, if an occurring field is
defined as:
DEFINE MONTHWORD MONTH-TABLE 9 A OCCURS 12 INDEX MONTH-INDEX
 521 Easytrieve ® Report Generator 11.6
MONTH-INDEX for the third occurrence is derived as follows:
MONTH-INDEX = (3 - 1) * 9 = 18
See Array Processing  for more information.
Subscripts
Subscripts are an alternative method available to select an individual element from an array. A subscript is a literal or field
that contains the actual occurrence of the element you are referencing.
Using subscripts removes the requirement of computing the index value;  Easytrieve  does it automatically. See Array
Processing  for more information.
Varying Length Fields
The VARYING keyword on the DEFINE statement designates varying length alphanumeric fields. Varying length fields are
often used in SQL databases (VARCHAR). An example of a varying length field definition follows:
FLDA    W   250   A   VARYING
Because VARYING is used, this W-type work field has two parts, which are internally defined as follows:
W  2   B  0  for the two-byte field length
W  248 A     for the data
When you reference this field in your statements, you can use FLDA to specify the field in any one of the following ways:
•To designate the entire field (both length and data portions), specify FLDA . This covers bytes 1 through 250.
•To designate only the length portion of the field (bytes 1 and 2), specify FLDA:LENGTH . This covers bytes 1 and 2
(the alphanumeric portion).
•To designate only the data portion of the field (bytes 3 through 250), specify FLDA:DATA. This covers bytes 3 through
250 (the binary portion).
NOTE
When you reference the entire field,  Easytrieve  automatically uses the length portion of the field when it acts on
the field.
Displaying Varying Length Fields
The display window for varying length fields is based on the maximum length. However, the current value of the length
portion determines how much of the data portion is displayed in the window.
The length portion of the field is not typically displayed. However when DISPLAY HEX is used, length and data is
displayed. DISPLAY HEX displays length and the full data field in hexadecimal and character format. An example follows.
Statements:
DEFINE FLDA  W  7  A  VALUE 'ABCD' VARYING                     
JOB INPUT NULL NAME MYPROG                                     
    DISPLAY FLDA                                               
    DISPLAY HEX FLDA                                           
    STOP                                                       
Results:
ABCD                                                           
CHAR   ABCD                                                    
ZONE 00CCCC4                                                   
NUMB 0412340                                                   
 522 Easytrieve ® Report Generator 11.6
Assigning and Moving Varying Length Fields
Assignments are based on the current length of the data and the rules of assignment. MOVEs default to the current length
of the data. MOVE SPACES moves blanks according to the maximum possible length of the varying length field. An
example follows.
Statements:
DEFINE NULLSTRING W 10 A VARYING VALUE ''                                      
DEFINE SENDVAR    W 10 A VARYING VALUE '12345678'                              
DEFINE RECVVAR07  W  7 A VARYING                                               
DEFINE RECVVAR10  W 10 A VARYING                                               
JOB INPUT NULL NAME MYPROG                                                     
      RECVVAR10 = NULLSTRING      . * ASSIGN NULL STRING TO VARYING            
      DISPLAY '1.  VALUE=' RECVVAR10 ' LENGTH=' RECVVAR10:LENGTH               
      RECVVAR10 = SENDVAR         . * ASSIGN 10 BYTE VARYING TO 10 BYTE VARYING
      DISPLAY '2.  VALUE=' RECVVAR10 ' LENGTH=' RECVVAR10:LENGTH               
      RECVVAR07 = SENDVAR         . * ASSIGN 10 BYTE VARYING TO  7 BYTE VARYING
      DISPLAY '3.  VALUE=' RECVVAR07 ' LENGTH=' RECVVAR07:LENGTH               
      RECVVAR10 = RECVVAR07       . * ASSIGN  7 BYTE VARYING TO 10 BYTE VARYING
      DISPLAY '4.  VALUE=' RECVVAR10 ' LENGTH=' RECVVAR10:LENGTH               
      MOVE SPACES TO RECVVAR07    . * MOVE SPACES TO 7 BYTE VARYING            
      DISPLAY '5.  VALUE=' RECVVAR07 ' LENGTH=' RECVVAR07:LENGTH               
      STOP                                                                     
Results:
1. VALUE=           LENGTH=                                                    
2. VALUE=12345678   LENGTH=    8                                               
3. VALUE=12345      LENGTH=    5                                               
4. VALUE=12345      LENGTH=    5                                               
5. VALUE=           LENGTH=    5                                               
NOTE
•If the sending field has a length of zero and the receiving field is a VARYING field, the receiving field has a
length of zero.
•If the sending field has a length of zero and the receiving field is not a VARYING field, the receiving field is
filled with the fill character (blank for assigned, blank, or specified fill character for MOVE).
Comparing Varying Length Fields
Comparisons of varying length fields are based on the length of the data at the time of the comparison.
8-Byte Binary Fields
To process 8-byte binary fields in  Easytrieve , it may be necessary to edit masks for 8-byte binary fields, assign 8-byte
binary fields to other field types, and define 8-Byte binary fields in expressions.
Processing 8-byte binary fields in  Easytrieve  programs presents some special challenges. These challenges arise from
the fact that the maximum precision for an 8-byte binary field is 19 digits, which is more than  Easytrieve  allows for any
other field type. To allow an  Easytrieve  program to work with 8-byte binary fields, the rule concerning maximum precision
is relaxed. However, it is important to remember that this rule applies solely to 8-byte binary fields.
 523 Easytrieve ® Report Generator 11.6
Edit Masks for 8-Byte Binary Fields
When defining an edit mask for an 8-byte binary field you must remember to provide 19-digit selectors. For example,
consider the following Easytrieve program:
DEFINE TEST-B-FIELD W 8 B 0 +
   MASK '-,---,---,---,---,---,--9'
JOB INPUT(NULL)
TEST-B-FIELD = 1000000
DISPLAY 'TEST-B-FIELD=' TEST-B-FIELD
TEST-B-FIELD = -1000000
DISPLAY 'TEST-B-FIELD=' TEST-B-FIELD
TEST-B-FIELD = -1000000000000000000
DISPLAY 'TEST-B-FIELD=' TEST-B-FIELD
STOP
This program produces the following output:
TEST-B-FIELD=                 1,000,000
TEST-B-FIELD=                -1,000,000
TEST-B-FIELD=-1,000,000,000,000,000,000
NOTE
The last line of output includes all 19 digits of the value.
Assigning 8-Byte Binary Fields to Other Field Types
The 19-digit precision of 8-byte binary fields also affects the result of assignments to fields with other types. These other
fields are restricted to a maximum precision of 18 digits. As such, it is possible to lose the high-order digit of the 8-byte
binary field on assignment. For example, consider the program:
DEFINE TEST-B-FIELD W  8 B 0 VALUE  9223372036854775807
DEFINE TEST-P-FIELD W 10 P 0
JOB INPUT(NULL)
DISPLAY 'TEST-B-FIELD=' TEST-B-FIELD
TEST-P-FIELD = TEST-B-FIELD
DISPLAY 'TEST-P-FIELD=' TEST-P-FIELD
STOP
This program produces the following output:
TEST-B-FIELD=9,223,372,036,854,775,807
TEST-P-FIELD=223,372,036,854,775,807
NOTE
The value lost the high-order digit of 9 during assignment from 8-byte binary to 10-byte packed.
Using 8-Byte Binary Fields in Expressions
As explained previously, the 8-byte binary field can lose its high-order digit during assignment. However, when an 8-byte
binary field appears as a term in an expression, the full value of the field is retained. For example, consider the program:
DEFINE TEST-B-FIELD W  8 B 0 VALUE  9223372036854775807
 524 Easytrieve ® Report Generator 11.6
DEFINE TEST-P-FIELD W 10 P 0
DEFINE TEST-B-NEWFL W  8 B 0
JOB INPUT(NULL)
DISPLAY 'TEST-B-FIELD=' TEST-B-FIELD
TEST-P-FIELD = TEST-B-FIELD / 10
DISPLAY 'TEST-P-FIELD=' TEST-P-FIELD
TEST-B-NEWFL = TEST-P-FIELD * 10 + 7
DISPLAY 'TEST-B-NEWFL=' TEST-B-NEWFL
STOP
This program produces the following output:
TEST-B-FIELD=9,223,372,036,854,775,807
TEST-P-FIELD=922,337,203,685,477,580
TEST-B-NEWFL=9,223,372,036,854,775,807
NOTE
The division causes the low-order digit to be discarded as expected. Also, the multiplication of the 10-byte
packed value produced a 19-digit intermediate value such that the addition produced the original input value,
also as expected.
Declarations
Review declarations that you can code using the DECLARE statement in  Easytrieve .
Declare Screen Item Attributes (  Easytrieve  Online)
You can declare named screen attribute fields by using the DECLARE statement. These declared attributes are different
from ordinary fields that you DEFINE. Screen attributes contain information that controls the display of screen items such
as their color and brightness.
Use of declared attributes provides the ability to dynamically change screen attributes during program execution, and
saves you coding time when the set of attributes is used many times. Declared attributes can be used as follows:
•Use the DECLARE statement to name a set of screen attributes you want to use on multiple screen items.
For example, it is easier to use a declared attribute containing the INTENSE, BLUE, and MUSTFILL attributes on
multiple items than to code the three attributes on each item in the screen. Declared attributes can be used in the
ATTR parameter of the DEFAULT, TITLE, and ROW statements.
•You can use declared attributes to contain a dynamic set of attributes, that is, you can declare named attributes
containing various sets of attributes. To do this, declare an empty named attribute to use on your ROW statements.
Before displaying the screen, you can assign one of the declared attributes containing a specific set of attributes into
the empty declared attribute. This lets you dynamically set the screen attributes of items based on decisions that are
made during execution.
Declare Input Edit Patterns
You can also use the DECLARE statement to declare named input edit patterns. An input edit pattern allows you to
specify a character sequence that describes the format of the data in the field.
NOTE
Use a PATTERN to edit complex combinations of data types and character sequences. Use a MASK to edit
numeric data.
 525 Easytrieve ® Report Generator 11.6
These named input patterns can then be used in the PATTERN parameter of multiple items on ROW statements in a
SCREEN activity. Input data is automatically checked against the pattern and if the data does not conform to its specified
PATTERN, an appropriate error message is issued to the terminal user.
As with declared attributes, using a declared pattern requires you to specify the PATTERN only once. Declared patterns
can then be used on multiple items on ROW statements.
Declare Subprogram Linkage
You can also use the DECLARE statement to specify how you want to link a subprogram. Subprograms can be linked
statically with your  Easytrieve  program or dynamically loaded.
NOTE
•For more information about using screen attributes and patterns, see the Screen Processing  section.
•For more information about subprogram linkage, see Inter-Program Linkage .
Literal and Data Formatting Rules
Review rules for literals and data formatting in  Easytrieve  including ASCII and EBCDIC Alphanumeric, Hexadecimal
Literals, DBCS, and MIXED format Literals.
EBCDIC, ASCII, SBCS, MIXED, and DBCS data formats are processed, but all possible relationships that can exist
between these formats are not supported. The following sections describe each of the supported literals, and explain the
format and conversion rules and format relationship rules for the mainframe:
ASCII and EBCDIC Alphanumeric Literals
Alphanumeric literals are words that are enclosed within single quotes, and can be up to 254 characters long. An
alphanumeric literal can contain ASCII and EBCDIC alphabetic characters A to Z, and numeric characters 0 to 9.
Whenever an alphanumeric literal contains an embedded single quote, you must code two single quotes. For example,
the literal O'KELLY is coded as:
'O''KELLY'
Note: ASCII is supported on UNIX and on Windows. EBCDIC is supported on the mainframe.
Hexadecimal Literals
Hexadecimal literals are words used to code values that contain characters not available on standard data entry
keyboards. Prefix the hexadecimal literal with X' (the letter X and a single quote), and terminate it with a single quote.
Each pair of digits that you code within the single quotes is compressed into one character. Only the digits 0 through 9 and
the letters A through F are permitted. The following hexadecimal literal defines two bytes of binary zeros:
X'0000'
DBCS Format Literals
DBCS format literals contain DBCS characters only. Enclose a DBCS format literal within apostrophes. A DBCS format
literal can be up to 254 bytes long, including the shift codes. An example of a DBCS literal follows:
'[DBDBDBDBDBDB]'
The left bracket ([) and right bracket (]) indicate shift-out and shift-in codes.
 526 Easytrieve ® Report Generator 11.6
MIXED Format Literals
MIXED format literals are words containing both SBCS and DBCS characters. Enclose MIXED format literals within
apostrophes. The presence of shift codes identifies DBCS subfields. Shift codes also identify the code system of that
DBCS data. The word coded within the apostrophes (including the shift codes) cannot exceed 254 bytes in length. A
MIXED literal is defined in the following example:
'EEEE[DBDBDB]'
The left bracket ([) and right bracket (]) indicate shift-out and shift-in codes.
Non-mainframe Data Format
In non-mainframe environments, the product assumes all literals and alphanumeric data are ASCII and performs no
conversion.
Format and Conversion Rules (Mainframe Only)
During compilation, all literals coded in the source program are converted into the correct DBCS code system and data
format (SBCS, MIXED, or DBCS) as dictated by the statements in which they appear. To understand the process used to
determine the correct code system and data format, it is important to identify the element of each program statement that
is interpreted as the subject of that statement. The subject dictates the correct code system and format type.
Literal Subject Elements (Mainframe Only)
Each program statement has a subject element whose DBCS code system and data format define the DBCS code system
and data format of all the other elements that appear on that statement.
The following table lists the subject elements of those statements that support the coding of literals. Those that do not
have a subject element are also included. They are indicated by the words "not applicable."
Statement Subject Element
FILE file-name  .... file-name
DEFINE  field-name  .... field-name
Assignment - field-name  .... field-name
IF field-name .... field-name
DO WHILE field-name  .... field-name
RETRIEVE WHILE field-name  .... field-name
MOVE .... not applicable
POINT file-name  .... file-name
CALL program-name  .... not applicable
DISPLAY .... file-name(printer)
REPORT report-name  .... file-name(printer)
HEADING .... file-name(printer)
TITLE ( report ) .... file-name(printer)
LINE .... file-name(printer)
SCREEN screen-name terminal
DEFAULT .... not applicable
KEY .... terminal
 527 Easytrieve ® Report Generator 11.6
TITLE ( screen ) .... terminal
ROW/REPEAT .... terminal
DBCS Code System and Data Format Literal Rules
Using the identified subject element of each program statement, the table that follows defines the rules for determining
the DBCS code system and data format for a literal. If a literal is not in the required DBCS code system or data format, the
literal is converted to the correct DBCS code system and data format during compilation.
In the following table, the code ASIS means that the data format (SBCS, MIXED, or DBCS) of the literal coded in the
program source is retained by the Easytrieve  compiler (it is not converted).
Statement/
KeywordData Format of Literal DBCS Code System of Literal
FILE - EXIT..USING ASIS PROCESSING
DEFINE - HEADING ASIS PROCESSING
IF/DO...WHILE field-name field-name
Assignment field-name field-name
POINT ASIS file-name
HEADING ASIS file-name(printer)
TITLE ( report ) ASIS file-name(printer)
LINE ASIS file-name(printer)
KEY ASIS terminal
TITLE ( screen ) ASIS terminal
ROW ASIS terminal
Format Relationship Rules (Mainframe Only)
The product processes SBCS, MIXED, and DBCS data formats, but does not support all the possible relationships
that can exist between these data formats. The following table defines the relationships that the product supports.
Relationships that are not defined in the table are not supported. Compilation errors occur if you specify them in your
program.
If a conversion is necessary, the conversion column in the table indicates the additional processing that applies to get the
object into the correct DBCS code system and applicable data format. The letter F means that the object is reformatted
to meet the requirements of the subject element. This category includes the reformatting of numeric data into the numeric
format of the subject and also the reformatting from one data format (SBCS, MIXED, or DBCS) into the data format of the
subject element.
The supported mainframe format relationships are:
Subject Element Data Format Supported Object Data Format Conversion
A - SBCS Alpha SBCS Alphabetic field none
A - SBCS Alpha SBCS Zoned Numeric field F
A - SBCS Alpha SBCS Packed field F
A - SBCS Alpha SBCS Unsigned Packed field F
A - SBCS Alpha SBCS Binary field F
 528 Easytrieve ® Report Generator 11.6
A - SBCS Alpha SBCS Alphabetic Literal none
A - SBCS Alpha SBCS Hexadecimal Literal none
N - Zoned Numeric SBCS Zoned Numeric field none
N - Zoned Numeric SBCS Packed field F
N - Zoned Numeric SBCS Unsigned Packed field F
N - Zoned Numeric SBCS Binary field F
N - Zoned Numeric SBCS Numeric Literal none
P - Packed SBCS Zoned Numeric field F
N - Zoned Numeric SBCS Packed field none
N - Zoned Numeric SBCS Unsigned Packed field F
N - Zoned Numeric SBCS Binary field F
N - Zoned Numeric SBCS Numeric Literal F
N - Unsigned Packed SBCS Zoned Numeric field F
N - Zoned Numeric SBCS Packed field none
N - Zoned Numeric SBCS Unsigned Packed field F
N - Zoned Numeric SBCS Binary field F
N - Zoned Numeric SBCS Numeric Literal F
B - Binary SBCS Zoned Numeric field F
B - Binary SBCS Packed field F
B - Binary SBCS Unsigned Packed field F
B - Binary SBCS Binary field none
B - Binary SBCS Numeric Literal F
M - Mixed SBCS Alphabetic field none
M - Mixed SBCS Zoned Numeric field F
M - Mixed SBCS Packed field F
M - Mixed SBCS Unsigned Packed field F
M - Mixed SBCS Binary field F
M - Mixed MIXED field F C
M - Mixed DBCS/Kanji field F C
M - Mixed SBCS Alphabetic Literal none
M - Mixed SBCS Numeric Literal F
M - Mixed SBCS Hexadecimal Literal none
M - Mixed DBCS Format Literal F C
M - Mixed MIXED Format Literal C
D/K - DBCS/Kanji SBCS Alphabetic field none
D/K - DBCS/Kanji SBCS Zoned Numeric field F
D/K - DBCS/Kanji SBCS Packed field F
D/K - DBCS/Kanji SBCS Unsigned Packed field F
 529 Easytrieve ® Report Generator 11.6
D/K - DBCS/Kanji SBCS Binary field F
D/K - DBCS/Kanji MIXED field F
D/K - DBCS/Kanji DBCS/Kanji field none
D/K - DBCS/Kanji SBCS Alphabetic Literal F
D/K - DBCS/Kanji SBCS Numeric Literal F
D/K - DBCS/Kanji SBCS Hexadecimal Literal none
D/K - DBCS/Kanji DBCS Format Literal none
D/K - DBCS/Kanji MIXED Format Literal F
Control Program Flow
Control the flow of execution through your  Easytrieve  program with the statements that are coded within your activities.
This article includes the following information:
Activities
Easytrieve  activities resemble the steps of a batch job, but they are not constrained by Job Control Language (JCL) and
associated operating system overhead. An Easytrieve  program consists of at least one of the four types of activities:
PROGRAM, SCREEN, JOB, and SORT.
A PROGRAM activity is optional. If used, only one PROGRAM activity can be coded in an Easytrieve  program, and it must
be coded before any other activities. PROGRAM activities can control the entire program. If used, the PROGRAM activity
must EXECUTE the other types of activities when they are to be initiated. If no PROGRAM activity is coded, there is an
implied PROGRAM activity that initiates other activities as follows:
•JOB and SORT activities are executed sequentially until a SCREEN activity is detected.
•The SCREEN activity is executed.
•Any remaining activities must be executed by the first SCREEN activity. Automatic sequential execution does not
proceed beyond the first SCREEN activity.
You can code one or more procedures (PROCs) at the end of each activity. Procedures are local to the activity after which
they are coded. You cannot perform procedures that are not associated with the activity in which the PERFORM is coded.
You can code one or more REPORT subactivities after the PROCs at the end of each JOB activity. You must code PROCs
used within a REPORT subactivity immediately after the REPORT subactivity in which you use them.
Program Flow
The PROGRAM activity is a simple top-down execution of the statements that are contained in it. PROGRAM activity
is delimited by another activity in the source. PROGRAM activity execution stops when any one of the following actions
occurs:
•The end of the activity is reached.
•A STOP statement is executed in the PROGRAM activity.
•A STOP EXECUTE or TRANSFER statement is executed anywhere in the program.
If a PROGRAM activity is coded, it is responsible for the execution of other activities in the program.
Screen Flow
The following code shows the basic flow of a SCREEN activity. See Screen Processing for more information.
 530 Easytrieve ® Report Generator 11.6
 RESET working storage                                                                
 [PERFORM INITIATION]                                                                 
 SCREEN ...                                                                           
 RESET working storage                                                                
       [PERFORM BEFORE-SCREEN]                                                        
         1. Build screen using program fields,
            pending messages, and cursor placement
         2. Send the screen          
         3. Receive the screen
         4. Edit the input data
         5. Handle automatic actions
       [PERFORM AFTER-SCREEN]
       GOTO SCREEN   
 RESET working storage
 [PERFORM TERMINATION]
Job Flow
The following code shows the relationship between JOB activity statements and shows implied statements that are
attributed to JOB:
RESET working storage                                   
[PERFORM start-proc]                                    
JOB ...     retrieve automatic input                    
            IF EOF                                      
              RESET working storage                Logic generated by JOB     
              [PERFORM finish-proc]                     
              wrap-up REPORTS                           
              return to invoking activity               
            END-IF                                      
  IF ...                                                
    PERFORM proc-name                                   
    PRINT report-name                              JOB activity statements    
    ...                                                 
  END-IF                                                
              RESET working storage                     
              GOTO JOB                             Implied iteration at end 
                                                   of JOB statements        
 proc-name. PROC                                        
   ...                                            Optional procedures
 END-PROC                                         and reports are
 REPORT report-name                               placed at end of JOB
                                                  statements       
   ...                                                   
 JOB/SORT/SCREEN                                   Other activities          
 531 Easytrieve ® Report Generator 11.6
Easytrieve  processes input records one at a time. You can use any valid combination of statements to examine and
manipulate the input record. Easytrieve  repeats the processing activity until the input is exhausted or until you issue a
STOP statement.
Sort Flow
The following example illustrates the flow of a SORT activity:
Retrieve first record from input file (file-a)      Step 1                           
                                                     Logic generated by the
DO WHILE NOT EOF file-a                              SORT statement               
                                                               
   IF BEFORE was specified                          Step 2                           
                                                     If BEFORE requested       
      IF RESET working storage fields specified     Step 3                           
        reset all RESET working storage fields       Re-initialize RESET fields 
      PERFORM proc-name                             Step 4                           
                                                     Perform the user's proc 
      IF SELECT statement was executed              Step 5                           
        pass record to SORT                          SELECT executed?         
      END-IF                                          pass record to SORT      
                                              
   ELSE                                          
                                                    Step 6                           
     pass record to SORT                             No BEFORE proc,           
                                                      pass all to SORT            
   END-IF                                 
                                                    Step 7                           
   Retrieve next record from input file (file-a)     Get next record from   
                                                      input file                       
END-DO                                         
                                                    Step 8                           
Perform SORT process (USING fld1, ...)               Actually SORT the         
                                                      records                          
DO WHILE sorted records exist                       Step 9                           
   Write sorted record to output file (file-b)       Write sorted records to 
END-DO                                               output file                      
                                           
proc-name. PROC                                     Step 10                          
...                                                   Optional user-written  
  SELECT                                              procedure is placed  
...                                                   after the SORT              
END-PROC                
JOB/SORT                     
 532 Easytrieve ® Report Generator 11.6
Units of Work and Commit Processing
To help you control the integrity of your files, databases, and other resources, Easytrieve  performs  commit processing.
Commit processing issues commands to the operating environment signifying the end of one unit of work and the start of
another. These commit points provide a point at which updates are committed to the operating system. Changes that are
not committed can be recovered or rolled back.
Commit points and rollbacks can be issued automatically by Easytrieve  or you can control this processing yourself.
Automatic Commit Processing
Each Easytrieve  activity can be considered a logical unit of work. For each activity statement, you can code a COMMIT
parameter on the PROGRAM, JOB, SCREEN, and SORT statements to control the way the product automatically issues
commit points.
Commit points can be issued automatically as follows:
•Use the ACTIVITY | NOACTIVITY subparameter to indicate whether a commit point is issued during the normal
termination of an activity:
–ACTIVITY -- Indicates to commit during the normal activity termination process. This is the default for PROGRAM
activities, if it is not specified.
–NOACTIVITY -- Indicates to not commit during activity termination. This is the default for JOB, SCREEN, and SORT
activities, if it is not specified.
•Use the TERMINAL | NOTERMINAL subparameter to indicate whether a commit point is issued during each terminal I/
O operation that is performed in the activity.
–TERMINAL -- Indicates to commit during each terminal I/O. This includes terminal I/O for SCREEN activities
and also for the Report Display Facility. In CICS, committing during terminal I/O runs your program pseudo-
conversationally. This is the default, if not specified.
–NOTERMINAL -- Indicates to not commit during terminal I/O. In CICS, this runs your program conversationally.
NOTE
•Once an activity with NOTERMINAL specified starts, all child activities execute with NOTERMINAL
specified for them until the parent activity terminates.
•When Easytrieve  determines that a program has been linked to, the linked to program always
behaves as if NOTERMINAL had been specified, that is, the child program always executes in fully-
conversational mode. See Inter-Program Linkage  for more information about the LINK statement.
When an activity terminates abnormally, a rollback is automatically issued to recover the updates that were made since
the last commit point.
If you execute a STOP EXECUTE statement in your activity, it is considered an abnormal termination.
Controlled Commit Processing
You can issue your own commit points and rollbacks as needed for your application by using the COMMIT and
ROLLBACK statements. These commits and rollbacks are performed in addition to the commits and rollbacks that are
automatically issued as a result of the COMMIT parameter on the activity statement.
Note: Controlled commits have no effect on whether programs run conversationally or pseudo-conversationally in CICS.
Recoverable Resources
With a recoverable resource, the actual processing that is performed by the execution of commits and rollbacks is
determined by the operating environment in which Easytrieve  is running. Each time a commit point is issued, Easytrieve
causes the following actions to happen:
 533 Easytrieve ® Report Generator 11.6
•An SQL COMMIT that closes cursors is executed.
•An IDMS COMMIT or IDMS FINISH is executed. IDMS FINISH statements end run-units and are used at the end of
activities or during terminal I/O. Following an IDMS FINISH statement, Easytrieve  does not automatically bind the run-
unit or re-establish currencies.
•HOLDs that have been issued are released.
•Browses of VSAM files are terminated. Easytrieve  can generally reposition the file for you. However, the product
cannot reposition an indexed file if the associated data set is a VSAM PATH and the auxiliary or secondary index data
set was defined with non-unique keys.
•Browses of C-ISAM files are terminated. Because only files with unique keys are supported, the product repositions the
file for you.
•In CICS, printer spool files are closed. Easytrieve  automatically defers opening these files until they are used.
You must provide the necessary logic in your code to handle these events.
CICS
In the CICS environment, the following resources are generally recoverable:
•SQL databases
•VSAM data sets specified as recoverable in their FCT entries
•IDMS  databases
•IMS/DLI databases
In CICS, a commit request (either automatic or controlled) issues a CICS SYNCPOINT command. A rollback request
issues a CICS SYNCPOINT ROLLBACK command. A CICS SYNCPOINT ROLLBACK command terminates the DLI PSB
and database positioning is lost. Easytrieve  does not automatically reschedule the PSB or reposition the DLI database.
When IDMS  is available, a controlled commit request issues an IDMS COMMIT command. An automatic commit issues
an IDMS FINISH command. A rollback request issues an IDMS ROLLBACK command. Each time an IDMS FINISH
command is issued, IDMS  ends the run-unit. You must provide the necessary logic in your program to bind a new run-unit
and re-establish currencies as needed.
TSO and CMS
In TSO and CMS, SQL databases are the only recoverable resources. In TSO, IDMS  databases are also recoverable.
When SQL is available, a commit request (either automatic or controlled) issues an SQL COMMIT command. A rollback
request issues an SQL ROLLBACK command.
Each time a commit point is issued, SQL closes all cursors. You must provide the necessary logic in your program to open
and reposition the cursor as needed. Exceptions can exist for specific SQL databases that maintain cursor positioning
across commits.
For DL/I files, issuing a commit point has no effect. In this case, DL/I CHECKPOINT and RESTART functions should be
used to manage logical units of work. DL/I files do not lose positioning when a commit point is issued.
When IDMS  is available, a controlled commit request issues an IDMS COMMIT command. An automatic commit issues
an IDMS FINISH command. A rollback request issues an IDMS ROLLBACK command. Each time an IDMS FINISH
command is issued, IDMS  ends the run-unit. You must provide the necessary logic in your program to bind a new run-unit
and re-establish currencies as needed.
Non-mainframe
In non-mainframe environments, SQL and C-ISAM are recoverable resources.
When SQL is available, a commit request (either automatic or controlled) issues an SQL COMMIT command. A rollback
request issues an SQL ROLLBACK command. Each time a commit point is issued, SQL closes all cursors. You must
provide the necessary logic in your program to open and reposition the cursor as needed.
 534 Easytrieve ® Report Generator 11.6
When C-ISAM is available, a commit request, either automatic or controlled, issues a call to iscommit. A rollback request
issues a call to isrollback. Each time a commit point is issued, Easytrieve  closes and reopens all active C-ISAM files. Files
are then repositioned upon the next browse operation.
Decision and Branching Logic
Easytrieve  uses certain statements to control the execution of your program using decision and branching logic. These
statements can govern program execution flow depending on the truth value of the conditional expressions. The following
statements are associated with decision and branching logic:
CASE                  IF    
DO                    GOTO  
EXECUTE               PERFORM   
PROC                  STOP  
EXIT                  REFRESH   
RESHOW
Conditional Expressions
Conditional expressions that are used as parameters of IF and DO statements offer an alternative to the normal top to
bottom execution of Easytrieve  statements. The syntax of a conditional expression is:
{IF      }           [ {AND}           ]                           
{DO WHILE} condition [ {   } condition ]...                        
{DO UNTIL}           [ {OR }           ]                           
Easytrieve  accepts seven different conditions. There are five simple conditions (having at most two operands) and two
extended conditions (having potentially an unlimited number of operands):
Simple Conditions Extended Conditions
Field relational Field series
Field class File relational
Field bits
File presence
Record relational
Skeletal examples of each type of conditional expression that are used in an IF statement follow:
Type Example
Field relational IF field-1 = field-2
Field series IF field-1 = field-2, field-3, field-4
Field class IF field-1 ALPHABETIC
Field bits IF field-1 ON X'0F4000'
File presence IF EOF file-name
File relational IF MATCHED file-1, file-2, file-3
Record relational IF DUPLICATE file-name
For more information about each of these conditional expressions, see the Language Reference  section.
 535 Easytrieve ® Report Generator 11.6
Double Byte Character Set Support
The following conditions provide support for DBCS and MIXED fields:
•Field relational
•Field series
•Field class
•Field bits
As with the data equations, when conversion from EBCDIC to DBCS format is part of the conditional expression,
Easytrieve  converts the EBCDIC data using the following techniques:
•Lowercase EBCDIC values into the applicable DBCS Katakana characters
•Other valid EBCDIC characters into their equivalent English values
•Invalid EBCDIC values into DBCS spaces
Combined Conditions
Any of these conditions, simple and extended, can be combined by using the logical connectors AND or OR in any
combination.
For combined conditions, those connected by AND are evaluated first. The connected condition is true only if all of the
conditions are true. The conditions connected by OR are then evaluated. The combined condition is true if any of the
connected conditions are true. You can use parentheses to override the normal AND and OR relationships. The following
table illustrates the results of combining conditions with AND, OR, and parentheses. The values x, y, and z represent any
condition.
 x       y        z         x OR       x AND      x OR       (x OR y)
                           y OR z     y AND z    y AND z       AND z 
True    True     True       True       True       True        True    
True    True     False      True       False      True        False  
True    False    True       True       False      True        True   
True    False    False      True       False      True        False  
False   True     True       True       False      True        True   
False   True     False      True       False      False       False  
False   False    True       True       False      False       False  
False   False    False      False      False      False       False  
Assignments and Moves
Use the assignment statement in  Easytrieve  to establish the value of a field as a result of simple data movements, an
arithmetic expression, or logical bit manipulation.
If necessary, data is converted to the correct format, depending on field type.
•An arithmetic expression produces a numeric value by adding, subtracting, multiplying, or dividing numeric quantities.
•The MOVE statement transfers, without conversion, character strings from one storage location to another.
•The MOVE LIKE statement copies fields with identical field names from one file to another. Assignments are generated
for each field moved. Because assignments are used, the MOVE LIKE statement converts data to the correct format of
the receiving field if necessary.
This article includes the following information:
 536 Easytrieve ® Report Generator 11.6
Arithmetic Expressions
To fully understand how an assignment establishes the value of a field as a result of an arithmetic expression, you need to
know how arithmetic expressions work within Easytrieve . An arithmetic expression allows two or more numeric quantities
to be combined to produce a single value. Arithmetic expressions can be used in assignment statements and in field
relational conditions.
Operators
The arithmetic operators that are used in Easytrieve  are:
Symbol Operation
* multiplication
/ division
+ addition
- subtraction
All fields and literals in an arithmetic expression must be numeric. Easytrieve  follows the standard mathematical order
of operations when computing arithmetic expressions: multiplication and division are performed before addition and
subtraction, in order from left to right.
The following example illustrates how arithmetic expressions are evaluated:
 11  +  5  *  8  -  48  /  16  +  4   Step 1                 
       └───Ú───┘                                             
 11  +     40    -  48  /  16  +  4   Step 2                 
                   └────Ú────┘                               
 11  +     40    -       3     +  4   Step 3                 
└────Ú──────┘                                                
     51          -      3      +  4   Step 4                 
    └───────────Ú────────┘                                   
                48             +  4   Step 5                 
               └────────Ú──────────┘                        
                        52                                   
Parentheses
You can use parentheses to override the normal order of evaluation. Any level of parenthesis nesting is allowed.
Expressions within parentheses are evaluated first, proceeding from innermost parenthesis level to the outermost.
The following example illustrates how parentheses found within arithmetic expressions are evaluated:
 11  +  5  *  ((8  -  48)  /  16  +  4)  Step 1             
             └────Ú──────┘                                  
 11  +  5  *   ( -40      /   16  +  4)  Step 2             
               └───────────Ú─────┘                           
 11  +  5  *   (         -2.5     +  4)  Step 3             
               └────────────────Ú────┘                    
 537 Easytrieve ® Report Generator 11.6
 11  +  5  *                   1.5       Step 4             
        └───────────Ú──────────────┘                         
 11  +             7.5                   Step 5             
└─────────Ú───────────┘                                     
          18.5                                              
Evaluations
When evaluating an arithmetic expression, at most 30 decimal digits are maintained for each operation. During the
calculation of:
                             {*}
               {= }          {/}
field-name-1   {  } value-1  { }   value-2
               {EQ}          {+}
                             {-}
The length and number of decimal places that are maintained during the calculation (intermediate results) are determined
for each operation according to the rules shown in the following table:
If operation is: The number of decimal places equals:
Addition or
subtractionDecimal places  -- The larger of the number of decimal places in
value-1  or value-2 .
Length  -- The larger of the number of integer places in value-1  or
value-2 , plus the number of decimal places in result plus 1.
Multiplication Decimal places  -- The sum of the number of decimal places in
value-1  and value-2 .
Length  -- The sum of the length of value-1  and value-2 .
Division Decimal places  -- The larger of:
The number of decimal places in value-1  minus the number of
decimal places in value-2 .
The number of decimal places in field-name-1  plus one.
Four decimal places.
Length  -- The number of integer places in value-1  plus the
number of decimal places in the result.
If the length of the intermediate result has more than 30 digits, the excess digits must be truncated. For addition,
subtraction, and division, the excess digits are always truncated from the left side of the result.
For multiplication, however, truncation on the right side of the result is attempted. The minimum number of decimal places
to be maintained in the result is the larger of:
•The number of decimal places in field-name-1  plus one
•Four decimal places
If the number of decimal places in the result is less than or equal to this minimum, no digits are truncated from the right
side of the result. Otherwise, the number of digits that are truncated from the right is the smaller of these values:
•The number of excess digits
•The difference between the number of decimal places in the result and the minimum
When truncation occurs on the right, both the length and number of decimal places in the result are reduced by the
number of digits truncated. If there are still excess digits after right truncation, these excess digits are truncated from the
left.
 538 Easytrieve ® Report Generator 11.6
For example, assume that value-1  and value-2  both have a length of 18 digits and both have 4 decimal places. Then,
according to the previous rules table, the result has a length of 36 digits and 8 decimal places. In this case, the number
of excess digits is 6. Then, for various values of the number of decimal places in field-name-1 , the result is truncated as
shown in the next table:
Decimal places in field-name-1 Digits truncated
(left) (right)Decimal places in result
Fewer than 2 6 0 4
2 5 1 4
3 4 2 4
4 3 3 5
5 2 4 6
6 1 5 7
More than 6 0 6 8
Rounding of Intermediate Results in Calculations
A possible loss of precision can occur as a result of the order of mathematical operations. The intermediate result of a
mathematical operation such as multiplication or division can result in a rounding error in the final result. Such an error
may occur, for example, when the result of a division operation is multiplied by 100 to calculate a percent. In the following
example, the result of the calculation is already rounded up in the fifth digit after the decimal point during the division
operation. As a result, precision is lost.
Example:
DEFINE FIELD-NAME-1    W     7   P   5  
          
JOB INPUT NULL 
          
  FIELD-NAME-1 ROUNDED = 29 / 266.92 * 100
  DISPLAY '29 / 266.92 * 100   = ' FIELD-NAME-1
          
  FIELD-NAME-1 ROUNDED = 100 * 29 / 266.92
  DISPLAY '100 * 29 / 266.92   = ' FIELD-NAME-1
          
  STOP        
        
The output of this calculation when the division operation is performed first is:
29/266.92*100 = 10.8646 0
The output of this calculation when the division operation is performed after the multiplication operation is:
100*29/266.92 = 10.8646 8
The example shows the impact of the order of the multiplication and division operations on the intermediate result:
•The FIELD-NAME-1 has five decimal places. The intermediate result is truncated from the right to 5 + 1 decimals.
•When the division is performed first, the intermediate result is truncated to six decimal places from the right this way:
29 / 266.92 = 0.108646785553724 = 0.108646
 539 Easytrieve ® Report Generator 11.6
WARNING
The intermediate result is always truncated, regardless of whether of not the ROUNDED option is used. The
ROUNDED option is applied only when the final value is assigned to the field.
•When the intermediate result is then multiplied by 100, the loss of precision becomes visible as in the example:
Example:
0.108646 * 100 = 10.86460
Solution for a Higher Level of Precision
For a higher level of precision, we recommend performing the multiplication operation before the division operation.
Calculations that are performed in this order do not produce truncated results in the intermediate calculation.
Assignment Statement
The assignment statement establishes a value in a field. The value can be a copy of the data in another field or literal, or it
can be the result of an arithmetic or logical expression evaluation.
The two formats of the assignment statement are:
Format 1 Syntax (Normal Assignment)
                    {= } {send-field-name      } 
 receive-field-name {  } {send-literal         } 
                    {EQ} {arithmetic-expression}
Format 2 Syntax (Logical Expression)
                    {= }                 {AND} {bit-mask-field-name}
 receive-field-name {  } send-field-name {OR } {bit-mask-literal   }
                    {EQ}                 {XOR} {                   }
EBCDIC to DBCS Conversion (Mainframe Only)
When conversion from EBCDIC to Double Byte Character Set format is required for the assignment statement, the
EBCDIC data is converted using the following techniques:
•Converts lowercase EBCDIC values into the applicable DBCS Katakana characters.
•Converts other valid EBCDIC characters into their equivalent English values.
•Converts invalid EBCDIC values into DBCS spaces.
Format 1 (Normal Assignment)
Format 1 sets the value of receive-field-name  equal to the value of send-field-name , send-literal , or the arithmetic
expression . The rules of the statement are shown in the following table:
Receive-field-name  (Left-hand side) Send-field-name  (Right-hand side) Resulting Value
Alphanumeric field Alphabetic field Resulting value of receive-field-name
is padded on the right with spaces or
truncated as necessary.
Numeric field Resulting value of receive-field-name  is the
non-quantitative zoned decimal equivalent
of send-field-name  with padding or
truncation on left as necessary. Assignment
of numeric fields to varying alphanumeric
fields is not allowed.
 540 Easytrieve ® Report Generator 11.6
Alphanumeric or hexadecimal literal Resulting value of receive-field-name
is padded on the right with spaces as
necessary.
Alphanumeric or hexadecimal field MIXED field Each byte of send-literal  is moved to
receive-field-name  unaltered. The resulting
value of receive-field-name is padded on
the right with EBCDIC spaces.
Numeric field Numeric field,
literal,
or arithmetic expressionResult is padded on left with zeros to fit
the description of receive-field-name . If the
value of the assignment is too large to be
stored in receive-field-name , it is truncated
as follows:
For binary numbers (numbers that are
expressed in two's complement form), the
sign and high-order bits are truncated from
the left as necessary, and the remaining
left-most bit becomes the new sign.
For zoned decimal, packed decimal,
and unsigned packed decimal numbers
(numbers that are expressed in sign-
magnitude form), the high-order digits are
truncated from left as necessary. The result
is truncated on the right if the number of
decimal places in receive-field-name  is less
than the right-hand side.
Declared attribute field Declared attribute field Receive-field name  is replaced with the
attributes that are contained in send-field-
name .
Nullable field NULL field Indicator for receive-field-name is set to 1
(indicates NULL).
Not NULL field The assignment works as usual and the
indicator for receive-field-name is set to 0,
indicating NOT NULL.
Literal Indicator for receive-field-name is set to 0.
Arithmetic expression with any NULL
operandA runtime error occurs.
Arithmetic expression in which all operands
are NOT NULLIndicator for receive-field-name is set to 0.
Not nullable field NULL field A runtime error occurs.
DBCS field DBCS field Send-field-name  is converted into the
DBCS code system of receive-field-name.
The resulting value of receive-field-name  is
padded on the right with DBCS spaces or
truncated on the right as necessary.
MIXED field Each EBCDIC byte of send-field-name  is
converted into its equivalent DBCS value.
Any DBCS data that is identified by shift
codes is converted to the DBCS code
system of receive-field-name . The shift
codes are then removed. The resulting
value of receive-field-name  is padded on
the right with DBCS spaces or truncated on
the right as necessary.
 541 Easytrieve ® Report Generator 11.6
Alphabetic field Each byte of send-field-name  is converted
into its equivalent DBCS value and the
resulting value is stored in  receive-field-
name . The resulting value of receive-
field-name  is padded on the right with
DBCS spaces or truncated on the right as
necessary.
Numeric,
packed,
or binary fieldResulting value of receive-field-name  is
zoned decimal equivalent of  send-field-
name with each byte converted into the
DBCS equivalent. Before the conversion,
the result is padded on left with DBCS
zeros, or truncated on left.
DBCS literal Resulting value of receive-field-name  is
padded on the right with DBCS spaces or
truncated on the right as necessary.
DBCS Field Alphanumeric or hexadecimal literal Each byte of send-literal  is converted into
its equivalent DBCS value and the result
is stored in receive-field-name . Resulting
value of receive-field-name  is padded on
the right with DBCS spaces or truncated on
the right as necessary.
MIXED field DBCS field Send-field-name  is converted into the
DBCS code system of receive-field-name .
The shift codes that are defined for the
code system of receive-field-name  are
added and the resulting value is padded on
the right with EBCDIC spaces or truncated
on the right as necessary. When truncation
occurs, DBCS characters are not split.
Truncation is to the nearest double byte.
MIXED field The EBCDIC data in send-field-name  is
moved unaltered to receive-field-name . The
DBCS data that is identified by shift codes
is converted to the DBCS code system of
receive-field-name . The shift codes are
also converted to meet the requirements
of that code system. The resulting value of
receive-field-name  is padded on the right
with EBCDIC spaces or truncated on
the right as necessary. When truncation
occurs within the DBCS portion of a field,
DBCS characters are not split. Truncation is
to the nearest double byte.
Alphabetic field Each byte of send-field-name  is moved
unaltered to receive-field-name . The
resulting value of receive-field-name  is
padded on the right with EBCDIC spaces or
truncated on the right as necessary.
Numeric,
packed,
or binary fieldResulting value of receive-field-name  is
the zoned decimal equivalent of send-field-
name  with padding or truncation on left, if
necessary.
 542 Easytrieve ® Report Generator 11.6
DBCS literal Send-field-name  is converted into the
code system of receive-field-name  and the
correct shift codes are added. The result is
padded on the right with EBCDIC spaces.
Examples
The following examples of Format 1 of the assignment statement illustrate its various rules:
Format 1 (Normal Assignment, receive-field-name  alphanumeric)
Statements:
 
F1A   W   4   A                                                      
F2A1  W   1   A    VALUE 'A'                                         
F2A2  W   6   A    VALUE 'ABCDEF'                                    
F2N1  W   2   N    VALUE 12                                          
F2N2  W   3   P 1  VALUE 1234.5                                      
 ...                                                                 
Resulting Value:
 
F1A  =  F2A1             'A   '                                      
F1A  =  F2A2             'ABCD'                                      
F1A  =  F2N1             '0012'                                      
F1A  =  F2N2             '2345'                                      
F1A  =  X'FF'            X'FF404040'                                 
Note: For an example using varying length alphanumeric fields, see Varying Length Fields in Defining Fields .
Format 1 (Normal Assignment, receive-field-name  numeric)
Statements:
 
DEFINE F1N  W 4 N 1                                                  
DEFINE F2N1 W 4 N 1 VALUE 1                                          
DEFINE F2N2 W 4 N 1 VALUE 2                                          
DEFINE F2N3 W 4 N 1 VALUE 3                                          
JOB INPUT NULL NAME MYPROG                                           
   F1N = F2N1 + F2N2 + F2N3                                          
   DISPLAY SKIP 2 +                                                  
          'F1N = F2N1 + F2N2 + F2N3         = ' F1N                  
   F1N = F2N1 + F2N2 / F2N3                                          
   DISPLAY SKIP 2 +                                                  
          'F1N = F2N1 + F2N2 / F2N3         = ' F1N                  
   F1N = (F2N1 + F2N2) / F2N3                                        
   DISPLAY SKIP 2 +                                                  
          'F1N = (F2N1 + F2N2) / F2N3       = ' F1N                  
   F1N = ((F2N1 / F2N2) * 100) + .5                                  
   DISPLAY SKIP 2 +                                                  
          'F1N = ((F2N1 / F2N2) * 100) + .5 = ' F1N                  
   STOP                                                              
Results:
 543 Easytrieve ® Report Generator 11.6
                                           Resulting                 
                                             Value                   
 
         F1N = F2N1 + F2N2 + F2N3         =   6.0                    
               (1   +   2  +  3)                                     
 
         F1N = F2N1 + F2N2 / F2N3         =   1.6                    
               (1   + 2    / 3)                                      
               (1   + 0.6666)                                        
 
         F1N = (F2N1 + F2N2) / F2N3       =   1.0                    
               (( 1  + 2)    / 3)                                    
                     (3      / 3)                                    
 
         F1N = ((F2N1 / F2N2) * 100) + .5 =  50.5                    
               ((   1 / 2)    * 100) + .5                            
                    ((0.5     * 100) + .5)                           
                                (50  + .5)                           
Format 2 (Logical Expression)
Format 2 of the assignment statement sets the value of receive-field-name  equal to the result of evaluating a logical
expression. The value of send-field-name  is logically acted upon by the value of bit-mask-field-name  or bit-mask-literal .
The lengths of all values must be the same and bit-mask-literal  must be hexadecimal.
•AND -- Zero bits in bit-mask-field-name  or bit-mask-literal  are carried forward to send-field-name  and the result is
placed in receive-field-name .
•OR -- One bit in bit-mask-field-name  or bit-mask-literal  are carried forward to send-field-name  and the result is placed
in receive-field-name .
•XOR -- Corresponding bits of bit-mask-field-name  or bit-mask-literal , and of send-field-name  must be opposite (zero
and one) to result in a one bit in receive-field-name .
Rules for Varying Length Fields
•Receive-field-name  and send-field-name  must both be varying length fields or fixed-length fields.
•Bit-mask-field-name  must be a fixed-length field.
•If receive-field-name  is a varying length field, the length of its data portion must be equal to the length of the data
portion of send-field-length  and the length of bit-mask-field-name  or bit-mask-literal .
Rules for Nullable Fields
The rules for nullable fields are shown in the following table:
Receive-field-name  (Left-hand side) Send-field-name  (Right-hand side) Resulting Value
Nullable field Nullable field but not NULL The receiving field's indicator is set to 0,
indicating NOT NULL.
Not a nullable field The receiving field's indicator is set to 0,
indicating NOT NULL.
Not nullable field NULL field A runtime error occurs.
Example
The following example of Format 2 of the assignment statement illustrates its various rules:
 544 Easytrieve ® Report Generator 11.6
Format 2 (Logical Expression Evaluation) Statements:
Statements:
DEFINE F1P  W 2 P  MASK HEX                                           
DEFINE F2P  W 2 P  VALUE X'123D'                                      
JOB INPUT NULL NAME MYPROG                                            
   F1P = F2P AND X'FFFE'                                            
   DISPLAY SKIP 2  +                                                  
          'F1P = F2P AND X''FFFE'' = ' F1P                            
   F1P = F2P OR  X'000F                                             
   DISPLAY SKIP 2 +                                                   
          'F1P = F2P OR  X''000F'' = ' F1P                            
   F1P = F2P XOR X'FFFF'                                              
   DISPLAY SKIP 2 +                                                   
          'F1P = F2P XOR X''FFFF'' = ' F1P                            
   F1P = F2P XOR F2P                                                  
   DISPLAY SKIP 2 +                                                   
          'F1P = F2P XOR F2P       = ' F1P                            
STOP                                                                  
Results:
 
                              Resulting                               
                                Value                                 
       F1P = F2P AND X'FFFE' = 123C                                   
 
       F1P = F2P OR  X'000F' = 123F                                   
 
       F1P = F2P XOR X'FFFF' = EDC2                                   
 
       F1P = F2P XOR F2P     = 0000                                   
MOVE Statement
MOVE transfers characters from one storage location to another. It is used for moving data without conversion and for
moving variable length data strings. The following table illustrates the rules of the MOVE statement regarding nullable
fields:
Receive-field-name  (Left-hand side) Send-field-name  (Right-hand side) Resulting Value
Nullable field Send-field name  that is not nullable Receiving field's indicator is set to 0,
indicating NOT NULL.
Literal Receiving field's indicator is set to 0,
indicating NOT NULL.
Send-field-name  that is nullable The receiving field's indicator is set to -1
if the sending field is NULL, or if it is NOT
NULL.
Not nullable field NULL field A runtime error occurs.
 545 Easytrieve ® Report Generator 11.6
MOVE LIKE Statement
MOVE LIKE moves the contents of fields with identical names from one file to another. Data movement and conversion
follow the rules of the assignment statement.
Table Processing
In  Easytrieve , tables are made up of an argument and a description. Review this topic to see how to define and search
tables.
•The argument uniquely identifies a table entry.
•The description is the remainder of the table entry.
Some typical examples of table usage include organization structures, parts lists for assembly processes, and accounting
chart-of-accounts.
The search of  Easytrieve  table files is extremely efficient. Therefore, table use is recommended for applications that
need to validate encoded data and retrieve code description.
Defining Tables
There are two types of tables that you can specify on the FILE statement:
In-stream
(specified by the INSTREAM subparameter on the TABLE parameter) directs  Easytrieve  to look for table data
within the program immediately following the definition of the ARG and DESC fields for the file. This table is
established at the time the program is compiled. Its size is limited only by the amount of available memory.
External
(INSTREAM is not specified) indicates that the table is located in a file external to the program. This file must be
sequentially accessible. An external table is established just before use.
An external table can be:
•An existing file that is in ascending order by its search argument
•Created by specifying the name of the table as the TO file-name  parameter in a SORT activity.
External tables that are also indexed files result in a random read to the file using the search argument as the key. This
results in added efficiency.
All data needed to create small tables (to be processed by the SEARCH statement) can be entered instream along with 
Easytrieve  statements; that is, the table data can immediately follow the library definition statements for the table. The
data is delimited by the ENDTABLE statement in the first eight positions of a record.
In-stream table data is 80 characters per record and is unaffected by the SCANCOL options. All characters between the
ARG and DESC definitions and the ENDTABLE delimiter are treated as data.
Note: An in-stream table can be retrieved from a macro file. However, the macro must contain the entire table definition
(FILE statement through ENDTABLE).
The following illustrates a table-of-days  definition:
FILE  DAYTABL  TABLE   INSTREAM                             
   ARG 1    1  A.   DESC   3  9  A                          
1 SUNDAY   }                                                
2 MONDAY   }                                                
 ...       }      (instream data)                           
7 SATURDAY }                                                
ENDTABLE   }                                                
 546 Easytrieve ® Report Generator 11.6
The only way to modify an instream table is to recompile the program after supplying new table data. However, you can
modify external tables without program change, because  Easytrieve  builds these tables dynamically prior to each use.
All tables must be sorted in ascending order by their search argument. No duplicate search arguments are allowed. Table
sequence is validated as the table is created.
The only fields defined for table files are ARG (argument) and DESC (description). ARG defines the field used
when searching the table. DESC defines the field that contains the desired information. The maximum length for an
alphanumeric ARG or DESC field is 254 bytes.
The following illustrates a typical table file description. The resulting table provides descriptions of a hypothetical high
school curriculum:
1011     ENGLISH I      }                               
1012     ENGLISH II     }  records from                 
 ...                    }  CLASSES file                 
 ...                    }                               
9712     HOME ECONOMICS }                               
---------------------------------------                 
FILE     CLASSES  TABLE (150)...                        
   ARG 1  4  A.         DESC  10  40  A     |   
Searching Tables
The SEARCH statement provides access to table information. You can code SEARCH statements any place within a
PROGRAM, SCREEN, or JOB activity, and issue any number of searches against any number of tables. To test the
success of the SEARCH, use the file presence test: IF [NOT] file-name .
The following illustrates the retrieval of high school class descriptions based upon class identification codes:
Statements:
DEFINE CODE          W   4 A                                     
DEFINE DESCRIPTION   W  40 A                                     
FILE CLASSES TABLE INSTREAM                                      
ARG   1  4 A                                                     
DESC 10 40 A                                                     
1011     ENGLISH I                                               
1012     ENGLISH II                                              
1013     ENGLISH III                                             
1014     ENGLISH IV                                              
ENDTABLE                                                         
PROGRAM NAME MYPROG                                              
  MOVE '1012' TO CODE                                            
  SEARCH CLASSES WITH CODE, GIVING DESCRIPTION                   
  IF CLASSES                                                     
    DISPLAY DESCRIPTION                                          
  ELSE                                                           
    DISPLAY 'CLASS NOT FOUND'                                    
  END-IF                                                         
Result:
ENGLISH II                                                      
 547 Easytrieve ® Report Generator 11.6
Array Processing
Use an array in  Easytrieve  to process identical elements by using either index manipulation or subscripting. Review
topics: Bounds Checking, Indexing, Single and multiple dimension arrays, Subscripts, and Segmented Data.
An array is a series of consecutive memory locations in one or more dimensions.
Bounds Checking
Easytrieve  automatically checks that indexes and subscripts do not reference data outside the storage boundary of the
field being referenced. If your index or subscript is out of bounds, an execution error occurs. Subscripts are checked to
ensure that they are within the OCCURS value of the field's definition. Indexes are checked to ensure that the reference is
within the largest enclosing data structure. For file fields, this structure is the file buffer. For working storage fields, this is
the defined field, or the base field if the defined field is a redefinition.
Indexing
Any data field definition can contain the INDEX attribute. An index can be used to reference data fields that occur
multiple times. If you do not use an index, you must either use subscripts or assign individual field names to multiple field
occurrences.
The data field's starting location is adjusted by the contents of its indexes to determine the desired field occurrence. The
INDEX  index-name  value is set to:
(desired occurrence number - 1) * (length of element)
Single Dimension Arrays
The following one-dimensional array is typical of those found in most programs. Data definition is straightforward. The
value of MONTH-INDEX controls access to the desired data occurrence, MONTH.
Statements:
DEFINE ARRAY-ELEMENT W  2  N                                     
DEFINE MONTHS        W 120 A VALUE +                             
                    'JANUARY   +                                 
                     FEBRUARY  +                                 
                     MARCH     +                                 
                     APRIL     +                                 
                     MAY       +                                 
                     JUNE      +                                 
                     JULY      +                                 
                     AUGUST    +                                 
                     SEPTEMBER +                                 
                     OCTOBER   +                                 
                     NOVEMBER  +                                 
                     DECEMBER  '                                 
DEFINE MONTH       MONTHS 10 A +                                 
  OCCURS (12) INDEX (MONTH-INDEX)                                
JOB INPUT NULL NAME MYPROG                                       
  ARRAY-ELEMENT = 11                                             
  MONTH-INDEX = (ARRAY-ELEMENT - 1) * 10                         
  DISPLAY MONTH                                                  
  STOP                                                           
 548 Easytrieve ® Report Generator 11.6
Results:
 NOVEMBER                                                        
Because MONTH is 10 bytes long, the following relationships are true:
ARRAY-ELEMENT is: MONTH-INDEX is: DATA OCCURRENCE is:
1 0 JANUARY
2 10 FEBRUARY
3 20 MARCH
... ... ...
12 110 DECEMBER
Multiple Dimension Arrays
Multiple dimension arrays can be defined in two different ways:
•Define a single field with multiple indexes.
•Index a redefining field, as well as the parent field.
The following table illustrates two arrays that are identical in size and usage, but are defined very differently
MONTH-INDEX-1 MONTH-INDEX-2 MONTH ROW-INDEX-1 COL-INDEX-2 MONTH-CELL
0 0 JANUARY 0 0 JANUARY
0 10 FEBRUARY 0 10 FEBRUARY
0 20 MARCH 0 20 MARCH
30 0 APRIL 30 0 APRIL
30 10 MAY 30 10 MAY
30 20 JUNE 30 20 JUNE
60 0 JULY 60 0 JULY
60 10 AUGUST 60 10 AUGUST
60 20 SEPTEMBER 60 20 SEPTEMBER
90 0 OCTOBER 90 0 OCTOBER
90 10 NOVEMBER 90 10 NOVEMBER
90 20 DECEMBER 90 20 DECEMBER
In both cases, the sum of the indices determines which data occurrence is referenced. Both MONTH and MONTH-CELL
are 10-character fields with two indexes. Both fields also occur twelve times. MONTH-INDEX-1 and ROW-INDEX, and
MONTH-INDEX-2 and COL-INDEX are considered similar indexes.
You can define and access arrays of more than two dimensions by a simple extension of the following examples.
Defining a Field with Multiple Indexes
Statements:
DEFINE QUARTER-ROW W  2  N                                   
DEFINE MONTH-COL   W  2  N                                   
 549 Easytrieve ® Report Generator 11.6
DEFINE MONTHS      W 120 A VALUE +                           
                     'JANUARY   +                            
                      FEBRUARY  +                            
                      MARCH     +                            
                      APRIL     +                            
                      MAY       +                            
                      JUNE      +                            
                      JULY      +                            
                      AUGUST    +                            
                      SEPTEMBER +                            
                      OCTOBER   +                            
                      NOVEMBER  +                            
                      DECEMBER  '                            
DEFINE MONTH  MONTHS 10 A OCCURS (12) +                      
  INDEX (MONTH-INDEX-1, MONTH-INDEX-2)                       
JOB INPUT NULL NAME MYPROG                                   
  QUARTER-ROW = 4                                            
  MONTH-COL   = 2                                            
  MONTH-INDEX-1 = (QUARTER-ROW - 1) * 30                     
  MONTH-INDEX-2 = (MONTH-COL - 1) * 10                       
  DISPLAY MONTH                                              
  STOP                                                       
                                                             
JANUARY
(month-cell)FEBRUARY
(month-cell)MARCH
(month-cell)
APRIL MAY JUNE <── Quarter-Row
JULY AUGUST SEPTEMBER <── Quarter-Row
OCTOBER NOVEMBER DECEMBER <── Quarter-Row
                                                          
    M          M           M                                 
    O          O           O                                 
    N          N           N                                 
    T          T           T                                 
    H          H           H                                 
    -          -           -                                 
    C          C           C                                 
    O          O           O                                 
    L          L           L                                 
                                                             
Result:
 NOVEMBER                                                    
Redefining a Field, Giving Each Field Its Own Index
Statements:
DEFINE QUARTER-ROW W  2  N                                    
 550 Easytrieve ® Report Generator 11.6
DEFINE MONTH-COL   W  2  N                                    
DEFINE MONTHS      W 120 A VALUE +                            
                     'JANUARY   +                             
                      FEBRUARY  +                             
                      MARCH     +                             
                      APRIL     +                             
                      MAY       +                             
                      JUNE      +                             
                      JULY      +                             
                      AUGUST    +                             
                      SEPTEMBER +                             
                      OCTOBER   +                             
                      NOVEMBER  +                             
                      DECEMBER  '                             
DEFINE MONTH         MONTHS     10 A  +                       
  OCCURS (12)                                                 
DEFINE MONTH-ROW     MONTH      30 A, +                       
  OCCURS 4,   INDEX (ROW-INDEX)                               
DEFINE MONTH-COLS    MONTH-ROW  10 A, +                       
  OCCURS 3,   INDEX (COL-INDEX)                               
DEFINE MONTH-CELL    MONTH-COLS 10 A                          
JOB INPUT NULL NAME MYPROG                                    
  QUARTER-ROW = 4                                             
  MONTH-COL   = 2                                             
  ROW-INDEX   = (QUARTER-ROW - 1) * 30                        
  COL-INDEX   = (MONTH-COL - 1) * 10                          
  DISPLAY MONTH-CELL                                          
  STOP    
                                                    
JANUARY
(month-cell)FEBRUARY
(month-cell)MARCH
(month-cell)
APRIL MAY JUNE <── Quarter-Row
JULY AUGUST SEPTEMBER <── Quarter-Row
OCTOBER NOVEMBER DECEMBER <── Quarter-Row
                                                           
    M               M             M                          
    O               O             O                          
    N               N             N                          
    T               T             T                          
    H               H             H                          
    -               -             -                          
    C               C             C                          
    O               O             O                          
    L               L             L                          
    S               S             S                          
Results:
 551 Easytrieve ® Report Generator 11.6
 NOVEMBER                                                   
Subscripts
Subscripts are an alternative method available to select an individual element from an array. A subscript is an integer (or
a field containing an integer) that represents the occurrence number of the element within the array to be referenced. 
Easytrieve  computes the index value for you.
You can use subscripts with a field name in the following way:
[file-name:] field-name ( subscript ... )
The following restrictions apply to the use of subscripts:
•A subscript must be a field name or a literal. An arithmetic expression cannot be coded for a subscript.
•A subscript's value must be a positive integer, no greater than the value specified for the OCCURS parameter of the
DEFINE statement for field-name .
•You cannot subscript a field name used as a subscript.
•An indexed field cannot be used as a subscript.
Subscripting a One-Dimensional Array
A one-dimensional array is defined just as it would be if indexing were to be used. Referring to the Single Dimension
Array shown earlier, the following table illustrates the relationship between the array element and the corresponding array
element value:
ELEMENT is VALUE is
MONTH(1) JANUARY
MONTH(2) FEBRUARY
MONTH(3) MARCH
... ...
MONTH(12) DECEMBER
For this array the maximum value that can be specified for the occurrence number is 12.
Subscripting a Two-Dimensional Array
A two-dimensional array is somewhat more complicated. To define a two-dimensional array, you must define the length
and number of occurrences of each dimension. The following illustrates this:
DATA       W                   30 A   VALUE 'AA+
                                             BB+
                                             CC+
                                             ...
                                             00'
ROW        DATA                10 A   OCCURS 3
COLUMN     ROW                  2 A,  OCCURS 5
ELEMENT    COLUMN               2 A
This illustration defines a two-dimensional array (ELEMENT) with three rows and five columns, each occurrence of which
is an alphabetic field of two characters. The first dimension (ROW) is defined as having three occurrences. The second
 552 Easytrieve ® Report Generator 11.6
dimension (COLUMN) is defined as having five occurrences. The length of the first dimension (ROW) must be the length
of the second dimension (COLUMN) times the number of occurrences of the second dimension (COLUMN).
The following table illustrates the relationship between the array element and the corresponding array element value:
ELEMENT is VALUE is
ELEMENT(1,1) AA
ELEMENT(1,2) BB
ELEMENT(1,3) CC
ELEMENT(1,4) DD
ELEMENT(1,5) EE
ELEMENT(2,1) FF
... ...
ELEMENT(3,5) OO
Subscripting a Three-Dimensional Array
A three-dimensional array is a simple extension of a two-dimensional array. To define a three-dimensional array, you
define the length and number of occurrences of each dimension (as you did for a two-dimensional array). The only
difference is that you add the definition of a third dimension (MONTH-LET). This third dimension permits you to easily
select individual positions within a cell in the array.
The following illustrates the definition and use of a three-dimensional array:
Statements:
DEFINE QUARTER-ROW W  2  N                                       
DEFINE MONTH-COL   W  2  N                                       
DEFINE MONTHS      W 120 A VALUE +                               
                     'JANUARY   +                                
                      FEBRUARY  +                                
                      MARCH     +                                
                      APRIL     +                                
                      MAY       +                                
                      JUNE      +                                
                      JULY      +                                
                      AUGUST    +                                
                      SEPTEMBER +                                
                      OCTOBER   +                                
                      NOVEMBER  +                                
                      DECEMBER  '                                
DEFINE MONTH-ROW     MONTHS     30 A, +                          
  OCCURS 4                                                       
DEFINE MONTH-COLS    MONTH-ROW  10 A, +                          
  OCCURS 3                                                       
DEFINE MONTH-LET     MONTH-COLS 1  A, +                          
  OCCURS 10                                                      
DEFINE MONTH-CELL    MONTH-LET  1 A                              
JOB INPUT NULL NAME MYPROG                                       
*  THIS PROGRAM DISPLAYS THE 3RD                                 
*  LETTER OF THE MONTH IN THE 4TH                                
 553 Easytrieve ® Report Generator 11.6
*  ROW, 2ND COLUMN (THE V IN NOVEMBER)                           
   DISPLAY MONTH-CELL (4, 2, 3)                                  
   STOP                                                          
Results:
V                                                                
Segmented Data
One of the most common data structures is segmented data. Each record contains a fixed portion of data and multiple
occurrences of data segments. The actual number of occurrences is not known until execution time. In COBOL, these
structures are known as variable-length table definitions and are defined with an "occurs depending on" clause.
Defining Segmented Data
The following illustrates the field definitions necessary to describe a personnel record with a fixed area and variable
occurrences of dependent and salary history segments:
FILE MASTER SEQUENTIAL                                               
*                                                                    
* FIXED PORTION                                                      
*                                                                    
EMP-ID            1   5   N                                          
EMPNAME           6   20  A                                          
NO-OF-DEPENDS     26  2   N                                          
NO-OF-JOBS        28  2   N                                          
*                                                                    
* DEPENDENT SEGMENTS                                                 
*                                                                    
DEPEND-INFO       30  26  A        OCCURS 20                         
  DEPEND-NAME     30  20  A        INDEX DEPINDEX                    
  DEPEND-BIRTH    50  6   N        INDEX DEPINDEX                    
*                                                                    
* SALARY HISTORY SEGMENTS                                            
*                                                                    
SALARY-HISTORY    30  16  A        OCCURS 10                         
  SALARY-AMOUNT   30  8   N   2    INDEX SALINDEX                    
  SALARY-GRADE    38  2   N        INDEX SALINDEX                    
  SALARY-EFF-DATE 40  6   N        INDEX SALINDEX                    
Because the starting location for each variable occurring segment is not known, the first position after the fixed portion is
used. Later, to access the data, the lengths of the preceding segments are added to the index to determine the starting
location of the next variable segment. The OCCURS parameter specifies the maximum number of occurrences for each
variable portion.
Accessing Segmented Data
The next example illustrates the index manipulation statements necessary to access the data contained in the file:
FILE MASTER SEQUENTIAL                                               
*                                                                    
* FIXED PORTION                                                      
*                                                                    
 554 Easytrieve ® Report Generator 11.6
EMP-ID            1   5   N                                          
EMPNAME           6   20  A                                          
NO-OF-DEPENDS     26  2   N                                          
NO-OF-JOBS        28  2   N                                          
*                                                                    
* DEPENDENT SEGMENTS                                                 
*                                                                    
DEPEND-INFO       30  26  A        OCCURS 20                         
  DEPEND-NAME     30  20  A        INDEX DEPINDEX                    
  DEPEND-BIRTH    50  6   N        INDEX DEPINDEX                    
*                                                                    
* SALARY HISTORY SEGMENTS                                            
*                                                                    
SALARY-HISTORY    30  16  A        OCCURS 10                         
  SALARY-AMOUNT   30  8   N   2    INDEX SALINDEX                    
  SALARY-GRADE    38  2   N        INDEX SALINDEX                    
  SALARY-EFF-DATE 40  6   N        INDEX SALINDEX                    
WORK-CTR          W   2   N                                          
*                                                                    
JOB INPUT MASTER NAME PERSONNEL-REPORTS                              
  MOVE ZEROS TO DEPINDEX, WORK-CTR . * INITIALIZE DEPENDENT INDEX,CTR
  DO WHILE WORK-CTR < NO-OF-DEPENDS. * PROCESS ALL DEPENDENT PORTIONS
    PRINT DEPEND-REPORT                                              
    WORK-CTR = WORK-CTR + 1                                          
    DEPINDEX = DEPINDEX + 26                                         
  END-DO                                                             
*                                                                    
  MOVE ZERO TO WORK-CTR            . * REINITIALIZE CTR              
  SALINDEX = (NO-OF-DEPENDS * 26)  . * START OF SALARY HISTORY IS THE
*                                  . *   END OF THE DEPENDENT PORTION
  DO WHILE WORK-CTR < NO-OF-JOBS   . * PROCESS ALL SALARY PORTIONS   
    PRINT SALARY-REPORT                                              
    WORK-CTR = WORK-CTR + 1                                          
    SALINDEX = SALINDEX + 16                                         
  END-DO                                                             
*                                                                    
  REPORT DEPEND-REPORT LINESIZE 72 SPACE 1                           
    TITLE 'DEPENDENT REPORT'                                         
    LINE EMP-ID EMPNAME DEPEND-NAME DEPEND-BIRTHDATE                 
*                                                                    
  REPORT SALARY-REPORT LINESIZE 72 SPACE 1                           
    TITLE 'SALARY REPORT'                                            
    LINE EMP-ID EMPNAME SALARY-AMOUNT SALARY-GRADE SALARY-EFF-DATE   
Data Strings
Evaluating strings of data is another common index process. The following illustrates a technique for taking names from
the input record, reversing them, and then printing them. The results of this program are:
REVERSED-NAME DATA-NAME
GLORIA WIMN WIMN,GLORIA
NANCY BERG BERG,NANCY
 555 Easytrieve ® Report Generator 11.6
GEORGE CORNING CORNING,GEORGE
MARY NAGLE NAGLE,MARY
The program code is as follows:
FILE NAMES CARD                                                   
   DATA-NAME        1             20     A                        
      SCAN-NAME     DATA-NAME      1     A  INDEX SUB1            
   REVERSED-NAME    W             20     A                        
      SCAN-REVERSED REVERSED-NAME  1     A  INDEX SUB2            
COUNTER             W              2     P 0                      
SAVE-COUNT          W              2     P 0                      
JOB INPUT NAMES                                                   
*                                                                 
* INITIALIZE REVERSED NAME, SUB1, SUB2, AND COUNTER FIELDS        
*                                                                 
MOVE SPACES TO REVERSED-NAME                                      
MOVE ZEROS TO SUB1, SUB2, COUNTER                                 
*                                                                 
* FIND LENGTH OF LAST NAME                                        
*                                                                 
   DO WHILE SCAN-NAME NQ ','                                      
      COUNTER = COUNTER + 1                                       
      SUB1    = SUB1 + 1                                          
   END-DO                                                         
SAVE-COUNT = COUNTER                . *SAVE LENGTH OF LAST NAME   
COUNTER = 0                         . *RESET COUNTER              
SUB1 = SUB1 + 1                     . *BUMP SUB1 PAST THE COMMA   
*                                                                 
* FIND FIRST NAME AND MOVE TO REVERSED NAME                       
*                                                                 
   DO WHILE SCAN-NAME NQ ' ' +                                    
    AND COUNTER LE 20 - SAVE-COUNT - 1                            
      SCAN-REVERSED = SCAN-NAME                                   
      COUNTER = COUNTER + 1                                       
      SUB2 = SUB2 + 1                                             
      SUB1 = SUB1 + 1                                             
   END-DO                                                         
COUNTER = 0                 . *RESET COUNTER                      
SUB1 = 0                    . *RESET TO BEGINNING OF LAST NAME    
SUB2 = SUB2  + 1            . *BUMP SO SPACE IS BETWEEN FIRST AND 
*                              *LAST NAMES                        
* MOVE LAST NAME TO REVERSED NAME FIELD                           
*                                                                 
   DO WHILE COUNTER LQ SAVE-COUNT - 1                             
      SCAN-REVERSED = SCAN-NAME                                   
      COUNTER = COUNTER + 1                                       
      SUB1 = SUB1 + 1                                             
      SUB2 = SUB2 + 1                                             
   END-DO                                                         
PRINT NAMES-REPORT                                                
REPORT NAMES-REPORT LINESIZE 78                                   
 556 Easytrieve ® Report Generator 11.6
    TITLE 1 'EXAMPLE OF HOW TO REVERSE NAMES'                     
    TITLE 2 'INPUT FIELD FORMAT IS:'                              
    TITLE 3 'LAST-NAME,FIRST-NAME'                                
    LINE REVERSED-NAME DATA-NAME                                  
END                                                               
Inter-Program Linkage
Easytrieve provides all of the functions necessary to perform standard input/output, data examination, and data
manipulation. LINK and TRANSFER statements are used to invoke other  Easytrieve  programs. Invoke subprograms
through CALL, LINK, and TRANSFER statements, and the EXIT parameter of the FILE statement.
This article contains the following information:
Using the CALL statement or the FILE EXIT parameter to invoke another  Easytrieve  program is not supported and
will yield unpredictable results. Invoking an  Easytrieve  program using a CALL from a non-  Easytrieve  program is also
unsupported and will produce unpredictable results. Control can be safely transferred from a parent program to an 
Easytrieve  program (as the child) using program LINK requests. LINK request syntax varies depending on the calling
program language.
•The FILE EXIT and CALL statements enable you to invoke subprograms written in other programming languages. All
discussions of the CALL statement also apply to FILE EXITs. (FILE EXITs are CALLs that are controlled automatically
by  Easytrieve .)
•The LINK statement allows you to transfer control from the current program (parent) to another program (child) and
then return control to the parent program.
•The TRANSFER statement allows you to transfer execution to a target program without returning to the invoking
program.
CALL Statement on the Mainframe
The CALL statement on the mainframe provides a means to invoke subprograms written in other programming languages.
The following topics discuss the mainframe techniques used with the CALL statement:
•Program linking
•Storage management
•Linkage (register usage) conventions
•Parameter list
•Error condition handling
Program Linking
Called subprograms can be statically or dynamically linked with the  Easytrieve  object module. You must declare which
type of linkage you want to use in your  Easytrieve  program. To do this, use one of the following on the PARM statement:
•The CALL parameter; for example:
PARM CALL (STATIC)
•The DECLARE statement; for example:
DECLARE INTCALC PROGRAM DYNAMIC
The way that the called program is bound is determined by the following, in order:
1.If the program was declared on a DECLARE statement, the STATIC or DYNAMIC keyword on the DECLARE
statement determines how it is bound.
 557 Easytrieve ® Report Generator 11.6
2.If specified, the CALL parameter on the PARM statement supplies the default for all called programs in your 
Easytrieve  program.
3.The default is determined by the environment. The default on the mainframe is DYNAMIC. The default on UNIX is
STATIC.
In CICS, all dynamic programs are loaded by executing the CICS LOAD command. The LOAD command dynamically
places the program in storage and returns the program's entry point to  Easytrieve .
Each time the CALL statement is executed,  Easytrieve  determines whether or not the program has been loaded. If
the program has not been loaded,  Easytrieve  executes a CICS LOAD command to load it. Once loaded, the program
remains loaded until it reaches one of the following points:
•The end of the first activity that references the program -- If the current activity (the child activity) was invoked with an
EXECUTE statement from another activity (the parent activity), and if both the child and parent activity reference the
program, the program is not deleted until the parent activity terminates. The termination of the child activity does not
cause the program to be deleted.
•Easytrieve  performs the next screen input/output operation -- However, if you specified COMMIT NOTERMINAL on
the SCREEN statement or the calling  Easytrieve  program is executing conversationally,  Easytrieve  does not delete
the program.
In MVS, all dynamic programs are loaded by invoking the LOAD function of the operating system, or by invoking the
CEELOAD function when ENVIRONMENT COBOL is used. The LOAD function dynamically places the program in
storage and returns the program's entry point to  Easytrieve .
Easytrieve  loads the program as part of the initialization of the first activity that references the program. If the current
activity (the child activity) was invoked with an EXECUTE statement from another activity (the parent activity), and if both
the child and parent activity reference the program, then  Easytrieve  loads the program during the initialization of the
parent activity. In addition,  Easytrieve  does not delete the program until the termination of the parent activity. Neither the
initialization nor the termination of the child activity has any effect on the program's status.
Storage Management
In VSE, the author of programs in other languages is responsible for managing required storage. If additional storage is
needed (for example, to LOAD another program), you cannot use DOS COMREG facilities. All storage must be:
•Within the originally loaded program
•Obtained using GETVIS
•Uniquely controlled within the STORMAX area
Linkage (Register Usage) Conventions
When  Easytrieve  invokes a subprogram written in another programming language, it adheres to standard IBM register
management conventions. The called subprogram must honor these conventions:
Register Usage
REGISTER 1 Address of the parameter list
REGISTER 13 Address of an 18 fullword register save area
REGISTER 14 Address of where to return to within  Easytrieve
REGISTER 15 Address of the entry point in the subprogram
 558 Easytrieve ® Report Generator 11.6
The subprogram must save the  Easytrieve  registers in the save area addressed by REGISTER 13 and must restore
them prior to returning using REGISTER 14. The 18-fullword register save area provided by  Easytrieve  must be
maintained as illustrated in the following table:
Save Area Usage
WORD 1 Reserved
WORD 2 Set by  Easytrieve  to the address of the save area for the internal
routine prior to the one issuing the subprogram call
WORD 3 Set by the subprogram to the address of the save area within the
subprogram
WORD 4 to WORD 18 Set by the subprogram to values contained in  Easytrieve 
REGISTERS 4 to 12 upon entry to the subprogram
Assembler Subprogram Linkage
Assembler language subprograms present no linkage problems. The following shows the instructions necessary to
successfully control assembler language subprogram linkage:
ASMPGM  CSECT                                                     
        STM  14,12,12(13) save registers 14 through 12            
        LR   11,15        set base register                       
        USING ASMPGM,11   assign base register                    
        LA   14,0(0,13)   address of <easy> save area
        LA   13,MYSAVE    address of subprogram save area         
        ST   13,8(0,14)   chain forward                           
        ST   14,MYSAVE+4  chain backward                          
        LR   10,1         save parameter list address             
        ...                                                       
        ...                                                       
        ...                                                       
RETURN  L    13,4(0,13)   address of <easy> save area
        LM   14,12,12(13) restore <easy> registers   
        MVI  8(13),X'FF'  indicate unused save area               
        SR   15,15        set zero return code                    
        BR   14           return to <easy>           
        ...                                                       
MYSAVE  DC   18A(0)       18 fullword save area                   
        ...                                                       
        ...                                                       
COBOL Subprogram Linkage
Note: COBOL subprograms are supported only in environments in which IBM supports a COBOL program invocation by
an Assembler program. CICS does not support such an invocation.
COBOL subprogram linkage is dependent upon the operating system (z/OS or z/VSE) and the COBOL parameters that
were in effect when the COBOL subprogram was compiled. For specific details about these parameters and linkage
conventions, see the COBOL Programmer's Guide .
The following shows typical COBOL instructions necessary to control subprogram linkage:
 559 Easytrieve ® Report Generator 11.6
...                                                            
LINKAGE SECTION.                                                
01  PARAMETER-1.                                                
...                                                            
01  PARAMETER-2.                                                
...                                                            
01  PARAMETER-N.                                                
...                                                            
PROCEDURE DIVISION USING PARAMETER-1,                           
                         PARAMETER-2,                           
                         ...                                    
                         PARAMETER-N.                           
 ...                                                            
 ...                                                            
GOBACK                                                          
 ...                                                            
ENVIRON Option and ENVIRONMENT Parameter
A COBOL environment is set for PROGRAM activities by coding the ENVIRONMENT COBOL parameter of the
PROGRAM statement to establish the proper LE and COBOL environment for subprograms only and sub-activities called
in that PROGRAM activity. The default for PROGRAM activities is ENVIRONMENT NONE. No default is taken from the
PARM statement or the options table.
WARNING
For performance considerations, we recommend that you set the ENVIRONMENT option to COBOL if many 
Easytrieve  programs are calling Language Environment subprograms. The option should be set to NONE if
most CALLs are made to non-Language Environment subprograms.
A COBOL environment is set for JOB activities in one of the following ways:
•Coding the ENVIRONMENT COBOL parameter of the JOB statement. This establishes the proper LE and COBOL
environment for subprograms called in that JOB activity only.
•Coding the ENVIRONMENT COBOL subparameter of the PARM statement. This establishes the proper LE and
COBOL environment for all subprograms called in all JOB activities of the  Easytrieve  program.
•Setting the ENVIRON=COBOL option of the system Options Table when  Easytrieve  is installed. This establishes
the proper LE and COBOL environment for all subprograms called in all JOB activities for all  Easytrieve  programs.
This option is set into the program at compile time. Changing the option value will not affect link-edited  Easytrieve 
application programs.
•Coding the ENVIRONMENT COBOL parameter of the PROGRAM statement, and that activity invokes the JOB
activity. The COBOL ENVIRONMENT established by the PROGRAM activity will be inherited by the JOB activity.
COBOL ENVIRONMENT Operation
When the ENVIRONMENT COBOL parameter or the ENVIRON=COBOL option is in effect, this alone will not cause the
COBOL ENVIRONMENT to be established. The ENVIRONMENT will not be established unless the activity for which
ENVIRONMENT is specified contains a CALL statement, (in PROGRAM or JOB activities), or an EXECUTE statement,
(in PROGRAM activities). However, if no CALL or EXECUTE is present, the ENVIRONMENT will still be established if the 
Easytrieve  program contains a FILE statement that specifies the EXIT parameter. If none of these conditions exist (no
CALL, EXECUTE, or FILE EXIT), the ENVIRONMENT will not be started even if ENVIRONMENT COBOL is specified in
the program. In that case, no ENVIRONMENT is needed, and that overhead is saved.
When ENVIRONMENT COBOL is in effect for an activity, the ENVIRONMENT is started at the start of the activity, and it is
terminated at the end of the activity.
 560 Easytrieve ® Report Generator 11.6
If a PROGRAM activity starts the COBOL ENVIRONMENT, and then executes a JOB activity, that ENVIRONMENT will
remain active during the execution of the JOB activity. It will not be started and stopped for the JOB activity. Even if the
JOB activity specifies ENVIRONMENT NONE, the ENVIRONMENT started in the PROGRAM activity will remain active
during the JOB activity execution. The COBOL ENVIRONMENT started in the PROGRAM activity will remain active
during all JOB activities EXECUTEd by that PROGRAM activity.
If ENVIRONMENT NONE is specified for the PROGRAM activity, each executed JOB activity for which ENVIRONMENT
COBOL is specified, will get the COBOL ENVIRONMENT started and terminated as the activity starts and terminates, (if
the CALL and FILE EXIT requirements are met).
If no PROGRAM activity is coded, each JOB activity for which ENVIRONMENT COBOL is specified, will get the COBOL
ENVIRONMENT started and terminated as the activity starts and terminates, (if the CALL and FILE EXIT requirements
are met).
When the COBOL ENVIRONMENT is active, the  Easytrieve  runtime becomes the LE Main routine. Any programs called
by the  Easytrieve  application program are LE subprograms. This lets subprograms act properly as called subroutines
without using the ENDJOB compiler option.
COBOL Environment Rules
The rules for using ENVIRONMENT COBOL are as follows:
•The parameter functions for CALLed subprograms, FILE EXITs; it functions in z/OS.
•All COBOL programs in the run unit must be compiled with the RESIDENT and REENTRANT compiler options. This
ensures that all COBOL modules access the same copy of the global data area and optimum performance is obtained.
•FILE EXITs and subprograms can have an AMODE of 24, 31, or ANY and an RMODE of 24 or ANY. If a 24-bit
subprogram is being called from an  Easytrieve  program when ENVIRONMENT(COBOL) is set, these LE runtime
options must also be set: ALL31=(OFF),STACK=(,,BELOW). For information regarding the setting of LE runtime option
overrides for  Easytrieve , please see Installing .
•When the COBOL subprogram issues a GOBACK statement, control returns to the  Easytrieve  statement following the
CALL statement.
•When the COBOL subprogram executes a STOP RUN statement, the statement causes the current  Easytrieve 
activity to terminate. When an activity terminates due to a STOP RUN, any spooled reports currently being printed are
terminated. Any unprinted spooled reports are purged, therefore, programs that use FORTRAN service routines cannot
be called.
•Support for Language Environment (LE) takes place through the ENVIRONMENT COBOL parameter.
•The RENT Binder option must also be specified for called COBOL programs compiled with the RENT compiler option.
PL/I Subprogram Linkage
Easytrieve  supports only DYNAMIC calls to PL/I subprograms. Linkage with PL/I is unique due to its non-standard
conventions. It requires the use of the PROC OPTIONS(COBOL) parameter. See the IBM PL/I programming guide for
details on the linkage of PL/I subprograms with other programming languages.
C Subprogram Linkage
Easytrieve  supports both DYNAMIC and STATIC calls to C subprograms. As with COBOL, C subprograms may be
invoked through the CALL statement and as FILE EXITs, and they may be AMODE 24 or 31. C subprograms are invoked
by  Easytrieve  using the same IBM standard calling conventions used for invoking COBOL programs.
The C subprogram coding required to process incoming parameters depends on whether the C subprogram is being
invoked as DYNAMIC or STATIC. The following sections show examples of both.
To Receive Parameters When C Subprogram is DYNAMIC
Easytrieve  main program:
 561 Easytrieve ® Report Generator 11.6
PARM ENVIRONMENT(COBOL)  LINK(EZTPGM R)
DECLARE CPROG PROGRAM DYNAMIC
DEFINE PARM1     W        4   B    VALUE 1111
DEFINE PARM2     W        3   A    VALUE 'ABC'
*
JOB INPUT NULL
DISPLAY '*** BEFORE CPROG CALL ***'
DISPLAY 'PARM1 IS >>-à ' PARM1
DISPLAY 'PARM2 IS >>-à ' PARM2
CALL CPROG USING (PARM1 PARM2)
DISPLAY '*** AFTER CPROG CALL ***'
DISPLAY 'PARM1 IS >>-à ' PARM1
DISPLAY 'PARM2 IS >>-à ' PARM2
STOP
C subprogram (link-edited as CPROG load module):
#pragma runopts (plist(os))  /* required MVS */
#include <csp.h>             /* contains __csplist macro */
void main(void)
{
    int  * parm1_ptr ;  
    char * parm2_ptr ;  
    /* Retrieve the EZT program parameters */   
    parm1_ptr = (int  *) __csplist[ 0 ];  /* 1st parm */    
    parm2_ptr = (char *) __csplist[ 1 ];  /* 2nd parm */    
    /*  Modify the parameter values */  
    *parm1_ptr = 2222;  
    *parm2_ptr = 'Z';   
}
To Receive Parameters When C Subprogram is STATIC
Easytrieve  main program:
This program is exactly the same as the previous main program example except for the following statement:
. . .
DECLARE CPROG PROGRAM STATIC
. . .
C subprogram (statically link-edited with  Easytrieve  program EZTPGM):
#pragma runopts(plist(os))      /* required MVS  */
extern "COBOL"
void CPROG(int parm1, char parm2[3])
{
    /*  Modify the parameter values */  
    parm1    = 2222;    
    parm2[0] = 'Z'; 
}
 562 Easytrieve ® Report Generator 11.6
Parameter Lists
The parameter list for both input/output and CALL exits (pointed to by register 1) passes information to the subprogram.
Each entry in this contiguous group of fullwords identifies one parameter. The end of the list is indicated by the high-order
bit of the high-order byte of the last entry being set to a one.
Parameter List Format
Figure 39: Parameter List Format
The parameter lists passed to subprograms for EXIT (FILE) and CALL are quite similar. In fact, the list for CALL is
identical to that associated with the USING subparameter of EXIT. The only difference is that EXIT always passes at least
two parameters.
Note: If multiple fields are coded on the USING subparameter, and storage areas overlap, results are unpredictable.
Exit Parameter List
You can use the EXIT parameter of the FILE statement to invoke subprograms written in other programming languages
for input/output related events. Code the name of these subprograms on the EXIT parameter of the FILE statement in the
library of your program.
 563 Easytrieve ® Report Generator 11.6
Figure 40: Exit Parameter List
For input/output exits, work area address and the control code address are required parameters. The control code is a
fullword used to indicate the function to be performed by the exit. For instance:
Control Code
Value Function
00000000 input request
00000004 output request
00000008 file close request, or end-of-input (set by input exit subprogram)
For MODIFY exits (subparameter of the FILE statement), the required two parameters are record area address and work
area address because the exit receives all records after input and before output.
 564 Easytrieve ® Report Generator 11.6
Figure 41: MODIFY Exits Parameter List
Parameters coded on the optional USING subparameter of EXIT are appended to the standard two parameters. The
following example shows input/output and MODIFY subprogram parameter list examples:
 565 Easytrieve ® Report Generator 11.6
Figure 42: Examples of Input, Output and MODIFY Subprogram Parameter List
Calling an AMODE(24) Subprogram
When the subprogram being called is link-edited as AMODE(24), and if any parameters are being passed to that program,
those parameters must reside in memory that is located below the 16meg line. Memory location can be controlled at the
installation level and at the program level.
Installation level:
To force all storage below the 16meg line for all  Easytrieve  programs, set the AMODE31 Installation Option to N. For
more information see Execution Options .
 566 Easytrieve ® Report Generator 11.6
Program level:
To force storage below the 16meg line for a specific  Easytrieve  program, you must specify the CALL(AMODE24)
parameter in the PARM statement in the  Easytrieve  program.
Error Condition Handling
Program errors that occur in subprogram exits cause the abnormal termination of  Easytrieve  programs. Because these
errors are occasionally difficult to analyze within the complex environment of  Easytrieve , exits should be tested first with
simulation.
CALL Statement in UNIX, Linux, and Windows
The CALL statement in UNIX, Linux, and Windows provides a means to invoke subprograms written in other programming
languages. The following topics discuss the techniques used with the CALL statement:
•Program linking
•Storage management
•Linkage conventions
•Error condition handling
Storage Management
Called subprograms should use the malloc and free functions to allocate and free storage. The subprogram should free
any storage it has allocated.
Linkage Conventions
The CALL statement can be used to call programs that conform to the C calling conventions for the platform on which you
are running  Easytrieve . For more information, see Using .
FILE EXIT Linkage
You can use the EXIT parameter of the FILE statement to invoke subprograms written in other programming languages
for input/output related events. There are two types of exits you can code:
•Standard
•Using the MODIFY subparameter
Standard Exits
A standard exit should perform its own I/O. A standard exit function should look like this:
unsigned long  YourStandardExit(
      long           eOperation,
      void           * pRecord,
      unsigned long  * pcbRecord,
      void           * pKey,
      unsigned long  * pcbKey,
      P_EZEXIT_FCB   pFCB,
      void           * * pExitArgList
      );
where the meaning of parameters is as follows:
 567 Easytrieve ® Report Generator 11.6
eOperation
Has a value as shown in the following list of constants. These constants enumerate the possible values for
eOperation  and their meaning:
#define IO_OPEN         0   /*   Open the file                 */
#define IO_GET_NEXT_NH  4   /*   GET NEXT NOHOLD               */
#define IO_GET_NEXT_H   6   /*   GET NEXT HOLD                 */
#define IO_GET_PRIOR_NH 10  /*   GET PRIOR NOHOLD              */
#define IO_GET_PRIOR_H  12  /*   GET PRIOR HOLD                */
#define IO_PUT          14  /*   PUT                           */
#define IO_READ_NH      18  /*   READ NOHOLD                   */
#define IO_READ_H       20  /*   READ HOLD                     */
#define IO_WRITE_ADD    22  /*   WRITE ADD                     */
#define IO_WRITE_UPD    24  /*   WRITE UPDATE                  */
#define IO_WRITE_DEL    26  /*   WRITE DELETE                  */
#define IO_POINT_FWD    28  /*   POINT forward                 */
#define IO_RELEASE      30  /*   RELEASE                       */
#define IO_CLOSE        42  /*   CLOSE                         */
#define IO_DISPLAY      48  /*   DISPLAY                       */
#define IO_SYNCPOINT    54  /*   SYNCPOINT                     */
#define IO_POINT_BWD    56  /*   POINT backward                */
pRecord
Is the pointer to the record buffer. On input operations, your exit places data into this buffer from the file. On
output, your exit writes the data from the buffer to the file.
pcbRecord
Is the pointer to the length of the record currently in the buffer. On input operations, your exit must place the size
of the record at this location.
pKey
Is the pointer to the key. This field is valid only for operations that require a key.
pcbKey
Is the pointer to the length of the key.
pFCB
Is the pointer to the EXIT_FCB. The EXIT_FCB contains information describing the file. The EXIT_FCB is
described after the description of the parameters.
pExitArgList
Is the pointer to the array of pointers to the fields in the USING list of the EXIT phrase. The pointers are ordered
as the fields in the USING list are ordered.
Return Value
The following list of constants enumerate the valid return values and the meanings:
#define FC_NORMAL     0     /*   The operation completed           */
                            /*     normally.                       */
#define FC_ENDFILE    4     /*   The operation attempted to        */
                            /*     position the file past the      */
                            /*     last record in the file         */
#define FC_RDUPREC    8     /*   The key of the record just        */
                            /*     read matches the key of the     */
                            /*     next record in the file         */
#define FC_WDUPREC    12    /*   The operation attempted to        */
                            /*     insert a record whose key       */
 568 Easytrieve ® Report Generator 11.6
                            /*     matches a record already in     */
                            /*     the file                        */
#define FC_NRFOUND    16    /*   The key specified for the         */
                            /*     operation does not match        */
                            /*     the key of any record in        */
                            /*     the file                        */
#define FC_LOCKED     20    /*   The operation attempted to        */
                            /*     retrieve a record that is       */
                            /*     locked by another user          */
#define FC_IOERROR    24    /*   The operation failed for some     */
                            /*     reason other than one of        */
                            /*     those given above               */
The ANCHOR is a control block that the exit might want to allocate (it is not required). Its purpose is to hold information
that the exit needs from one invocation of the exit to the next. The ANCHOR is chained off the EXIT_FCB (which follows).
Your exit is responsible for the creation, maintenance, and destruction of this area.
 typedef struct ANCHOR {
      FILE        * pFile;
      /* More data could be placed here.  Since there is no more data
       * in this example, a better solution would be to use the pAnchor
       * field in the EXIT_FCB as the file pointer.
       */
      } ANCHOR, * P_ANCHOR;
The EXIT_FCB is a control block that is passed to the exit each time the exit is called. The same instance of the
EXIT_FCB is passed from the time the file is opened to the time the file is closed for each operation on the file.
Hence, if your exit allocates its own control block (like the ANCHOR, shown below), its address can be placed as the first
item in the EXIT_FCB and retrieved from the same place with each invocation of the exit. Remember to deallocate the
control block when the file is closed.
Easytrieve  creates, maintains, and destroys this control block. Your exit should restrict itself solely to changing the
pAnchor  field.
   typedef struct EZEXIT_FCB {
      P_ANCHOR       pAnchor;             /* for use by the Exit           */
      char           *pszFileName;        /* Pointer to the file name      */
      char           *pszPathName;        /* Pointer to the Path           */
      unsigned long  cbRecordSize;        /* Logical record length         */
      unsigned long  cbBufAreaLen;        /* Length of the buffer area     */
      void           *pBuffer;            /* Pointer to the file buffer    */
      char           szProcessMode[ 4 ];  /* File Access Mode              */
      unsigned char  eRecordFormat;       /* Record format                 */
#        define RF_NONE       0           /*   Record format not specified */
#        define RF_FIXED      1           /*   F or FB specified           */
#        define RF_VARIABLE   2           /*   V, VB, or VSB specified     */
#        define RF_UNDEFINED  3           /*   U specified                 */
      unsigned char  eFileOrg;            /* File type                     */
#        define FO_NONE       0           /*   File type not specified     */
#        define FO_SEQUENTIAL 1           /*   SEQUENTIAL                  */
#        define FO_INDEXED    2           /*   INDEXED                     */
#        define FO_RELATIVE   3           /*   RELATIVE                    */
 569 Easytrieve ® Report Generator 11.6
      unsigned char  fMiscFlags0;         /* Miscellaneous flags           */
#if defined(LSB)
/* For architectures with the Least Significant Byte First
 * such as the INTEL 80x86 chips.
 */
#        define FM_DEFER      0x01        /*   DEFER                       */
#        define FM_ASA        0x02        /*   ASA                         */
#        define FM_CREATE     0x04        /*   CREATE                      */
#        define FM_RESET      0x08        /*   CREATE RESET                */
#        define FM_UPDATE     0x20        /*   UPDATE                      */
#        define FM_NOVERIFY   0x40        /*   NOVERIFY                    */
#        define FM_MODIFY     0x80        /*   EXIT with MODIFY            */
#elif defined(MSB)
/* For architectures with the Most Significant Byte First
 * such as the HP PA Risc (HP 9000) chips.
 */
#        define FM_DEFER      0x80        /*   DEFER                       */
#        define FM_ASA        0x40        /*   ASA                         */
#        define FM_CREATE     0x20        /*   CREATE                      */
#        define FM_RESET      0x10        /*   CREATE RESET                */
#        define FM_UPDATE     0x04        /*   UPDATE                      */
#        define FM_NOVERIFY   0x02        /*   NOVERIFY                    */
#        define FM_MODIFY     0x01        /*   EXIT with MODIFY            */
#  endif
      unsigned char  Reserved1;           /* Reserved for future expansion */
      void           * pReserved2;
      void           * pReserved3;
      void           * pReserved4;
      } EZEXIT_FCB, * P_EZEXIT_FCB;
Note: The Installation Media contains an example of a standard exit program, VRTXTEXT.c. Ask your system
administrator where that program can be found.
MODIFY File Exit
If you code the MODIFY subparameter on the FILE statement,  Easytrieve  performs the I/O. Your exit should examine
the record and convert it into the correct form. On an input operation,  Easytrieve  reads the record, then passes it to your
MODIFY file exit to be reformatted. On an output operation,  Easytrieve  passes the record to your exit to be reformatted.
When your exit finishes,  Easytrieve  writes the reformatted record to the file.
The prototype for your MODIFY file exit should look like this:
unsigned long YRMDEXIT(
      void           * pRecordArea,
      void           * pWorkArea,
      unsigned long  cbRecordLength,
      unsigned long  * pcbWorkAreaLength,
      void           * * pExitArgList
      );
where:
pRecord
Points to the record buffer. The record to be reformatted is in this buffer.
 570 Easytrieve ® Report Generator 11.6
pWorkArea
Points to a buffer. The record from pRecord  must be reformatted and placed in this buffer.
cbRecord
This is the length of the record at pRecord .
pcbWorkArea
Points to the length of pWorkArea 's buffer. When your exit has placed the reformatted in the buffer, it must place
the length of the reformatted record at this field.
pExitArgList
Is the pointer to the array of pointers to the fields in the USING list of the EXIT phrase. The pointers are ordered
as the fields in the USING list are ordered.
Return Value
This exit uses the same values as were defined for the standard file exit.
Note: The Installation Media contains an example of a MODIFY exit program, YRMDEXIT.c. Ask your system
administrator where that program can be found.
If your exit processes variable length records, the RECORD-LENGTH field of the file should be in the USING list. Your exit
must place the correct value in the USING list.
If your exit handles both input and output operations, you should place a field in the USING list that can tell your exit what
type of operation the exit must perform.
Error Condition Handling
Program errors that occur in subprograms cause the abnormal termination of  Easytrieve  programs. Because these errors
can be difficult to analyze in the complex environment of  Easytrieve , you should test subprograms before using them in 
Easytrieve .
LINK Statement
The LINK statement is used to invoke another program and then return execution to the statement following the LINK
statement in the original (invoking) program. The program invoked can be written in any language that is supported by the
operating system in which the program is executing (including  Easytrieve ).
LINK Statement and CALL Statement
The LINK statement differs from the CALL statement in the following ways:
•LINK creates a new program execution environment that bears a child relationship to the program issuing the LINK
command (the parent program). A called program executes in the same execution environment as the program issuing
the CALL command.
•On the mainframe, a called program uses the same linkage conventions in all execution environments; LINK uses the
linkage conventions of the operating system in which the program is executing.
Broadcom  Product References
The child program can issue any command supported by the operating system. In a CICS environment, the program can
issue terminal I/O or display reports, but only in a fully conversational mode.
Commands issued by a child program, such as SYNCPOINT, and I/O commands, can affect the operating environment
of the parent program.  Easytrieve  does not guarantee that applications using LINK execute identically in all execution
environments. If portability between operating systems is required by an application, it is your responsibility to code the
application in such a way that portability is assured.
 571 Easytrieve ® Report Generator 11.6
USING Parameter
A single parameter can be passed to the child program by specifying the USING parameter. The parameter is passed
to the child program by value; that is, the parent program passes a copy of the value of the field or literal to the child
program. The child program cannot directly modify the value of the field or literal. You specify the field to receive the
parameter with the USING parameter on the PROGRAM statement in the child program.
Giving Parameter
You can allow the parent program to accept a return parameter from the child program by specifying the GIVING
parameter. You specify the field to be returned in the GIVING parameter of the PROGRAM statement in the child program.
Easytrieve  returns a value to the parent program by writing the return value into the same parameter area that was used
by  Easytrieve  to pass the USING parameter to the child program.
When the child program terminates, the parameter is copied from the parameter area to the variable specified in the
GIVING parameter of the parent program. Because a single parameter area is used for communications in both directions,
Easytrieve  determines the size of the parameter area by the larger of the fields specified on the USING and GIVING
parameters. If the child program copies a return parameter into the parameter area with the PROGRAM GIVING
parameter, but there is no GIVING parameter specified in the parent program, the returned parameter is ignored without
any error indication.
Operating System Implementation
The LINK statement is implemented as listed below:
Operating System Command Parameters Passed By
CICS EXEC CICS LINK CICS communication area
TSO MVS LINK SVC 6 Standard MVS/TSO linkage conventions
CMS CMS LINK SVC 6 Standard CMS linkage conventions
Non-mainframe (UNIX, Linux, Windows) system ("routine_name using_data")
Note: When linking to an OS/VS COBOL program in TSO or CMS, the COBOL program must be compiled with the
NORES compile option. Also, you cannot LINK and CALL an OS/VS COBOL program in the same activity.
Note: In CICS, the TRANSFER statement is more efficient than the LINK statement. In TSO and CMS, the opposite is
true.
Non-mainframe
The GIVING parameter on the LINK and PROGRAM statements is ignored in non-mainframe environments. The data
from the USING parameter must be acceptable in the shell you are running.
The program being linked to can be any valid shell program or command. For example, you can use LINK 'cls' (in
Windows) or LINK 'clear' (in UNIX) to clear the terminal or console screen for future DISPLAY statements. The following
LINK statement example executes the dir Windows command and redirects the output to a file for future processing:
LINK 'dir' USING '> dir.lst'
The LINK statement, combined with the rest of the  Easytrieve  language, provides powerful scripting possibilities.
TRANSFER Statement
The TRANSFER statement is used to transfer execution to a target program without returning to the invoking program.
The target program can be written in any language that is supported by the operating system in which the program is
executing.
 572 Easytrieve ® Report Generator 11.6
The TRANSFER statement completely terminates the current  Easytrieve  program and invokes a target program using
the linkage conventions of the operating system in which the program is executing. The target program inherits the
execution environment of the program issuing the TRANSFER command.
Commands Issued by the Target Program
The target program can issue any command supported by the operating system. In a CICS environment, the program
can issue terminal I/O or display reports in a pseudo-conversational mode only if the program issuing the TRANSFER
command can operate pseudo-conversationally.
Complete termination of the current  Easytrieve  program does not imply the termination of the current logical unit of work.
Although  Easytrieve  attempts to terminate the current program (for example, close files and complete reports), it does
not necessarily terminate all activities performed by the operating system for the  Easytrieve  program.
Commands issued by a child program, such as SYNCPOINT, and I/O commands can affect the operating environment
of the parent program.  Easytrieve  does not guarantee that applications using TRANSFER execute identically in all
execution environments. If portability between operating systems is required by an application, it is your responsibility to
code the application in such a way that portability is assured.
USING Parameter
A single parameter can be passed to the target program by specifying the USING parameter. The parameter is passed
to the target program by value, that is, the invoking program passes a copy of the value of the field or literal to the target
program. The target program cannot directly modify the value of the field or literal. You specify the field to receive the
parameter with the USING parameter on the PROGRAM statement in the target program.
Operating System Implementations
The TRANSFER statement is implemented as follows:
Operating System Command Parameters Passed By
CICS EXEC CICS XCTL CICS communication area
TSO MVS XCTL SVC 7 Standard MVS/TSO linkage conventions
CMS CMS XCTL SVC 7 andard CMS linkage conventions
Non-mainframe (UNIX, Linux, Windows) execl ("/bin/sh", "routine_name using_data",
NULL)
Note: When running pseudo-conversationally in CICS, you must specify the TRANSID parameter on the PARM statement
in the target program. TRANSID specifies the CICS transaction ID that is invoked when the terminal user presses an
attention key following the program's termination for a pseudo-conversation. The transaction ID of the target program
must be defined in the PCT.
Note: In CICS, the TRANSFER statement is more efficient than the LINK statement. In TSO, CICS, and CMS, the
opposite is true.
Non-mainframe
If you coded a SHELL environment variable,  Easytrieve  uses that path instead of /bin/sh. The data from the USING
parameter must be acceptable in the shell you are running. The program being transferred to can be any valid shell
program or command. Used in this manner, a program could drive the execution of other programs. The TRANSFER
statement, combined with the rest of the  Easytrieve  language, provides powerful scripting possibilities.
Code Efficient Programs
Review coding tips to help you write more efficient  Easytrieve  programs.
 573 Easytrieve ® Report Generator 11.6
Data Usage
Easytrieve  normally generates the most efficient code when performing operations on binary fields (data type B) on the
mainframe.  Easytrieve  performs binary or integer arithmetic whenever possible. When this is impractical due to the size
of intermediate results,  Easytrieve  uses packed decimal.
When you code packed decimal fields, if you use 15 or fewer digits,  Easytrieve  generates inline program code. On the
mainframe, if you use more than 15 digits,  Easytrieve  uses runtime library routines for multiplication and division. The
use of runtime library routines results in a longer execution time of your program.
Avoid the use of zoned numeric fields for heavily used computations in your program.
Use indexes, rather than subscripts, in array processing to produce more efficient code. Although subscripts are easier to
use, they must be internally computed into the index displacements.
When you use subscripts to access arrays, use a two-byte binary field on the mainframe instead of a zoned numeric field
to reduce execution time.
Easytrieve  must convert one of the operands when you perform an operation on fields of different data types. To limit
data conversions, code the fields to be updated or compared as the same type and the same number of decimal places
whenever possible.
In non-mainframe environments, all numeric operations require that the operands be converted to packed. Therefore
packed decimal is the most efficient data type. However, this is subject to change.
Table Processing
Avoid using very large tables, because they take more time to search and require more storage than small tables.
NOTE
Easytrieve  automatically converts a SEARCH of an INDEXED table file into a keyed read when the ARG field is
also the file's key. This results in much faster access and reduced storage requirements.
Compiler Site and Program Options
The FASTSRT mainframe site option allows you to specify whether  Easytrieve  instructs the mainframe sort program to
process all of the I/O whenever possible. If the FASTSRT option is specified at your site, ensure that the sort program can
process extended parameter lists.
The STATE site option and PARM statement parameter saves the statement number of the statement currently being
executed for display during an abnormal termination. This option/parameter requires approximately six to eight bytes of
additional storage for each executable source line in your program.
The FLOW site option and PARM statement parameter activates a trace of statements being executed to be printed
during an abnormal termination. This option and this parameter require a subroutine to be invoked once for each
executable source line.
After you test your program, deactivate the FLOW trace, if possible, to decrease execution time of your program.
The FLDCHK site option and PARM statement parameter validates all data references during program execution. This
option and this parameter generate additional  Easytrieve  code.
After you test your program, deactivate the FLDCHK validation, if possible, to decrease execution time of your program.
The VFM site option and PARM statement parameter specifies the amount of storage available for the Virtual File
Manager (VFM) buffer pool. Additional storage can decrease execution time.
The ABEXIT site option and PARM statement parameter activates the runtime SPIE exit which gets control in order to
produce debugging information in case of an abend in the  Easytrieve  application program. Activating the SPIE exit
requires additional storage and time resources.
 574 Easytrieve ® Report Generator 11.6
Set ABEXIT=NO in the site options, and during development, specify PARM ABEXIT(SNAP) in the  Easytrieve  program.
After you test your program, remove the ABEXIT(SNAP) so the production compilation is done with ABEXIT=NO.
Report Processing
In non-CICS mainframe environments, you can enhance report processing performance by coding the FILE parameter on
the REPORT statement or the WORKFILE parameter of the PARM statement, (or the WORKFILE Option in the Options
Table). Any of these parameters specifies that a dedicated work file is to be used rather than a VFM work file.
Code CICS Programs
Review tips to help you write efficient  Easytrieve  programs in a CICS environment.
•The following site options or PARM statement parameters are ignored under CICS:
–FASTSRT site option
–SSID site option
–SSID PARM statement parameter
•Easytrieve  saves and restores all working storage fields, record I/O buffers, and table file entries across pseudo-
conversations using temporary storage. Limit the number of fields and table entries you use in your program.
•To save on table usage, use INDEXED files, rather than in-stream files, as the subject of searches of large tables.
When an INDEXED file is used as a table, the SEARCH statement results in a random read to the INDEXED file using
the argument as the key.
•You must code the TRANSID parameter of the PARM statement if the program is invoked by another program through
the TRANSFER statement. TRANSID specifies the PCT transaction ID that is invoked after a pseudo-conversation.
•Terminal I/O is done pseudo-conversationally unless COMMIT NOTERMINAL is specified on the activity statement.
For more information about  Easytrieve  commit processing, see the topic Units of Work and Commit Processing on
the page Control Program Flow.
•It is important to remember that commit points and pseudo-conversational terminal I/O can cause the following:
–VSAM file browses on non-unique paths are terminated.
–File holds are released.
–SQL cursors are closed and data is committed.
–Called subroutines are deleted and reloaded.
–IDMS  run units are terminated.
–DLI PSBs are terminated.
•You must code your programs carefully. For example, when browsing an SQL file, you must reposition browses after a
pseudo-conversation.
•Printer spool files are closed during each commit point, including pseudo-conversations.
Multiple Platform Considerations
Review how  Easytrieve  works on different platforms and tips for migrating programs to non-mainframe environments or
when you have source that can run on multiple platforms.
•If your program relies on a specific collating sequence, you should review this code when moving platforms. For
example, you have to account for numeric values being higher than alphabetic values in EBCDIC but lower in ASCII.
INSTREAM tables, in particular, must be in proper order for the system you are compiling on. You may want to
consider converting these into external tables, which can be sorted for the specific platform.
•As you port files from one platform to another, you must address the manner that you use to transfer the files. You
should be aware that Easytrieve  uses ASCII or EBCDIC as appropriate for the environment in which it runs. Be careful
when you migrate your files to convert only the alphanumeric fields without corrupting numeric data. Fixed sequential
 575 Easytrieve ® Report Generator 11.6
files on the mainframe may become line-feed delimited files on other platforms, and therefore are required to be
handled as variable files. For more information, see File Processing .
•The CONVAE/CONVEA toolkit macros can be used to convert alphanumeric fields between ASCII and EBCDIC. The
Workbench in Easytrieve  for Windows includes a data conversion utility that can convert a file automatically, based on
a macro containing that file’s field definitions.
•On distributed platforms, macros must be stored with an extension of .mac.
•Be aware that UNIX is case-sensitive and that %TEST will cause the compiler to look for TEST.mac, not test.mac.
•Mainframe FILE statements often get their attributes (record formats and record length) from JCL or from opening
an existing file. You may want to add the attributes to the FILE statement or you may want to get the attributes
dynamically through a file description string. For details, see the Execute a Program  section.
•Be aware that the "I" data format is for integers of the native data format of the host environment you are executing
on. Your code should not expect specific hexadecimal values and still be considered portable because integers are not
stored identically on all platforms.
•You may find it useful for your code to test for the underlying code system when writing programs to be portable. A
simple method is to execute the following code that determines if execution is using an EBCDIC based system or not:
DEFINE TESTBYTE S 1 A VALUE 'A'  
IF TESTBYTE = X'C1'  
 ...
You can use this code example to dynamically  set a FILE statement SYSNAME value so it can be a DDname on a
mainframe or a pathname on a PC.
SQL Database Processing
Easytrieve  provides optional processing facilities for SQL databases. Review this topic to see which SQL databases are
supported.
•IBM Db2, versions 9, 10, 11 and 12
•IBM's Db2 for AIX, version 2.1 and greater
•IBM's SQL/DS, version 2.2 and greater
•Datacom/DB  with SQL, version 8.0 and greater
•IDMS , version 12.0 and greater
•Oracle, mainframe, version 10g and greater
•Oracle, HP-UX and AIX, version 7.1 and greater
•Ingres, HP-UX and AIX, version 6.4 and greater
•OpenIngres, HP-UX, and AIX, version 1.0 and greater
•ODBC, version 3.0 and greater
Mainframe users:
•Before Easytrieve  can process these databases, the Pan/SQL  Interface product, version 2.4, must be correctly
installed. To process an Oracle database, Pan/SQL  version 2.5 must be installed. For complete information, see the
Pan/SQL  Getting Started Guide , available from Bookshelves and PDFs .
Non-mainframe users:
•All SQL Interface functionality is installed with Easytrieve . No additional installation or documentation is required.
To use these facilities effectively, you should have a basic knowledge of SQL and the database management system to be
processed.
 576 Easytrieve ® Report Generator 11.6
Programming Methods
Review supported programming methods for processing SQL databases in  Easytrieve  To use these methods, you can
use native SQL statements, or allow  Easytrieve  to automatically manage the SQL cursor.
The supported programming methods for processing SQL databases are:
•Use native SQL statements to manually manage the SQL cursor.
•Let Easytrieve  automatically manage the SQL cursor.
Native SQL Statements
Easytrieve  supports most of the SQL statements available for a given DBMS. The exceptions are those statements that
are compiler directives and statements that cannot be dynamically prepared. Using these native SQL statements, you can
code fully SQL-compliant programs in which you control the SQL cursor operation. All native SQL statements are prefixed
with the SQL keyword. For complete syntax, see the Language Reference  section.
For SQL commands, see the following sections:
•Supported SQL Commands
•Unsupported SQL Commands
Automatic Cursor Management
Easytrieve  can automatically manage the SQL cursor in the following ways:
•Easytrieve  files
•Automatic retrieval without a file
Easytrieve  Files
Easytrieve  can automate SQL cursor management when you associate an SQL cursor with an  Easytrieve  file. The SQL
file can then be accessed in two ways:
•JOB INPUT statement -- With each iteration of the JOB statement or activity, another row from the table is
automatically retrieved into the file's data area. Even if you have only a basic knowledge of SQL, you can report on
data that is contained in an SQL database.
•Easytrieve  SQL-like statements -- Use the following statements to read and write SQL data on a controlled basis:
–CLOSE
–DELETE
–FETCH
–INSERT
–SELECT
–UPDATE
Automatic Retrieval Without a File
In this read-only method, you must code SQL on the JOB statement in place of a file name. You must code a SELECT
statement directly after the JOB statement to specify the columns to be retrieved and the host variables to receive the
data. Each time the JOB activity is iterated, another row of SQL data is retrieved. This is a simple way to retrieve SQL
data into working storage or into an extract file for subsequent output. Automatic retrieval does not require that you define
an Easytrieve  file.
 577 Easytrieve ® Report Generator 11.6
 Easytrieve  SQL Statement Rules
Review syntax rules that apply when you code SQL control statements in Easytrieve .
•Operators must be separated by blanks.
•Standard Easytrieve  continuation conventions are followed.
•Commas are not ignored.
•The period is used as a qualification separator, not to signify end-of-statement.
•The colon is used to identify host/indicator variables, not as a qualification separator.
•An SQL statement cannot be followed by another statement on the same source record.
Program Environment
Easytrieve  processes SQL statements using the Pan/SQL  interface on the mainframe and internal interfaces in non-
mainframe environments. Review the specific implementation for supported databases including DB2, SQL/DS, Datacom/
DB SQL, IDMS SQL, and non-mainframe Ingres, DB2, ODBC,and Oracle SQL interfaces.
The following list describes the specific implementation for each supported database:
•For mainframe DB2, both a dynamic interface and a static interface are supported.
•For SQL/DS, extended dynamic SQL is supported. SQL statements are dynamically prepared during the compilation
of your  Easytrieve  program and an access module or package is created. At runtime, SQL statements are executed
from the access module or package.
•The Datacom/DB  SQL interface is similar to the SQL/DS interface. An access plan, from which SQL statements are
executed, is created at compile time.
•The IDMS  SQL interface is strictly a dynamic interface for both compilation and execution.
•The non-mainframe Ingres, DB2, ODBC, and Oracle SQL interfaces are strictly dynamic interfaces for both compilation
and execution.
See Unsupported SQL Commands  for a list of commands that cannot be coded in  Easytrieve  programs.
Units of Work
Each  Easytrieve  activity is considered a separate SQL unit of work or transaction. If COMMIT TERMINAL is specified
on the activity statement, a commit is automatically executed during terminal I/O. If COMMIT ACTIVITY is specified in the
activity, a commit is also executed following the termination of the activity. If  Easytrieve  detects an error condition or if
you code a STOP EXECUTE statement in your program, a ROLLBACK statement is automatically executed.
You can issue your own COMMIT and ROLLBACK statements to signal the successful or unsuccessful end of the
transaction. These COMMIT and ROLLBACK statements are performed in addition to the ones  Easytrieve  does
automatically.
Each time a COMMIT or ROLLBACK statement is executed, all open SQL cursors are closed. Exceptions may exist for
specific databases that maintain cursor positioning across commits or syncpoints.
Support for Multiple SSIDs with Pan/SQL  Feature
Easytrieve  invokes a specific DB2 PAN/SQL installation from among multiple installations based on the value that is
specified for PARM SSID in the  Easytrieve  program. With this feature, if you have multiple versions of DB2 installed, you
can have multiple Pan/SQL  installations for each DB2 within a single library, and select the DB2 you want to access by
using the PARM SSID value in the  Easytrieve  program. This is done by building the  Easytrieve  SSID Table which is a
cross-reference table that assigns a specific PAN/SQL installation with a DB2 SSID. The CBAAJCL member SSIDTBL is
used to build the table. Information about how to create multiple PAN/SQL for DB2 installations in the same load library is
provided with PAN/SQL.
 578 Easytrieve ® Report Generator 11.6
PARM Statement Parameters
The PARM statement parameters set the SQL environment for the program.
SQLSYNTAX
In all environments, use the SQLSYNTAX parameter to specify the level of SQL syntax checking to perform on the SQL
statements in your program. SQLSYNTAX FULL specifies that SQL statements undergo detail-level syntax checking. An
SQL PREPARE statement is executed for those SQL statements that can be dynamically prepared. Your DBMS must be
available to  Easytrieve . SQLSYNTAX PARTIAL indicates that your SQL statements are checked for valid commands
and secondary keywords. No connection is made to your DBMS unless you have an SQL INCLUDE statement in your
program. Your program does not execute until it has undergone FULL syntax checking.
If you want syntax checking to be performed by the DB2 preprocessor in a batch environment, you can use the
SQLSYNTAX NONE parameter on the PARM statement with a static bind. An option of NONE causes your program to
undergo partial syntax checking. Your program continues execution if no partial-level compile errors are found, a BIND
option of STATIC-ONLY is specified, and no other non-SQL syntax errors are found.
DB2
The SQLID parameter of the PARM statement results in the execution of the SQL SET CURRENT SQLID command by
the SQL Interface at compile time. The SQL SET CURRENT SQLID command is executed at runtime for controlled or
automatic processing. Execution of the SQL SET CURRENT SQLID command is valid for sites that have an external
security package that supports group IDs. The SQLID parameter applies to mainframe only.
The SSID parameter of the PARM statement can be used to specify the desired DB2 subsystem in non-CICS
environments. If the SSID parameter is not coded, the SQL interface gets the DB2 subsystem ID from the DB2 system
default module DSNHDECP. DSNHDECP is made available through the JOBLIB or steplib libraries. In CICS, the currently
attached subsystem is used. In non-mainframe environments, the SSID identifies the database to be connected.
Static SQL is used to improve the performance of an SQL program. In a static SQL program, all SQL statements are
known ahead of time and an optimized plan is created prior to execution time.
Static SQL is specified by two parameters on the PARM statement. PLAN specifies the name of the DB2 static-command-
program and its plan name. The command program can either be linked with the  Easytrieve  program or linked as a
separate load module. A BIND parameter of STATIC-ONLY or ANY causes the static-command-program to be generated.
The PLAN and BIND parameters apply to mainframe only.
To run your program statically, you must run special steps to create and link the static command program and plan. For
more information, see Program Compilation and Link-Editing Using JCL .
Dynamic SQL is used to process your program when running under the interpreter, regardless of the BIND parameter
specified.
Static SQL and the LINK Statement
When you execute multiple static SQL programs in a given transaction or task, you must bind all of the involved DBRMs
into a single plan. Therefore, specify the same plan name for the PLAN parameter of each application program.
PAN$SQL DD File
You can code a PAN$SQL DD statement to provide a plan name and DB2 for z/OS subsystem to be used at the time of
your execution. The  PAN$SQL DD file is processed only when executing statically and if the DB2 for z/OS Call Attach
Facility is used to establish a  connection. The PAN$SQL file can also be used to indicate that you want to execute
under the TSO Terminal Monitor Program in background mode. If TSO execution is specified, then the plan name and
subsystem ID  parameters are ignored. Valid parameters for the PAN$SQL file are the following:
 579 Easytrieve ® Report Generator 11.6
•PLAN—provide the name of the DB2 for z/OS plan to use for execution.
•SSID—provide the name of the DB2 for z/OS subsystem to use for the DB2 for z/OS Call Attach Facility for a
connection.
•TSO—indicates that you want to execute your  Easytrieve  program under the TSO Terminal Monitor Program in
background mode. You must code the correct JCL.
The following is sample JCL for the PAN$SQL statement:
      //PAN$SQL DD *
         PLAN=TESTPLAN,SSID=D810
The ability to specify a plan name for execution enables you to compile and link your  Easytrieve  DB2 for z/OS application
program once. The DBRM can then be bound into any DB2 for z/OS subsystem with any planname.
Execution under TSO resolves the problem of called DB2 for z/OS subroutines that previously had to be linked with
DSNALI, the DB2 for z/OS Call Attach Facility module. This restriction required subroutines to be linked one way for other
applications.
If your  Easytrieve  program contains SQL statements and it also calls COBOL (or other language) subroutines, you can
now share those subroutines with  Easytrieve  applications and other applications.
You can link your COBOL subroutines once with DSNELI and it can be used by all your applications.
Sample JCL for Execution Under TSO:
//EXECEZT EXEC PGM=IKJEFT01,DYNAMNBR=20
//STEPLIB DD DISP=SHR,DSN=your.ezt.target.library
//        DD DISP=SHR,DSN=your.ezt.db2.application.library
//        DD DISP=SHR,DSN=your.pansql.tso.load.library
//        DD DISP=SHR,DSN=your.db2.sdsnload.library
//PAN$SQL DD *
   TSO                       <=== Indicate TSO execution
//SYSPRINT DD SYSOUT=*
//SYSTSPRT DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//SYSOUT DD SYSOUT=*
//REPORT DD SYSOUT=*
//SYSIN DD DUMMY
//SYSTSIN DD *
   DSN SYSTEM(D810)
   RUN PROGRAM(eztpgm) PLAN(testplan)
   END
/*
Qualifying DB2 for z/OS Tables
Unqualified tables are implicitly qualified by the primary authorization ID of the program. This ID is usually established by
the USER parameter of your JCL JOB statement. You can modify qualification in one of three ways:
•SQLID keyword on the  Easytrieve  PARM statement
•SQL SET CURRENT SQLID command
•OWNER or QUALIFIER parameter on the DB2 for z/OS BIND statement
Use of the SQLID and its effect on table qualification depends on whether automatic or controlled processing is performed
and whether static or dynamic SQL is used.
 580 Easytrieve ® Report Generator 11.6
To eliminate the authorization problems that are encountered with the use of SQLID, use SQLSYNTAX NONE with BIND
STATIC-ONLY. These parameters enable the use of unqualified table names and bypass the dynamic prepare of SQL
statements. Unqualified table names can then be qualified by the BIND process.
SQL/DS
Specify the SQL/DS user ID to be used for compiling the program on the USERID parameter of the PARM statement. At
execution time, a CONNECT is executed by  Easytrieve  for automatic processing only. For controlled processing, you
must code the SQL CONNECT command providing the values for an sqlid and password.
Specify the name of the SQL/DS access module for this program on the PREPNAME parameter of the PARM statement.
When an SQL program is compiled, an access module is created or replaced. To avoid using the default name, use
unique access module names for each application program. In a high volume system, using the default PREPNAME can
result in catalog contention and a -911 SQLCODE resulting from a rollback.
Datacom/DB
Use the PLANOPTS parameter on the PARM statement to specify the name of a Pan/SQL  PLAN options module to
override the default module (DQSMPLN@). For more information about defining your own options module, see the Pan/
SQL Interface Getting Started 2.4C , available from Bookshelves and PDFs .
IDMS
Use the USERID parameter to specify the name of the IDMS dictionary to be used for explicit connect (no password is
needed).
If no dictionary name is provided, an implicit connection is attempted when the first SQL statement is processed. The
dictionary name is then obtained from the SYSCTL DD card provided in your JCL.
Ingres
Use the SSID parameter on the PARM statement to specify the name of the database to which this session connects.
Use the USERID parameter on the PARM statement to specify the user identifier under which this session runs. The
password subparameter is ignored.
ORACLE
Use the USERID parameter of the PARM statement to specify the ORACLE user ID for compiling the program. At
execution time,  Easytrieve  executes a CONNECT for automatic processing only. For controlled processing, you must
code the SQL CONNECT command, providing the values for an sqlid and password.
Language Environment is required for Oracle execution. The  Easytrieve  program that accesses an Oracle database
must run as an LE application. Therefore, PARM ENVIRONMENT(COBOL) is unconditionally activated for programs that
access Oracle.
ODBC
Use the SSID parameter on the PARM statement to specify the name of the data source to which this session connects.
In Windows, a connection dialog box is displayed if no SSID is provided.
Use the USERID parameter of the PARM statement to specify a user ID for compiling the program. At execution time, 
Easytrieve  executes a CONNECT for automatic processing only. For controlled processing, you must code the SQL
CONNECT command, providing the values for a data source, user ID, and password.
 581 Easytrieve ® Report Generator 11.6
Library Section Definition
In  Easytrieve , before SQL data can be accessed, define the fields to hold the columns to be retrieved. These fields
are known as host variables. Review the SQL Catalog INCLUDE Facility, processing Nullable Fields, SQL Data Types,
System-Defined File Fields, EOF Processing, and SQL Communications Area Fields.
If you are using native SQL commands or using automatic retrieval without a file, you usually define the fields as working
storage fields. Alternatively, you can define the fields within an active output file. This is an effective method to select SQL
data into a sequential file for extraction purposes. You must specify which columns are to be retrieved and which host
variables are to receive the data.
When using an Easytrieve  file, however, fields defined within the file correspond to the selected columns of the SQL table.
The table columns are retrieved into the file fields.
This article contains the following information:
SQL Catalog INCLUDE Facility
You can use the SQL catalog INCLUDE facility to automatically generate Easytrieve  field definitions directly from the SQL
catalog. This eliminates the need to code host variable definitions in the library section of your program. You may wish to
add redefinitions of the generated fields. For example, you may wish to code field segments for large alphanumeric fields
that will not fit on a single print line or you may wish to add MASKs to your redefinition.
The SQL INCLUDE statement names the SQL table or view from which column names and data types are obtained, and
defines the location at which the field definitions are generated.
The SQL INCLUDE statement must precede any other SQL or SELECT statements and must be coded in the library
section of your Easytrieve  program.
Note: To use the SQL catalog INCLUDE facility for ORACLE, your database administrator must have installed the catalog
views ( catalog.sql ).
Processing Nullable Fields
Easytrieve  supports the SQL concept of a null data value. Null is a value that denotes the absence of a known value for a
field. Specify the keyword NULLABLE on the SQL INCLUDE statement to generate the null indicator variables. Easytrieve
does the rest of the processing for you when processing the SQL table as a file.
When a field is defined as nullable, you can use special processing statements:
•IF NULL can be used to determine if the field contains a null value.
•MOVE NULL can be used to set a field's value to null.
Manual NULL Processing
When you use native SQL statements or automatic retrieval without a file, you define null values differently. You define an
indicator variable as a two-byte quantitative binary field (2 B 0). This indicator variable is then used in the INTO clause of
the native or automatic SELECT statement. SQL returns a negative value to the indicator variable when the field's value is
null. See the native SQL examples for the use of manual indicator values.
Note: Datacom/DB  uses I type fields as indicator variables. You can code B or I data types as indicator variables,
however, if you code B type data, conversion is performed whenever the database is accessed.
SQL Data Types
The following tables illustrate SQL data types and corresponding Easytrieve  field definitions. SQL provides some data
conversion in SQL assignments and comparisons. For more information about SQL data conversions, see your SQL
manuals. See the corresponding notes after the tables for asterisked items in the tables.
 582 Easytrieve ® Report Generator 11.6
The first table includes DB2, SQL/DS, Datacom/DB , and ODBC databases.
SQL Easytrieve DB2, SQL/DS Datacom/DB  SQL ODBC
BIGINT 8 B 0
8 I 0Y N N
INTEGER 4 B 0
4 I 0Y Y Y
SMALL INTEGER 2 B 0
2 I 0Y Y Y
DECIMAL (x,y) x P y Y Y Y
UNSIGNED DECIMAL
(x,y)x P y N N N
CHARACTER (x) x A Y Y Y
VARCHAR (x) x A VARYING
(x <= 254)Y Y (8.1) Y
TEXT (x) x A VARYING N N N
LONG VARCHAR (x) x A VARYING
(x > 254)Y Y (8.1) Y
VARCHAR2 (x) x A VARYING N N Y
RAW x A VARYING N N N
LONG RAW (x) x A VARYING N N N
NUMERIC (x,y) x N y N Y Y
UNSIGNED NUMERIC
(x,y)x N y N N N
FLOAT 10 P 3 Y Y Y
REAL 10 P 3 Y Y Y
DOUBLE PRECISION 10 P 3 Y Y Y
NUMBER x P y N N N
MONEY 10 P 2 N N N
GRAPHIC (x) x M
x KY N N
VARGRAPHIC (x) x M VARYING
x K VARYING
(x <= 254)Y N N
LONG VARGRAPHIC (x)x M VARYING
x K VARYING
(x > 254)Y N N
DATE 10 A *2 Y Y Y
TIME 8 A Y Y Y
TIMESTAMP 26 A Y Y Y
BINARY x B y *1 N N N
none x U y - - -
 583 Easytrieve ® Report Generator 11.6
The next table includes IDMS , Ingres, and Oracle databases:
SQL Easytrieve IDMS  SQL Ingres Oracle
INTEGER 4 B 0
4 I 0Y Y N
SMALL INTEGER 2 B 0
2 I 0Y Y N
DECIMAL (x,y) x P y Y N N
UNSIGNED DECIMAL
(x,y)x P y Y N N
CHARACTER (x) x A Y Y Y
VARCHAR (x) x A VARYING
(x <= 254)Y Y Y
TEXT (x) x A VARYING N Y N
LONG VARCHAR (x) x A VARYING
(x > 254)Y N N
VARCHAR2 (x) x A VARYING N N Y
RAW (x) x A VARYING N N Y
LONG RAW (x) x A VARYING N N Y
NUMERIC (x,y) x N y Y N N
UNSIGNED NUMERIC
(x,y)x N y Y N N
FLOAT 10 P 3 Y Y Y
REAL 10 P 3 Y N N
DOUBLE PRECISION 10 P 3 Y N N
NUMBER (x,y) x P y *3 N N Y
MONEY 10 P 2 N Y N
GRAPHIC (x) x M
x KY N N
VARGRAPHIC (x) x M VARYING
x K VARYING
(x < = 254)Y N N
LONG VARGRAPHIC (x)x M VARYING
x K VARYING
(x > 254)Y N N
DATE 10 A *2 Y Y Y
TIME 8 A Y N N
TIMESTAMP 26 A Y N N
BINARY x B y *1 Y N N
none x U y - - -
Note 1: The data type of BINARY is invalid for lengths other than 2, 4, or 8. When processing an SQL INCLUDE
statement on the mainframe, this data type is converted to x A.
Note 2: For Ingres, dates are 11 bytes in length.
 584 Easytrieve ® Report Generator 11.6
Note 3: Maximum length = 10 bytes.
Decimal Data Types
For SQL DECIMAL data types, the scale is the same as the decimal places of an  Easytrieve  field. SQL precision
refers to the total number of digits that can occur in the packed field. An  Easytrieve  length refers to the number of
bytes occupied by the packed field. An  Easytrieve  field that is 5 P 2 is the equivalent of an SQL DECIMAL data type of
precision = 9 and scale = 2. Depending on your SQL release, SQL may not support  Easytrieve  packed fields with lengths
> 8.
SQL Syntax Checking
When an SQL statement is passed to SQL for syntax checking, host variables are converted to question marks (?) by
the product. It is possible that when an SQL error is detected, the question mark is identified as the field in error. In this
case, you are responsible for looking up the error message and identifying which host variable is in error. Because host
variables are replaced with question marks, their use in arithmetic expressions may result in compile errors. For DB2 and
SQL/DS, an SQLCODE of -418 can occur.
System-Defined File Fields
When using an Easytrieve  file to process an SQL database, the following system-defined fields are used:
RECORD-COUNT
RECORD-COUNT contains the number of rows returned to the Easytrieve  program. This is the number of rows fetched by
either automatic or controlled processing.
RECORD-LENGTH
RECORD-LENGTH is the length of the SQL file. The length is the sum of the maximum lengths of all fields in the file.
EOF Processing
When the end of the tables has been reached, either with automatic (JOB) or controlled (FETCH) processing, the file is
marked EOF (end of file). In automatic processing, execution stops, and the FINISH procedure (if present) executes. In
controlled processing, you can code file presence tests (IF EOF  file-name ) to determine whether an end of file condition
exists.
SQL Communications Area Fields
All of the SQL Communication Area fields (SQLCA) are automatically created in S (static) working storage when any of
the following occurs:
•The first SQL-managed file is encountered.
•The first SQL INCLUDE statement is encountered.
•The first native or controlled SQL statement is found.
•The first JOB INPUT SQL statement is found.
The fields generated for SQLCA for the supported SQL database management systems are shown in the following lists.
SQL Communication Area Fields for DB2, SQL/DS, Ingres, ODBC, and ORACLE
 DEFINE SQLCA       S           136  A                              
 DEFINE SQLCAID     SQLCA         8  A                              
 DEFINE SQLCABC     SQLCA +8      4  B 0                            
 585 Easytrieve ® Report Generator 11.6
 DEFINE SQLCODE     SQLCA +12     4  B 0                            
 DEFINE SQLERRM     SQLCA +16    72  A                              
 DEFINE SQLERRML    SQLCA +16     2  B 0                            
 DEFINE SQLERRMC    SQLCA +18    70  A                              
 DEFINE SQLERRP     SQLCA +88     8  A                              
 DEFINE SQLERRD     SQLCA +96     4  B 0 OCCURS 6 
 DEFINE SQLWARN     SQLCA +120    8  A   
 DEFINE SQLWARN0    SQLCA +120    1  A                              
 DEFINE SQLWARN1    SQLCA +121    1  A                        
 DEFINE SQLWARN2    SQLCA +122    1  A                              
 DEFINE SQLWARN3    SQLCA +123    1  A                              
 DEFINE SQLWARN4    SQLCA +124    1  A                              
 DEFINE SQLWARN5    SQLCA +125    1  A                              
 DEFINE SQLWARN6    SQLCA +126    1  A                              
 DEFINE SQLWARN7    SQLCA +127    1  A                              
 DEFINE SQLWARN8    SQLCA +128    1  A                              
 DEFINE SQLWARN9    SQLCA +129    1  A                              
 DEFINE SQLWARNA    SQLCA +130    1  A                              
 DEFINE SQLEXT      SQLCA +131    5  A                              
 DEFINE SQLSTATE    SQLCA +131    5  A
SQL Communication Area Fields for Datacom/DB
 SQLCA               S           196  A                             
 SQLCA-EYE-CATCH     SQLCA         8  A                             
 SQLCAID             SQLCA         8  A                             
 SQLCA-LEN           SQLCA +8      4  B 0                           
 SQLCABC             SQLCA +8      4  B 0                           
 SQLCA-DB-VRS        SQLCA +12     2  A                             
 SQLCA-DB-RLS        SQLCA +14     2  A                             
 SQLCA-LUWID         SQLCA +16     8  A                             
 SQLCODE             SQLCA +24     4  B 0                           
 SQLCA-ERROR-INFO    SQLCA +28    82  A                             
 SQLCA-ERR-LEN       SQLCA +28     2  B 0   
 SQLCA-ERR-MSG       SQLCA +30    80  A                             
 SQLERRM             SQLCA +28    72  A                             
 SQLERRML            SQLCA +28     2  B 0         
 SQLERRMC            SQLCA +30    70  A                             
 SQLCA-ERROR-PGM     SQLCA +110    8  A                             
 SQLERRP             SQLCA +110    8  A  
 SQLCA-FILLER-1      SQLCA +118    2  A                             
 SQLCA-ERROR-DATA    SQLCA +120   24  A                             
 SQLCA-DSFCODE       SQLCA +120    4  A                             
 SQLCA-INFCODE       SQLCA +124    4  B 0   
 SQLCA-DBCODE        SQLCA +128    4  A                             
 SQLCA-DBCODE-EXT    SQLCA +128    2  A                             
 SQLCA-DBCODE-INT    SQLCA +130    2  B 0 
 SQLCA-MISC-CODE1    SQLCA +132    4  A                             
 SQLCA-MISC-CODE2    SQLCA +136    4  B 0   
 SQLCA-MISC-CODE3    SQLCA +140    4  A                             
 SQLCA-WRN-AREA      SQLCA +144    8  A                             
 SQLCA-WARNING       SQLCA +144    1  A       OCCURS 8       
 SQLWARN             SQLCA +144    8  A                             
 586 Easytrieve ® Report Generator 11.6
 SQLWARN0            SQLCA +144    1  A                             
 SQLWARN1            SQLCA +145    1  A                             
 SQLWARN2            SQLCA +146    1  A   
 SQLWARN3            SQLCA +147    1  A                             
 SQLWARN4            SQLCA +148    1  A                             
 SQLWARN5            SQLCA +149    1  A      
 SQLWARN6            SQLCA +150    1  A                             
 SQLWARN7            SQLCA +151    1  A                             
 SQLCA-PGM-NAME      SQLCA +152    8  A                             
 SQLCA-AUTHID        SQLCA +160   18  A                             
 SQLCA-PLAN-NAME     SQLCA +178   18  A   
SQL Communication Area Fields for IDMS
 SQLCA          S             344  A                           
 SQLCAID        SQLCA         8    A                           
 SQLCODE        SQLCA +8      4    B 0                         
 SQLCSID        SQLCA +12     4    B 0   OCCURS 2              
 SQLCERC        SQLCA +20     4    B 0                         
 SQLCNRP        SQLCA +28     4    B 0          
 SQLCSER        SQLCA +36     4    B 0                         
 SQLCLNO        SQLCA +44     4    B 0                         
 SQLCMCT        SQLCA +48     4    B 0                         
 SQLCOPTS       SQLCA +52     4    B 0                         
 SQLCFJB        SQLCA +56     4    B 0                         
 SQLCPCID       SQLCA +60     4    B 0                         
 SQLCLCID       SQLCA +64     4    B 0                         
 SQLCERL        SQLCA +68     2    B 0                         
 SQLCERM        SQLCA +72     256  A                           
 SQLSTATE       SQLCA +328    5    A                           
NOTE
When the  Easytrieve  client is using ODBC, only the following SQLCA variables are set.
For all SQL statements:
•SQLCODE
For all SQL statements when an error occurs:
•SQLMESG
•SQLERRM
•SQLERRMC
•SQLERRML
•SQLEXT
•SQLSTATE
Upon successful execution of INSERT, UPDATE, and DELETE statements:
•SQLERRD(3)
Because the ODBC standard does not provide an interface to read SQLCA values, all other SQLCA variables
are empty.
For more information about SQLCA, go to https://www.ibm.com/support/knowledgecenter/ and search for
SQLCA (SQL communications area) Db2.
 587 Easytrieve ® Report Generator 11.6
Sample Database
The following two tables are used for all the examples in this section.
    TABLE:    PERSONNEL                                              
              ------------------------------------------
    COLUMNS:  EMPNAME             WORKDEPT   EMPPHONE              
              ------------------------------------------
    DATA:     NORIDGE DEBBIE        901        5001                  
              OSMON   SAMUEL        901        5004                  
              MILLER  JOAN          950        6034                  
              EPERT   LINDA         950        null                  
              STRIDE  ANN           901        null                  
              ROGERS  PAT           921        2231                  
                                                                     
    EMPNAME       -  CHAR(20) (NOT NULL)                             
    WORKDEPT      -  DECIMAL(3,0) (NOT NULL)                         
    EMPPHONE      -  DECIMAL(5,0) (NULL)                             
.....................................................
    TABLE:    DEPARTMENTS                                            
              ------------------------------
    COLUMNS:  DEPTNAME           DEPTNUMBER                         
              ------------------------------
    DATA:     SHIPPING           901                                
              HUMAN RESOURCES    921                                
              ACCOUNTING         950                                
              DATA PROCESSING    951                                
                                                                    
    DEPTNAME      -   VARCHAR(20) (NOT NULL)                        
    DEPTNUMBER    -   DECIMAL(3,0) (NOT NULL)                       
                                                                     
    WORKDEPT in the PERSONNEL table corresponds with                
    the DEPTNUMBER in the DEPARTMENTS table.                        
Working Storage Definitions
This code shows working storage field definitions for the two sample tables:
DEFINE EMPNAME    W 20 A                                           
DEFINE WORKDEPT   W  2 P 0                                         
DEFINE EMPPHONE   W  3 P 0                                         
DEFINE DEPTNAME   W 22 A    VARYING                                
DEFINE DEPTNUMBER W  2 P 0                                         
DEFINE NULLPHONE  W  2 B 0 .* NULL INDICATOR                       
DEFINE USERID     W  8 A   VALUE('SQLDBA')    .* SQL/DS USERID     
DEFINE PASSWORD   W  8 A   VALUE('SQLDBAPW')  .* SQL/DS PASSWORD   
 Easytrieve  SQL Files
In this method of processing SQL, Easytrieve  automates cursor management by associating an SQL cursor with an
Easytrieve file. Review processing requirements, operation, input processing, and update processing.
 588 Easytrieve ® Report Generator 11.6
Processing Requirements
To process data from an SQL table using this method, you must code the following items:
•A FILE statement that specifies one or more table names
•If all columns defined in the file are subject to update, specify the UPDATE keyword on the FILE statement.
•One or more field definitions for the columns within the tables that you want to retrieve
You can code these definitions by using the DEFINE statement or by using the SQL INCLUDE statement to
automatically generate the definitions from the SQL catalog. If you want to selectively update only a few columns of
those defined within the file, omit the UPDATE keyword from the FILE statement and specify UPDATE only on the
field definitions (columns) you want to update. Coding UPDATE on the SQL INCLUDE statement causes generated
definitions to be subject to update.
•A SELECT statement that defines the result set for the cursor
If you do not use a SELECT statement, Easytrieve  generates a default SELECT to retrieve all rows for the tables. You
can override this default by specifying your own file-based SELECT statement as the first statement following the JOB
statement.
Overriding the default SELECT allows you to use SQL techniques to customize the result set for the cursor. For
example, you can:
–Limit the result set to a subset of records (WHERE)
–Organize the data in the table by groups (GROUP BY)
–Limit the groups returned (HAVING)
–Sequence the returning records (ORDER BY)
In addition to overriding the default SELECT, you can code one or more SELECTs anywhere in your JOB activity. This
lets you use conditional logic to dynamically determine which SELECT is executed.
A SELECT statement for an SQL file is similar to opening the file. Selecting a file that is already open first closes the
file and then reopens the file based on the new SELECT statement.
NOTE
For more information about SELECT statement usage, see the Language Reference  section.
Operation
If you are executing in an SQL/DS, Advantage Ingres, non-mainframe DB2, ODBC, or ORACLE system, Easytrieve
generates and executes a CONNECT statement. You need not code an SQL CONNECT statement when using
Easytrieve  automatic processing. The user ID and password parameters are taken from those specified in the USERID
parameter of the PARM statement.
Easytrieve  checks the SQLCODE field following each execution of a file-based SQL statement. If the SQLCODE indicates
an error, Easytrieve  issues an error message based on the SQL error and terminates execution. During automatic
processing, an SQLCODE indicating end of data causes Easytrieve  to initiate end-of-input processing; the FINISH
PROC (if any) executes, spooled reports are printed, and the current JOB activity ends. During controlled processing, an
SQLCODE indicating end of data causes Easytrieve  to set the value of EOF to true.
The SQL cursor that is automatically defined by a SELECT statement is closed following the termination of the activity that
opened it.
NOTE
Non-mainframe systems are limited to a maximum of 10 open cursors.
Input Processing
You can access SQL data using an Easytrieve  file either automatically or with controlled processing.
 589 Easytrieve ® Report Generator 11.6
Automatic Processing
If you name the SQL file as the input file on a JOB statement, Easytrieve  automatically accesses your SQL database.
When you specify an SQL file as automatic input, Easytrieve  prepares a default SELECT statement for the cursor.
The following program displays all records in the table named PERSONNEL:
FILE PERSNL SQL (PERSONNEL)                                          
EMPNAME    *  20 A                                                   
WORKDEPT   *   2 P  0                                                
JOB NAME RETRIEVE-PERSONNEL INPUT PERSNL                             
  DISPLAY EMPNAME +2 WORKDEPT       
You can override the default SELECT statement by coding a SELECT statement for the automatic input file as the first
statement in the JOB, as follows:
FILE PERSNL SQL (PERSONNEL)                                          
EMPNAME    *  20 A                                                   
WORKDEPT   *  2  P  0                                                
JOB NAME RETRIEVE-PERSONNEL INPUT PERSNL                             
  SELECT FROM PERSNL WHERE WORKDEPT = 901                            
  DISPLAY EMPNAME +2 WORKDEPT                                        
This program displays only the records for employees that are assigned to department 901. The SELECT statement
provides the new default selection criteria.
Using DEFER with SELECT
You can use the DEFER parameter on the SQL FILE statement to delay SELECT processing. For example, assume that
you want to select only employee numbers in a particular department and the department number is kept in a card file.
The SELECT statement contains a WHERE clause specifying the host variable in the card file.  Easytrieve  opens the
CARD file at the initiation of the JOB activity but the GET statement is coded in a START procedure. If the file SELECT is
not deferred, the SELECT is performed using an uninitialized host variable. Coding DEFER enables the START procedure
to get the card before the SELECT is performed.
In addition, if DEFER is not specified, the default SELECT is executed before the START procedure. Then the SELECT in
the START procedure is executed. This causes extra processing that is not needed. For example:
FILE PERSNL SQL (PERSONNEL) DEFER
EMPNAME  * 20 A
WORKDEPT *  2 P
FILE CARDFIL CARD
CARDDEPT 1 3 N
JOB NAME RETRIEVE-PERSONNEL INPUT PERSNL START GETCARD
  DISPLAY EMPNAME +2 WORKDEPT
  GETCARD. PROC
    GET CARDFIL
  SELECT FROM PERSNL WHERE WORKDEPT = :CARDDEPT
  END-PROC
NULLable Field Processing
The following example illustrates how to process the nullable field, EMPPHONE. You must test for a nullable field before
processing it. If EMPPHONE contains a null value, it is set to zero before displaying it:
 590 Easytrieve ® Report Generator 11.6
FILE PERSNL SQL (PERSONNEL)                                          
  SQL INCLUDE (EMPNAME, WORKDEPT, EMPPHONE) +                        
    FROM PERSONNEL LOCATION * NULLABLE                               
JOB NAME RETRIEVE-PERSONNEL INPUT PERSNL                             
  IF EMPPHONE NULL                                                   
    EMPPHONE = 0                                                     
  END-IF                                                             
  DISPLAY EMPNAME +2 WORKDEPT +2 EMPPHONE   
Multiple Tables
The following example illustrates joining two tables, PERSONNEL and DEPARTMENTS, to report on employees and the
departments in which they work:
FILE PERSNL SQL (PERSONNEL, DEPARTMENTS)                             
EMPNAME    *  20 A     HEADING 'EMPLOYEE NAME'                       
WORKDEPT   *   2 P 0   HEADING ('DEPT', 'NO')                        
DEPTNAME   *  22 A     HEADING 'DEPARTMENT'                          
DEPTNUMBER *   2 P 0                                                 
JOB NAME RETRIEVE-PERSONNEL INPUT PERSNL                             
  SELECT FROM PERSNL WHERE WORKDEPT = DEPTNUMBER                     
  PRINT PERSNL-REPORT                                                
  REPORT PERSNL-REPORT                                               
    LINE EMPNAME WORKDEPT DEPTNAME                                   
Both table names are specified on the FILE statement. The default SELECT is overridden because the result set should
include only those DEPARTMENT records that match the department number of the PERSONNEL record.
Controlled Processing
You use the FETCH statement (in conjunction with SELECT and CLOSE statements) to retrieve the records from the file
with controlled processing. You can code these statements within a PROGRAM, SCREEN, or JOB activity, with or without
automatic input. The following rules apply:
•Controlled statements are not permitted in SORT or REPORT procedures.
•The FETCH statement cannot reference an automatic input file within the same JOB activity. You can FETCH from a
file other than the file subject to automatic input.
In a PROGRAM Activity
The following example illustrates controlled input from a default cursor:
FILE PERSNL SQL (PERSONNEL)                                          
EMPNAME    *  20 A                                                   
WORKDEPT   *   2 P 0                                                 
PROGRAM NAME RETRIEVE-PERSONNEL                                      
  FETCH FROM PERSNL                                                  
  DO WHILE NOT EOF PERSNL                                            
    DISPLAY EMPNAME +2 WORKDEPT                                      
    FETCH FROM PERSNL                                                
  END-DO                                                             
The PROGRAM activity fetches each row of the table and displays the fields. The DO statement executes until end-of-file.
In a JOB Activity
 591 Easytrieve ® Report Generator 11.6
The same process used in a JOB activity is coded as follows:
FILE PERSNL SQL (PERSONNEL)                                          
EMPNAME    *  20 A                                                   
WORKDEPT   *   2 P 0                                                 
JOB NAME RETRIEVE-PERSONNEL INPUT NULL                               
  FETCH FROM PERSNL                                                  
  IF NOT EOF PERSNL                                                  
    DISPLAY EMPNAME +2 WORKDEPT                                      
  ELSE                                                               
    STOP                                                             
  END-IF                                                             
You must execute a STOP statement when end-of-file is reached, because a NULL JOB activity automatically loops.
Random Processing
The following example illustrates a type of random processing in which the SQL file cursor is built using a key that is
contained in a sequential file.
FILE esds-filename SEQUENTIAL                                                 
FILENAME   17  20 A                                                  
FILE PERSNL SQL (PERSONNEL) DEFER                                    
EMPNAME    *  20 A                                                   
WORKDEPT   *   2 P 0                                                 
JOB NAME RETRIEVE-PERSONNEL INPUT esds-filename                               
  SELECT FROM PERSNL WHERE EMPNAME = :FILENAME                       
  FETCH FROM PERSNL                                                  
  IF EOF PERSNL                                                      
    DISPLAY 'EMPLOYEE NOT ON FILE ' FILENAME                         
  ELSE                                                               
    DISPLAY EMPNAME +2 WORKDEPT                                      
  END-IF                                                             
  CLOSE PERSNL       
The sequential file is read automatically by the JOB activity. For each record, a SELECT statement is executed to
locate the employee in the PERSONNEL table. If the FETCH statement results in end-of-file, the employee is not found.
Otherwise, the employee name and department are displayed.
Synchronized File Processing
The following example illustrates a way to match a sequential file with an SQL file. This example uses the default SELECT
and then matches the two files based on the employee name in both files:
FILE esds-filename SEQUENTIAL                                                 
FILENAME   17  20 A                                                  
FILE PERSNL SQL (PERSONNEL)                                          
EMPNAME    *  20 A                                                   
WORKDEPT   *   2 P 0                                                 
JOB NAME MATCH-PERSNL INPUT (esds-filename KEY (FILENAME) PERSNL KEY (EMPNAME))
    IF NOT MATCHED AND esds-filename                                          
       DISPLAY 'EMPLOYEE NOT IN SQL FILE' FILENAME                   
    ELSE                                                             
       IF NOT MATCHED AND PERSNL                                     
 592 Easytrieve ® Report Generator 11.6
          DISPLAY 'EMPLOYEE NOT ON esds-filename FILE' EMPNAME                
       ELSE                                                          
          DISPLAY 'EMPLOYEE ON BOTH FILES' EMPNAME                   
       END-IF                                                        
    END-IF
The default SELECT could have been overridden by coding a SELECT as the first statement after the JOB statement.
Update Processing
Additional requirements for updating an Easytrieve  SQL file are as follows:
•You can name only one table on the FILE statement for updates, inserts, or deletions.
•You must specify the UPDATE parameter on the FILE statement if all fields defined are subject to update. If you want
to update only certain fields, do not specify UPDATE on the FILE statement, but specify UPDATE on the DEFINE
statement for each field to be updated. You can also use the SQL INCLUDE statement to automatically generate
definitions with UPDATE.
•You must specify UPDATE on the FILE statement to insert or delete rows.
•For updating, you must code a SELECT statement for the file that contains the FOR UPDATE clause. If the FOR
UPDATE clause is omitted, the first UPDATE statement is flagged in error. Default SELECT statements that are
created by Easytrieve  do not contain the FOR UPDATE clause.
•For ORACLE, dynamic UPDATEs and DELETEs must be mimicked by Easytrieve  by selecting the ROWID of each
row, then using that value to identify the current row during the UPDATE or DELETE. For this reason, you must use a
SELECT statement with the FOR UPDATE clause.
•For certain ODBC data sources, UPDATEs and DELETEs WHERE CURRENT OF CURSOR are not supported. In
these cases, you must use native SQL statements.
Controlled Processing
The following example selects a specific row from the table, updates the department to 930, and moves a null data value
to the phone number:
FILE PERSNL SQL (PERSONNEL) UPDATE                                   
SQL INCLUDE (EMPNAME, WORKDEPT, EMPPHONE) +                          
  FROM PERSONNEL LOCATION * NULLABLE                                 
PROGRAM NAME RETRIEVE-PERSONNEL                                      
  SELECT FROM PERSNL WHERE EMPNAME = 'ROGERS  PAT' FOR UPDATE        
  FETCH FROM PERSNL                                                  
  IF EOF PERSNL                                                      
    DISPLAY 'EMPLOYEE NOT FOUND'                                     
  ELSE                                                               
    WORKDEPT = 930                                                   
    MOVE NULL TO EMPPHONE                                            
    UPDATE PERSNL                                                    
  END-IF                                                             
Automatic Processing
The following example changes the department number for all employees in departments 901 through 921:
FILE PERSNL SQL (PERSONNEL) UPDATE                                   
SQL INCLUDE (WORKDEPT) +                                         
  FROM PERSONNEL LOCATION *                                     
 593 Easytrieve ® Report Generator 11.6
JOB NAME RETRIEVE-PERSONNEL INPUT PERSNL                       
  SELECT FROM PERSNL WHERE WORKDEPT = 901 FOR UPDATE 
  WORKDEPT = 921                                                     
  UPDATE PERSNL                                                      
Deleting from an SQL File
The following example illustrates how to select a specific row from the table, and then delete it:
FILE PERSNL SQL (PERSONNEL) UPDATE                                   
SQL INCLUDE (EMPNAME, WORKDEPT, EMPPHONE) +                          
  FROM PERSONNEL LOCATION * NULLABLE                                 
PROGRAM NAME RETRIEVE-PERSONNEL                                      
  SELECT FROM PERSNL WHERE EMPNAME = 'ROGERS  PAT' FOR UPDATE        
  FETCH FROM PERSNL                                                  
  IF EOF PERSNL                                                      
    DISPLAY 'EMPLOYEE NOT FOUND'                                     
  ELSE                                                               
    DELETE FROM PERSNL                                               
  END-IF                                                             
Inserting an SQL Row
The following example illustrates how to insert a new row into a table:
FILE PERSNL SQL (PERSONNEL) UPDATE                                   
SQL INCLUDE (EMPNAME, WORKDEPT, EMPPHONE) +                          
  FROM PERSONNEL LOCATION * NULLABLE                                 
PROGRAM NAME RETRIEVE-PERSONNEL                                      
  EMPNAME = 'WIMN    GLORIA'                                         
  WORKDEPT = 921                                                     
  EMPPHONE = 3478                                                    
  INSERT INTO PERSNL                                                 
Automatic Retrieval Without a File
Use automatic retrieval without a file in  Easytrieve  to retrieve SQL data as a result of a specially-coded JOB and
SELECT statement combination.
Automatic retrieval without a file is a read-only method that typically uses working storage fields as the receiving area for
the data. This method allows some advanced selection techniques not available for cursors associated with  Easytrieve 
files.
Processing Requirements
To process data from an SQL table using this method, you must provide the following:
 594 Easytrieve ® Report Generator 11.6
•One or more field definitions for the columns within the tables that you want to retrieve
•These definitions can be coded using the DEFINE statement or by using the SQL INCLUDE statement to automatically
generate the definitions from the SQL catalog. The definitions are usually coded in working storage, but you can define
the fields in an output file for extraction purposes.
•A JOB statement with the INPUT SQL parameter
•SQL signifies that the automatic processing does not involve an  Easytrieve  file.
•A non-file-based SELECT statement that defines the result set for the cursor
•Only one non-file based SELECT statement can be coded in each JOB activity.
This SELECT statement is very different from the file-based SELECT statement used with an  Easytrieve  SQL file,
because it more closely approximates a true SQL SELECT clause. For example, you name the tables that participate
in the result. Also, the SELECT can perform more advanced selections such as UNIONs.
Operation
Easytrieve  generates and executes a CONNECT statement. You need not code an SQL CONNECT statement when
using  Easytrieve  automatic processing. The user ID and password parameters are taken from those specified in the
USERID parameter of the PARM statement.
Easytrieve  checks the SQLCODE field following each execution of the SELECT statement. If the SQLCODE indicates an
error,  Easytrieve  issues an error message based on the SQL error and terminates execution. An SQLCODE indicating
end of data causes  Easytrieve  to initiate end-of-input processing: the FINISH PROC (if any) executes, spooled reports
are printed, and the current JOB activity ends.
The SQL cursor that is automatically defined by a non-file-based SELECT statement is closed following the termination of
the JOB activity that opened it.
Retrieving All Columns
The following code retrieves all columns and all rows from the PERSONNEL table. A report is generated showing
WORKDEPT, EMPNAME, and EMPPHONE.  Easytrieve  sorts the report by WORKDEPT. Note the use of manual null
variable indicators.
DEFINE EMPNAME    W 20 A                                             
DEFINE WORKDEPT   W  2 P 0                                           
DEFINE EMPPHONE   W  3 P 0                                           
DEFINE NULLPHONE  W  2 B 0 .* NULL INDICATOR                         
JOB INPUT SQL NAME(SQLEX1)                                           
   SELECT * FROM PERSONNEL                            +              
      INTO :EMPNAME, :WORKDEPT, :EMPPHONE :NULLPHONE                 
   IF NULLPHONE < 0 .* PHONE PRESENT?                                
      EMPPHONE = 0  .* NO, SET TO 0                                  
   END-IF                                                            
   PRINT PERSNL                                                      
REPORT PERSNL LINESIZE 65                                            
 SEQUENCE WORKDEPT                                                   
 LINE WORKDEPT EMPNAME EMPPHONE                                      
Selected Columns
The following code retrieves all rows of selected columns from the PERSONNEL table and generates a report showing
WORKDEPT and EMPNAME. SQL orders the rows by WORKDEPT.
DEFINE EMPNAME    W 20 A                                             
 595 Easytrieve ® Report Generator 11.6
DEFINE WORKDEPT   W  2 P 0                                           
JOB INPUT SQL NAME(SQLEX2)                                           
   SELECT EMPNAME, WORKDEPT     +                                    
      FROM PERSONNEL            +                                    
      ORDER BY WORKDEPT         +                                    
      INTO :EMPNAME, :WORKDEPT                                       
   PRINT PERSNL                                                      
REPORT PERSNL LINESIZE 65                                            
 LINE WORKDEPT EMPNAME                                               
Multiple Tables
The following code retrieves an employee name and the corresponding department name from the PERSONNEL and
DEPARTMENTS tables. This example shows parameters required for SQL/DS.
PARM USERID('SQLDBA' 'SQLDBAPW') +                                   
     PREPNAME(EASYOL 'SQLDBA')                                       
DEFINE EMPNAME    W 20 A                                             
DEFINE WORKDEPT   W  2 P 0                                           
DEFINE EMPPHONE   W  3 P 0                                           
DEFINE DEPTNAME   W 22 A    VARYING                                  
DEFINE DEPTNUMBER W  2 P 0                                           
DEFINE NULLPHONE  W  2 B 0 .* NULL INDICATOR                         
JOB INPUT SQL NAME(SQLEX3)                                           
   SELECT EMPNAME, DEPTNAME          +                               
      FROM PERSONNEL, DEPARTMENTS    +                               
      WHERE  WORKDEPT = DEPTNUMBER   +                               
      INTO :EMPNAME, :DEPTNAME                                       
   PRINT PERSNL                                                      
REPORT PERSNL LINESIZE 65                                            
 LINE EMPNAME DEPTNAME                                               
Native SQL Processing
Use Native SQL processing in  Easytrieve  to use native SQL statements equivalent to many of those used in COBOL.
With native SQL statements, code fully SQL-compliant programs to control SQL cursor operation.
All native SQL statements are prefixed with the SQL keyword. For complete syntax, see the Language Reference  section.
This article contains the following information:
Processing Requirements
You must code the SQL DECLARE statement in the Library Definition section of an Easytrieve  program. You must code all
other SQL statements, except SQL INCLUDE, in the Activity Definition section.
You should test the SQLCODE field in the SQLCA to determine whether or not the execution of each controlled
processing statement is successful.
If the SQLCODE field contains a zero (0), you should test the SQLWARN0 field to ensure that no warning conditions were
issued during processing of the SQL statement. To determine acceptable values for SQLWARN0, see the appropriate
SQL reference documentation.
You must code all SQL INCLUDE statements and SQL-managed file definitions before any controlled SQL statements.
 596 Easytrieve ® Report Generator 11.6
Operation
Coding native SQL statements requires an advanced knowledge of SQL statements and of the database to be processed.
You can code native SQL statements in any PROGRAM or JOB activity. You cannot code them in SORT or REPORT
procedures.
Supported SQL Commands
Following is a list of commonly used SQL commands. They must be prefixed by SQL. For a complete list, see the
Language Reference  section. For more information, see your SQL vendor reference documentation.
•CLOSE
•COMMIT
•CONNECT
•DECLARE
•DELETE
•FETCH
•INSERT
•OPEN
•PUT
•ROLLBACK
•UPDATE
DB2
All DB2 commands that can be executed using the DYNAMIC execution facilities of DB2 are supported. For more
information, see the SQL reference manual for your current release .
SQL/DS
All SQL/DS commands that are supported through the EXTENDED DYNAMIC facilities of SQL/DS are supported. For
more information, see either of the following manuals:
•SQL/Data System Application Programming for VSE (SH24-5018)
•SQL/Data System Application Programming for VM/SP (SH24-5068)
Advantage Ingres
All Ingres SQL commands that can be executed using the DYNAMIC execution facilities are supported. For more
information, see the Ingres Enterprise Relational Database SQL Reference Guide .
Oracle
All Oracle SQL commands that can be executed using the DYNAMIC execution facilities are supported. For more
information, see the Oracle SQL Reference Guide .
Note: Due to the Oracle restriction against using the CURRENT OF clause with dynamic SQL, Easytrieve  must mimic the
CURRENT OF clause using ROWID. This technique prohibits use of SELECT * in conjunction with DELETE or UPDATE
WHERE CURRENT OF cursor.
Note: Oracle systems are limited to a maximum of 10 cursors.
Unsupported SQL Commands
The following SQL commands cannot be issued using Easytrieve  controlled SQL processing:
 597 Easytrieve ® Report Generator 11.6
•BEGIN DECLARE
•CREATE PROGRAM
•DECLARE STATEMENT
•DECLARE TABLE
•DESCRIBE
•END DECLARE
•EXECUTE
•EXECUTE IMMEDIATE
•PREPARE
•SELECT ... INTO ...
•WHENEVER
The SELECT ...INTO... command is valid when processing DB2 static-only programs. For more information, see the
SQLSYNTAX parameter for the PARM statement.
Note: The SELECT ... INTO ... command (singleton SELECT) can be simulated using Easytrieve  automatic cursor
management.
Retrieving All Columns
The following example retrieves all columns from the PERSONNEL table.
PARM USERID('SQLDBA' 'SQLDBAPW') +                                   
     PREPNAME(EASYOL 'SQLDBA')                                       
DEFINE EMPNAME    W 20 A                                             
DEFINE WORKDEPT   W  2 P 0                                           
DEFINE EMPPHONE   W  3 P 0                                           
DEFINE DEPTNAME   W 22 A    VARYING                                  
DEFINE DEPTNUMBER W  2 P 0                                           
DEFINE NULLPHONE  W  2 B 0 .* NULL INDICATOR                         
DEFINE USERID     W  8 A    VALUE ('SQLDBA')                         
DEFINE PASSWORD   W  8 A    VALUE ('SQLDBAPW')                       
SQL DECLARE CURSOR1 CURSOR FOR    +                                  
SELECT *                          +                                  
   FROM PERSONNEL                                                    
JOB INPUT NULL NAME(SQLEX4)                                          
   SQL CONNECT :USERID IDENTIFIED BY :PASSWORD                       
   PERFORM CHECKSQL                                                  
   SQL OPEN CURSOR1                                                  
   PERFORM CHECKSQL 
   DO WHILE SQLCODE NE 100. * 1403 FOR ORACLE                        
      SQL FETCH CURSOR1              +                               
          INTO :EMPNAME, :WORKDEPT, :EMPPHONE :NULLPHONE             
      PERFORM CHECKSQL                                               
      IF NULLPHONE < 0    . * PHONE PRESENT?                         
         EMPPHONE = 0     . * NO, SET TO 0                           
      END-IF                                                         
      IF SQLCODE NE 100   . * NOT END OF TABLE                       
         PRINT PERSNL                                                
      END-IF                                                         
   END-DO    
   SQL CLOSE CURSOR1                                                 
   PERFORM CHECKSQL                                                  
 598 Easytrieve ® Report Generator 11.6
   STOP      
CHECKSQL. PROC                                                       
 IF SQLCODE NE 0 AND SQLCODE NE 100. * 1403 FOR ORACLE               
    DISPLAY 'SQLCODE = ' SQLCODE                                     
    STOP EXECUTE                                                     
 END-IF                                                              
END-PROC                                                             
REPORT PERSNL LINESIZE 65                                            
 LINE EMPNAME WORKDEPT EMPPHONE                                      
Reassign Departments
The following example reassigns all employees in department 901 to department 109 and displays the names of the
employees. The PARM statement parameters are necessary only if you want to access a DB2 or Ingres database
subsystem other than the default.
PARM SSID('DB2B')                                                    
DEFINE EMPNAME    W 20 A                                             
DEFINE WORKDEPT   W  2 P 0                                           
SQL DECLARE CURSOR1 CURSOR FOR    +                                  
SELECT EMPNAME                    +                                  
   FROM PERSONNEL                 +                                  
   WHERE WORKDEPT = 901           +                                  
   FOR UPDATE OF WORKDEPT      
JOB INPUT NULL NAME(SQLEX5)                                          
   SQL CONNECT :USERID IDENTIFIED BY :PASSWORD                       
   PERFORM CHECKSQL                                                  
   SQL OPEN CURSOR1                                                  
   PERFORM CHECKSQL     
   DO WHILE SQLCODE NE 100. * 1403 FOR ORACLE                        
      SQL FETCH CURSOR1           +                                  
          INTO :EMPNAME                                              
      PERFORM CHECKSQL                                               
      IF SQLCODE NE 100   . * 1403 FOR ORACLE                        
         PRINT PERSNL                                                
         SQL UPDATE PERSONNEL                  +                     
             SET WORKDEPT = 109                +                     
             WHERE CURRENT OF CURSOR1                                
         PERFORM CHECKSQL                                            
      END-IF                                                         
   END-DO  
   SQL CLOSE CURSOR1                                                 
   PERFORM CHECKSQL                                                  
   STOP  
CHECKSQL. PROC                                                       
 IF SQLCODE NE 0 AND SQLCODE NE 100. * 1403 FOR ORACLE               
    DISPLAY 'SQLCODE = ' SQLCODE                                     
    STOP EXECUTE                                                     
 END-IF                                                              
END-PROC                                                             
REPORT PERSNL LINESIZE 65                                            
 LINE EMPNAME                                                        
 599 Easytrieve ® Report Generator 11.6
Update Phone Numbers
The following example illustrates how to update a phone system. In this case all phone numbers must be changed to 5
digits. The first character must be a 7 and the rest of the digits remain the same. If an employee does not have a phone
number, his or her record is not updated. No update report is necessary.
JOB INPUT NULL NAME(SQLEX6)                                          
   SQL CONNECT :USERID IDENTIFIED BY :PASSWORD                       
   PERFORM CHECKSQL                                                  
    SQL UPDATE PERSONNEL                +                            
       SET EMPPHONE = 70000 + EMPPHONE  +                            
       WHERE EMPPHONE IS NOT NULL                                    
    PERFORM CHECKSQL                                                 
    STOP                                                             
CHECKSQL. PROC                                                       
 IF SQLCODE NE 0 AND SQLCODE NE 100. * 1403 FOR ORACLE               
    DISPLAY 'SQLCODE = ' SQLCODE                                     
    STOP EXECUTE                                                     
 END-IF                                                              
END-PROC                                                             
Using Table Name as Host Variable with Indicator Array
In this example, INDARRAY is used instead of the default indicator created by the SQL INCLUDE statement. An indicator
is matched for each field in the PERSONNEL table.
PARM USERID('SQLDBA' 'SQLDBAPW') +                                   
     PREPNAME(EASYOL 'SQLDBA')                                       
SQL INCLUDE (EMPNAME, WORKDEPT, EMPPHONE) FROM PERSONNEL NULLABLE    
DEFINE INDARRAY   W  2 B 0  OCCURS 3                                 
SQL DECLARE CURSOR1 CURSOR FOR    +                                  
  SELECT * FROM PERSONNEL   
JOB INPUT NULL NAME(SQLEXT)                                          
   SQL CONNECT :USERID IDENTIFIED BY :PASSWORD                       
   PERFORM CHECKSQL                                                  
  SQL OPEN CURSOR1                                                   
  PERFORM CHECKSQL      
  DO WHILE SQLCODE EQ 0                                              
    SQL FETCH CURSOR1 +                                              
      INTO :PERSONNEL :INDARRAY                                      
    PERFORM CHECKSQL                                                 
    IF INDARRAY(3) < 0                                               
      EMPPHONE = 0                                                   
    END-IF                                                           
    IF SQLCODE NE 100. * 1403 FOR ORACLE                             
      PRINT PERSNL                                                   
    END-IF                                                           
  END-DO       
  SQL CLOSE CURSOR1                                                  
  PERFORM CHECKSQL                                                   
  STOP  
CHECKSQL. PROC                                                       
  IF SQLCODE NE 0 AND SQLCODE NE 100. * 1403 FOR ORACLE              
    DISPLAY 'SQLCODE = ' SQLCODE                                     
 600 Easytrieve ® Report Generator 11.6
    STOP EXECUTE                                                     
  END-IF                                                             
END-PROC                                                             
REPORT PERSNL LINESIZE 65                                            
 LINE EMPNAME WORKDEPT EMPPHONE                                      
ODBC Data Sources
Use  Easytrieve  to access your ODBC data sources. There are limitations on the activities you can use with data sources
in  Easytrieve  ..
The following table presents data sources tested by Broadcom  and provides usage notes:
Data Source Usage Notes
Microsoft SQL Server All processing supported
Microsoft Access Does not support UPDATE or DELETE WHERE CURRENT OF
CURSOR.
Microsoft Excel Does not support UPDATE or DELETE WHERE CURRENT OF
CURSOR.
See Access an Excel Spreadsheet as an SQL File   for tips on
setup.
Comma-Separated Values Files Read and insert processing only.
See Access a CSV File as an SQL File  for tips on setup.
SQL INCLUDE is not supported.
Advantage EDBC All processing supported
DB2 All processing supported
Oracle Does not support UPDATE or DELETE WHERE CURRENT OF
CURSOR.
MySQL Does not support UPDATE or DELETE WHERE CURRENT OF
CURSOR.
Access a CSV File as an SQL File
Use a Comma-Separated Values (CSV) File in  Easytrieve  as an SQL file in a program using ODBC. Generally, the file
supports read access and insert processing only.
For more information, see your ODBC documentation.
Set Up Your File
To set up your file, you must define your file as an ODBC data source.
Follow these steps:
1.From the Windows Start menu, select Settings, Control Panel, Administrative Tools, Data Sources (ODBC). The
ODBC Data Source Administrator dialog opens.
2.Under the User DSN tab, click Add… and then select Microsoft Text Driver (*.txt, *.csv).
3.Enter a Data Source Name and select the directory where the CSV file resides. Because this Data Source Name
defines the directory, it can be used for all CSV files in the directory.
4.Click Define Format to see a list of all files in the directory.
5.Select your CSV file and set the attributes for the columns in the file. If your file's first row will be used as column
names, check Column Name Header and click Guess to propagate the column list.
 601 Easytrieve ® Report Generator 11.6
Reference Your File in Your  Easytrieve  Program
Follow these steps:
•As the database name in the SSID parameter, specify the ODBC data source name that identifies the directory
containing the CSV file.
•Code your FILE statement, using any name you choose as the file name and the physical file name (including file
extension) as the table name.
Note: This differs from the standard SQL syntax of owner.table.
•Specify field definitions for each column in your file.
Note: Do not use the SQL INCLUDE statement for data definition. Because of the non-standard table name in Step 2,
you cannot use the SQL Catalog interface to generate your field definitions.
You are now ready to access the file by using SQL in your  Easytrieve  program.
Example
The following example shows how to list the fields in a CSV file:
PARM SSID 'MyDocs'
FILE Contacts SQL(Contacts.csv)
  LASTNAME    * 20 A
  FIRSTNAME   * 20 A
  HOMEPHONE   * 15 A
JOB INPUT Contacts
  PRINT
REPORT LINESIZE 80
  TITLE 'Contact Information'
LINE LASTNAME FIRSTNAME HOMEPHONE 
Access an Excel Spreadsheet as an SQL File
Use an Excel spreadsheet as an SQL file in a  Easytrieve  program using ODBC.
Set Up Your Spreadsheet in Excel
Follow these steps:
1.In a new or existing Excel spreadsheet, enter the required column name in the top cell of each column.
NOTE
These are the column names you reference in your  Easytrieve  program. They must be valid for  Easytrieve 
syntax.
2.From the Tools dropdown menu, select Share Workbook, and then check Allow changes by more than one user at the
same time. The Excel workbook is now shared.
3.Define the SQL table name for the Excel spreadsheet:
a.Highlight all the rows and columns that are to be part of the SQL table.
b.From the Insert dropdown menu, select Name, Define. The Define Name dialog opens.
c.Enter the name of the SQL table to be used in your  Easytrieve  program.
NOTE
The name must be valid for use in the syntax of an  Easytrieve  program.
4.Define the SQL column name for each Excel spreadsheet column to be used:
a.Highlight an entire column by clicking on the Excel-generated column heading.
 602 Easytrieve ® Report Generator 11.6
Language Reference
Review information in this section about  Easytrieve  character sets, statements, symbols and reserved words, and
converting from older versions to the current version of  Easytrieve .
Documentation Conventions
The following conventions are used throughout this section for illustrative purposes:
Notation Meaning
{braces} Mandatory choice of one of these entries.
[brackets] Optional entry or choice of one of these entries.
| (OR bar) Choice of one of these entries.
(parentheses) Multiple parameters must be enclosed in parentheses.
... Ellipses indicate that you can code the immediately preceding
parameters multiple times.
BOLD Bold text in program code is used to highlight an example of the
use of a statement.
CAPS All capital letters indicate an  Easytrieve  keyword, or within text
descriptions, indicate a name or field used in a program example.
lowercase italics Lowercase italics represent variable information in statement
syntax.
Syntax Rules
The free form English language structure of  Easytrieve  makes it easy for you to develop an efficient, flexible
programming style. To avoid programming errors, follow the simple syntax rules that are described for each statement in
this section.
Character Sets
Review details about how  Easytrieve  supports both single-byte character sets (SBCS) and double byte character sets
(DBCS) or a mix (MIXED format).
MIXED format is data that contains both SBCS and DBCS formatted data. SBCS data is limited to either EBCDIC or
ASCII depending on the platform. DBCS data is supported only in z/OS.
NOTE
Report processing is limited to EBCDIC and ASCII data format for standard reports and to any data format for
extended reports. Identifiers (for example, field names or labels) can contain DBCS and MIXED data as part of
the name. MIXED data format is supported only when such data is allowed. The product provides no additional
formatting based on the alignment of the DBCS portion of the data. DBCS data is not supported in the UNIX or
Windows environments.
EBCDIC and DBCS
Both EBCDIC and DBCS data processing are applicable to China (Hanzi characters), Japan (Kanji, Hiragana, and
Katakana characters), and Korea (Haja and Hangual characters). Easytrieve  supports both character sets, based on the
following assumptions and rules:
 829 Easytrieve ® Report Generator 11.6
•All the syntax rules that are described in the Statement Overview  section apply to EBCDIC data only. DBCS data in the
program statement area is not processed for such things as continuation characters, delimiters, words, and identifiers.
•Unless otherwise noted, source statements are expected to contain character data. Hexadecimal codes that are
embedded into statements are not supported as they may cause problems reading and printing the source program.
•A DBCS character occupies 2 bytes in storage. If not identified as DBCS characters, these same 2 bytes would be
processed as a pair of single-byte EBCDIC characters. To distinguish EBCDIC data from DBCS data,  Easytrieve 
uses a shift code system. This system, called the wrapping shift code system , takes the form of two codes -- one code
preceding and the second following the DBCS data. These codes wrap or enclose the DBCS data, thereby identifying
the beginning and end of DBCS data. The term that is associated with the code that precedes the DBCS data is a shift-
out code (shift-out of EBCDIC). The code that delimits (separates) the DBCS data is called a shift-in  code (shift-in to
EBCDIC). These codes can be one or two bytes in length.
The following diagram illustrates the use of the wrapping shift code system:
•A shift code is a special one or two-byte character that is contained in the program statement area. Shift code values
are defined in the DBCS Options module. For more information about the Options module, see the Using  section. Each
shift code value uniquely identifies the DBCS code system of the data. If the system cannot be uniquely identified, a
default is assumed. You can alter this default at compile time by using the PARM statement. For more information, see
the PARM Statement.
•In the statement area, shift codes are required to distinguish DBCS data from EBCDIC data. When an Easytrieve  word
has been identified, the word is known to be of EBCDIC, DBCS, or MIXED data format. Shift codes are maintained
for MIXED words only. The compiler identifies the statement containing the word and, when necessary, performs the
required processing to remove the shift codes and convert EBCDIC data.
•Once a shift-out code is found in a word, the data that follows is processed as DBCS data if any one of the following
actions occurs:
–The end statement area is reached before the related shift-in code is found.
–The shift-in code is found but it is not on a double byte boundary.
–The shift-out code is found as part of the identified DBCS data.
Statements
Review  Easytrieve  statements and a summary of the statements categorized by function.
Alphabetical Summary of Statements
The following table describes the statements that you can use in Easytrieve  programs.
Statement Description
% (percent) Invoke a macro
* (asterisk) Document comments in a program.
ACCESS Access a macro secured against unauthorized access in Panvalet
or VSAM.
AFTER-BREAK A REPORT procedure invoked following the printing of summary
lines for a control break.
AFTER-LINE A REPORT procedure invoked after printing a detail line on a
report.
AFTER-SCREEN A SCREEN procedure performed after a SCREEN activity
receives data from the terminal.
Assignment Establish a value in a field.
ATTR Use the ATTR parameter to assign screen attributes to a field or
literal.
 830 Easytrieve ® Report Generator 11.6
BEFORE-BREAK A REPORT procedure invoked before printing the summary lines
for a control break.
BEFORE-LINE A REPORT procedure invoked before printing a detail line on a
report.
BEFORE-SCREEN A SCREEN procedure invoked before a SCREEN activity sends
data to the terminal.
CALL Invoke subprograms written in other programming languages.
CASE Conditionally execute one of several alternative groups of
statements based on the value of a specific field.
CLOSE Close a file.
COMMIT Commit a logical unit of recoverable work.
CONTROL Identify control fields used in a control report.
COPY Duplicate field definitions of a named file.
CURSOR Set the initial position of the screen cursor.
DECLARE Name a set of screen attributes or an input edit pattern, or whether
a program is statically or dynamically linked.
DEFAULT Override system-defined screen attributes and message locations.
DEFINE Specify a data field within a file or within working storage.
DELETE Delete a row from an SQL file.
DISPLAY Format and transfer data to the system output device or to a
named file.
DLI Perform IMS/DLI functions against an IMS/DLI database.
DO UNTIL Control repetitive program logic by evaluating the condition at the
bottom of a group of statements.
DO WHILE Control repetitive program logic by evaluating the condition at the
top of a group of statements.
ELEMENT RECORD Identify the element records that comprise the logical record.
ELSE Identify statements to be executed when IF conditions are false.
See IF.
ELSE-IF Identify a conditional expression to be tested when the previous IF
or ELSE-IF conditional expression is false. See IF.
END-CASE Terminate the body of a CASE statement. See CASE.
END-DO Terminate the body of a loop associated with a DO UNTIL or DO
WHILE statement. See DO UNTIL and DO WHILE.
END-IF Terminate the logic associated with the previous IF statement. See
IF.
ENDPAGE A REPORT procedure used to produce page footing information.
END-PROC Delimit the statements in a procedure. See PROC Statement.
END-REPEAT Terminate the body of a REPEAT statement. See REPEAT.
ENDTABLE Delimit instream data used to create small tables.
EXECUTE Invoke a JOB, SORT, or SCREEN activity from a PROGRAM or
SCREEN activity.
EXIT Terminate a SCREEN activity.
FETCH Retrieve a row from an SQL file.
FILE Describe a file and database references.
 831 Easytrieve ® Report Generator 11.6
GET Place the next sequential record of the named file into the file's
record buffer.
GOTO Modify the top-to-bottom logic flow of statement execution.
GOTO JOB Branch to the top of the current JOB activity.
GOTO SCREEN Branch to the top of the current SCREEN activity.
HEADING Define an alternative heading for a field on a report.
IDD FILE Identify a non IDMS  file in the IDD and build the file and field
definition.
IDD NAME Establish the dictionary entity retrieval environment.
IDD RECORD Identify and define IDMS  and non IDMS  records.
IDD SUBSCHEMA Identify the subschema and build the file, record, logical record,
element record, and field definitions.
IDD VERSION Set a global override of the Options Table VERFILE, VERREC,
and VERSCHM defaults.
IDMS ACCEPT DBKEY Transfer database keys to program storage.
IDMS ACCEPT PROCEDURE Return information from the Application Program Information Block
(APIB) associated with a database procedure to the program.
IDMS ACCEPT STATISTICS Retrieve the system statistics.
IDMS BIND Sign on the activity with the database management system.
IDMS BIND FILE Give the database management system access to the record in
program storage.
IDMS BIND PROCEDURE Establish communications between a program and a DBA-written
database procedure.
IDMS COMMIT Request the creation of a checkpoint.
IDMS CONNECT Establish a record as a member of a set occurrence.
IDMS DISCONNECT Cancel the relationship between a record and a set occurrence.
IDMS ERASE Make a record or logical record unavailable for further processing
and remove it from all set occurrences in which it participates as a
member.
IDMS FIND Locate a record.
IDMS FINISH Sign off the database management system.
IDMS GET Retrieve current data records.
IDMS IF Test the status of a set.
IDMS KEEP Place a shared or exclusive lock on a record.
IDMS MODIFY Update a record or logical record within the database.
IDMS OBTAIN Locate and then retrieve a record. For database records, see
IDMS FIND and IDMB OBTAIN Statements. For logical records,
see IDMS OBTAIN.
IDMS READY Establish area availability with the database manager.
IDMS RETURN Retrieve the database key for an indexed record without retrieving
the record.
IDMS ROLLBACK Request recovery.
IDMS STORE Place a new record or logical record occurrence into a database.
IF Control the execution of associated statements by testing
conditional expressions.
 832 Easytrieve ® Report Generator 11.6
INITIATION A SCREEN procedure invoked during the start of a SCREEN
activity.
INSERT Insert a row into an SQL file.
JOB Define and initiate processing activities.
JOB INPUT Identify automatic input to the activity.
JOB INPUT NULL Inhibit automatic input.
JOB INPUT SQL Allow to automatically manage the SQL cursor without a file.
KEY Define valid terminal keys for a screen, specify descriptive text,
and assign functions to terminal keys.
LINE Define the content of a report line.
LINK Transfer control from current program to another named program
and return to current program.
LIST Regulate the printing or suppression of all statements in the
printed output of a program.
LOGICAL-RECORD Identify the logical records available for automatic or controlled
processing of IDMS  databases.
MACRO Define the parameters of a macro.
MEND Terminate a macro.
MESSAGE Define message type and text for messages in a SCREEN activity.
MOVE Transfer character strings from one storage location to another.
MOVE LIKE Move contents of fields with identical names from one file or
record to another.
MSTART Begin an instream macro.
NEWPAGE Eject the printer to the top of the next page before printing the next
line of source program on a statement listing.
PARM Override selected general standards for a program that are set in
the Site Options Table.
PERFORM Transfer control to a procedure and return control to next
executable statement in current program.
POINT Establish a position within an INDEXED or RELATIVE file from
which subsequent data is sequentially retrieved.
POP Restore the previous listing control indicators.
PRINT Produce report output.
PROC Initiate an Easytrieve  procedure.
PROGRAM Identify and initiate a processing activity that can optionally initiate
JOB, SORT, and SCREEN activities.
PUSH Save the current listing control indicators.
PUT Perform sequential file output.
READ Provide random access to INDEXED and RELATIVE files.
RECORD Identify the IDMS  database records available for automatic or
controlled processing.
REFRESH Restore the initial screen image by rebuilding it with the current
values of program fields.
RELEASE Manually release the hold on any record in an INDEXED or
RELATIVE file.
 833 Easytrieve ® Report Generator 11.6
REPEAT Display arrays on a screen.
REPORT Define the type and characteristics of a report.
REPORT-INPUT A REPORT procedure that selects or modifies report input data.
RESHOW Redisplay a screen image without rebuilding the screen using the
current values of program fields.
RETRIEVE Identify the IDMS  or IMS/DLI database records that are input to
the JOB activity.
ROLLBACK Roll back all recoverable work since the last commit-point.
ROW Specify items to be displayed and received on a row of a screen.
SCREEN Define and initiate a SCREEN activity.
SEARCH Provide access to table data.
SELECT (File-based SQL) Cause a cursor to be declared and opened for a SQL file.
SELECT ( IDMS ) Specify automatic input of logical records from IDMS  databases.
SELECT (Non-file SQL) Identify the rows and columns to be input to a JOB activity when
an Easytrieve  file is not used.
SELECT (Report Selection) Select report input data.
SELECT (Sort Selection) Select sort input data.
SEQUENCE Specify the order of a report based on the content of one or more
fields.
SET Dynamically change screen attributes and control the display of
screen errors.
SKIP Space the printer a designated number of lines before printing the
next line of a statement listing.
SORT Sequence an input file in alphabetical or numerical order based on
fields specified as keys.
SQL Indicate a valid SQL statement for any of the supported SQL
database management systems.
SQL INCLUDE Indicate SQL table information is used to generate Easytrieve  field
definitions.
STOP Terminate activities.
SUM Specify the quantitative fields that are to be totaled for a control
report.
TERMINATION (Reports) A REPORT procedure invoked at the end of a report, commonly
used to print report footing information.
TERMINATION (Screens) A SCREEN procedure invoked once during the end of a SCREEN
activity, used to perform actions that are executed once at the end
of the activity.
TITLE (Reports) Define an optional report title and its position on a title line.
TITLE (Screens) Define and center title items on a screen.
TRANSFER Transfer execution to a program without returning to the invoking
program.
UPDATE Update a row from an SQL file.
WRITE Update and delete existing records or add new records to
INDEXED and RELATIVE files.
 834 Easytrieve ® Report Generator 11.6
Statements Categorized by Function
The following Easytrieve  statements are categorized by function:
Library Definition
•COPY
•DECLARE
•DEFINE
•FILE
•SQL INCLUDE
File Management
•CLOSE
•COMMIT
•DELETE
•DISPLAY
•ENDTABLE
•FETCH
•GET
•INSERT
•JOB
•JOB INPUT NULL
•JOB INPUT SQL
•POINT
•PUT
•READ
•RELEASE
•ROLLBACK
•SELECT (File-based SQL)
•SELECT (Non-file SQL)
•SELECT (Sort selection)
•SORT
•UPDATE
•WRITE
Screen Processing
NOTE
Screen processing commands are supported only with Online versions of the product.
 835 Easytrieve ® Report Generator 11.6
•AFTER-SCREEN
•BEFORE-SCREEN
•CURSOR
•DEFAULT
•EXIT
•INITIATION
•KEY
•MESSAGE
•REFRESH
•REPEAT
•RESHOW
•ROW
•SCREEN
•SET
•TERMINATION
•TITLE
Report Processing
•AFTER-BREAK
•AFTER-LINE
•BEFORE-BREAK
•BEFORE-LINE
•CONTROL
•ENDPAGE
•HEADING
•LINE
•PRINT
•REPORT
•REPORT-INPUT
•SELECT
•SEQUENCE
•SUM
•TERMINATION
•TITLE
Generalized Programming
•PARM
•PROGRAM
Inter-Program Execution
•CALL
•LINK
•TRANSFER
 836 Easytrieve ® Report Generator 11.6
Decision and Branching Logic
•CASE
•DO UNTIL
•DO WHILE
•ELSE
•ELSE-IF
•END-DO
•END-IF
•EXECUTE
•GOTO
•GOTO JOB
•GOTO SCREEN
•IF
•PERFORM
•STOP
Listing Control
•* (asterisk)
•LIST
•NEWPAGE
•POP
•PUSH
•SKIP
Assignment and Moves
•Assignment
•MOVE
•MOVE LIKE
Macro Processing
•% (percent)
•ACCESS
•MACRO
•MEND
•MSTART
Native SQL
•SQL
 837 Easytrieve ® Report Generator 11.6
IDMS  Database Processing
•ELEMENT-RECORD
•IDD FILE
•IDD NAME
•IDD RECORD
•IDD SUBSCHEMA
•IDD VERSION
•IDMS ACCEPT DBKEY
•IDMS ACCEPT PROCEDURE
•IDMS ACCEPT STATISTICS
•IDMS BIND
•IDMS BIND FILE
•IDMS BIND PROCEDURE
•IDMS COMMIT
•IDMS CONNECT
•IDMS DISCONNECT
•IDMS ERASE
•IDMS FIND
•IDMS FINISH
•IDMS GET
•IDMS IF
•IDMS KEEP
•IDMS MODIFY
•IDMS OBTAIN
•IDMS READY
•IDMS ROLLBACK
•IDMS STORE
•LOGICAL-RECORD
•RECORD
•RETRIEVE
•SELECT ( IDMS )
IMS/DLI Database Processing
•DLI
Statement Overview
Review an overview of  Easytrieve  statements: Statement Area, Multiple Statements, Comments, Continuations, Words
and Delimiters, Keywords, Multiple Parameters, Field Names, Labels, Identifiers, Arithmetic Operators, Numeric Literals,
Alphanumeric Literals, and Font Numbers.
Statement Area
All source statements are records of 80 characters each. A system installation option establishes a statement area within
the 80 available positions. The default statement area is in columns 1 to 72.
 838 Easytrieve ® Report Generator 11.6
For example, although positions 1 to 80 are available, ‘SCANCOLS 7, SCANCOLE 72’ establishes the statement area as
positions 7 to 72. This allows for optional data (for example, sequence numbers and program identifiers) to be entered on
the record, but still be ignored by Easytrieve . The complete record is always printed on the statement listing.
                                              7 7      8             
1....6 7......................................2 3......0             
                                                                        
001000                                          PRGMNAME             
                                                                        
ignored          statement area                  ignored  
Multiple Statements
The statement area normally contains a single statement. However, you can enter multiple statements on a single record.
The character string '. ' (period followed by a space) indicates the end of a statement. Another  Easytrieve  statement
begins at the next available position of the statement area (after the space). For example, the following two statements
are on one record:
COST = FIXED + VARIABLE.  PRICE = COST + PROFIT
Comments
When the first non-blank character of a statement is an asterisk (*), the remainder of that record is a comment statement
that is ignored by the  Easytrieve  compiler. You can use comment statements at any place within a program, except
within a continued statement. A statement containing all blanks is treated as a comment.
To place a comment on the same line as a statement, code a period (.), one or more spaces, an asterisk (*), and then the
comment:
FIELD-NAME W 5 A    . * This is a comment
Continuations
The last non-blank character of a statement terminates the statement, unless that character is a - (minus) or a + (plus).
The - indicates that the statement continues at the start of the next statement area. The + indicates that the statement
continues with the first non-blank character in the next statement area. The difference between - and + is important only
when continuing words. Continuation between words is the same for both. The following continued statements produce
identical results:
FIELD-NAME   W   6   A   +                                    
             VALUE   'ABC-                                    
DEF'                                                         
----------------------------
FIELD-NAME   W   6   A   -                                    
             VALUE   'ABC+                                    
                      DEF'                                   
DBCS Data
To continue a statement defining DBCS data, you must delimit the DBCS data. This means a shift-in code must precede
the continuation character and a shift-out code must precede the continuing DBCS data on the next record. The following
example illustrates continuing a DBCS literal:
 839 Easytrieve ® Report Generator 11.6
FIELD-NAME   W  10   K   +                               
             VALUE   '[DBDBDB]   +                       
[DBDB]'                                                 
The [ and ] indicate shift-out and shift-in codes.
Words and Delimiters
One or more words make up each  Easytrieve  statement. A word can be a keyword, field name, literal, or symbol. All
words begin with a non-blank character. A delimiter or the end of the statement area terminates these words. Delimiters
make statements readable but are not considered part of the attached word.  Easytrieve  word delimiters are:
Delimiter Description
space The basic delimiter within each statement.
' single quote Encloses literals that are alphanumeric.
. period followed
by a spaceTerminates a statement.
, comma Used optionally for readability.
() parentheses Encloses multiple parameters and portions of arithmetic
expressions (the left parenthesis acts as a basic delimiter).
: colon Used as a delimiter for file, record, and field qualifications.
= equal sign Used as a delimiter for assignment and comparison statements.
NOTE
At least one space must follow all delimiters except for the '(' (left parenthesis), and the ':' (colon). Additionally,
the equal sign '=' can be coded with or without surrounding spaces.
Examples of the words RECORD-COUNT and NUM with various delimiters:
RECORD-COUNT
FILEONE:RECORD-COUNT
 (RECORD-COUNT)
 'RECORD-COUNT'
RECORD-COUNT,
 RECORD-COUNT.
RECORD-COUNT=10
IF RECORD-COUNT=10
NUM = 20
IF NUM = 20
Keywords
Keywords are words that have specific meaning to  Easytrieve . Some keywords are reserved words. You can use non-
reserved keywords in the appropriate context as field names, whereas reserved words cannot be used as field names. For
more information about keywords and reserved words, see Symbols and Reserved Words.
 840 Easytrieve ® Report Generator 11.6
Multiple Parameters
You must enclose multiple parameters within parentheses to indicate group relationships. If parentheses are not used,
only one parameter is assumed. The following example is an  Easytrieve  statement with multiple parameters:
CALL   PGMNAME  USING(FIELDA, FIELDB, FIELDC)
Field Names
Field names are composed of a combination of not more than 128 characters as follows:
•Alphabetic characters, A to Z, lowercase, and uppercase
•Decimal digits 0 through 9
•All special characters, except delimiters
The first character of a field name must be an alphabetic character, a decimal digit, or a national character (#, @, $).
In addition, a field name must contain at least one alphabetic or special character to distinguish the field name from a
number.
All working storage field names must be unique, and so must all field names within a single file. If you use the same field
name in more than one file, or in a file and in working storage, you must qualify the field name with the file name or the
word WORK. A qualified field name consists of the qualifying word followed by a colon and the field name. You can use
any number of spaces, or no spaces, to separate the colon from either the qualifying word or the field name. Field names
can contain DBCS characters.
Assume FLD1 occurs in both working storage and the file FILEA. FLD1 can be qualified in the following ways:
FILEA: FLD1
FILEA:FLD1
FILEA : FLD1
WORK:FLD1
Labels
Labels identify specific PROGRAMs, JOBs, PROCedures, REPORTs, SCREENs, and statements. Labels can be 128
characters long, can contain any character other than a delimiter, and can begin with A to Z, 0 through 9, or a national
character (#, @, $); they cannot consist of all numeric characters. Labels can contain DBCS characters.
Identifiers
Identifiers are words that name things (for example, field names or statement labels) in  Easytrieve . Identifiers cannot
contain these delimiters:
•comma {,}
•single quote {'}
•left parenthesis {(}
•right parenthesis {)}
•colon {:}
Arithmetic Operators
Easytrieve  arithmetic expressions use the following arithmetic operators:
 841 Easytrieve ® Report Generator 11.6
•multiplication (*)
•division (/)
•addition (+)
•subtraction (-)
The arithmetic operator must lie between two spaces.
Numeric Literals
Numeric literals can contain 18-numeric digits (characters 0 through 9). You can indicate the algebraic sign of a numeric
literal by attaching a + (plus) or a - (minus) prefix to the numeral. Also, you can use a single decimal point to indicate a
maximum precision of up to 18 decimal positions. The following examples are valid numeric literals:
123
+123
-123.4321
Alphanumeric Literals
Alphanumeric literals are words that are enclosed within single quotes, and can be 254 characters long. For more
information, see Literal and Data Formatting Rules .
Font Numbers
Font numbers are used by extended report processing to identify which font is used to display the field name or literal.
A font number must begin with a pound sign (#) and contain only numeric digits. Font numbers can be specified on the
following statements:
•DEFINE
•DISPLAY
•HEADING
•LINE
•TITLE
% (Macro Invocation) Statement
The macro invocation statement in  Easytrieve  enables you to invoke a macro. The statement consists of a macro name
preceded by a percent (%) sign. Review the syntax of the macro invocation statement.
NOTE
For more information about defining substitutable parameters in the macro, see MACRO Statement . For more
information about using macros, see the Programming  section.
This statement has the following format:
%macro-name  positional-parameters ...keyword-parameters  
%macro-name
Specifies a previously stored macro that you want to invoke. Macro names are limited to eight characters.
NOTE
For Panvalet  and Endevor  libraries the macro name can be from 1 to 10 characters in length.
 842 Easytrieve ® Report Generator 11.6
positional-parameters
Specifies values of positional parameters in the macro. You must supply positional parameters before any
keyword parameters.
keyword-parameters
Specifies both the keyword and values of keyword parameters in the macro.
* (Comment) Statement
The * (comment) statement in  Easytrieve  lets you document comments in a program. Review the syntax of a asterisk
(*) comment statement.
When the first non-blank character of a statement is an asterisk (*), the remainder of that record is a comment statement.
You can use comment statements any place within a program, except within a continued statement. A statement
containing all blanks is treated as a comment.
If you code comment statements within a SCREEN declaration and maintain the screen with the  Easytrieve  Online
Report Generator Screen Painter, all comment statements are moved to the top of the declaration.
This statement has the following format:
*  comment-text  
comment-text
Specifies the text that you want to enter as comment in the program.
ACCESS Statement
The ACCESS statement in  Easytrieve makes it possible to access a macro secured against unauthorized access in
Panvalet  or VSAM.
For both Panvalet  and VSAM macro storage access methods, the ACCESS record can appear anywhere in the 
Easytrieve  program prior to the retrieval of the macro, and remains in effect until the next ACCESS record is
encountered. The ACCESS record must be on a record by itself.  Easytrieve  does not print the ACCESS record.
This statement has the following format:
Panvalet :
ACCESS ' eight-byte code'                                             
VSAM:
ACCESS ' eight-byte password '                                         
'eight-byte code '
Specifies a security access code that applies to an individual Panvalet  library member. You must supply the
security access code on an ACCESS record before  Easytrieve  can retrieve a secured member.
'eight-byte password '
Specifies a VSAM password. VSAM provides the capability of protecting the macro library by using this password.
Before  Easytrieve  can retrieve a macro from a secured library, you must supply the library password on an
ACCESS record prior to the first macro call.
 843 Easytrieve ® Report Generator 11.6
AFTER-BREAK Report Procedure
The AFTER-BREAK. PROC produces special annotation on control reports. An AFTER-BREAK procedure in  Easytrieve 
is invoked following the printing of summary lines for a control break.
The AFTER-BREAK procedure is invoked once for each level of break. For example, assume two control fields are
specified. When the minor field causes a control break, the AFTER-BREAK procedure is invoked only once. When the
major field causes a control break, AFTER-BREAK is invoked twice.
The value of LEVEL (a system-defined field) can be used to determine which control break is being processed. The value
of BREAK-LEVEL (a system-defined field) contains the number of the field causing the control break. TALLY (a system-
defined field) contains the number of records in a particular control group. For examples of LEVEL and BREAK-LEVEL,
see Programming .
NOTE
If NOPRINT is specified on a CONTROL statement, the AFTER-BREAK procedure is still executed.
An AFTER-BREAK procedure must be delimited by an END-PROC statement. For more information, see PROC
Statement .
This procedure has the following format:
AFTER-BREAK. PROC
AFTER-BREAK. PROC
Specifies a REPORT procedure that is invoked following the printing of summary lines for a control break.
Example:
In the following example, the total line for the control field STATE receives special annotation:
Statements:
FILE FILE1                                                            
LAST-NAME  1  5 A                                                     
STATE      6  2 A                                                     
ZIP        8  5 N                                                     
PAY-NET    13 5 N 2                                                   
JOB INPUT FILE1 NAME MYPROG                                           
  PRINT REPORT1                                                       
*                                                                     
REPORT REPORT1 LINESIZE 65 +                                          
  SUMMARY  SUMCTL DTLCOPY                                             
  SEQUENCE STATE ZIP LAST-NAME                                        
  CONTROL  STATE ZIP                                                  
  LINE 01  LAST-NAME STATE ZIP PAY-NET                                
*                                                                     
 AFTER-BREAK. PROC 
 IF LEVEL EQ 2 
 DISPLAY 'TOTALS FOR THE STATE OF ' STATE 
 END-IF 
END-PROC  
Data:
BROWNIL6007612345                                                     
 844 Easytrieve ® Report Generator 11.6
BROWNIL6007667890                                                     
JONESIL6007709876                                                     
JONESIL6007754321                                                     
SMITHTX7521811111                                                     
SMITHTX7521866666  
Results:
             LAST-NAME   STATE    ZIP      PAY-NET                    
                                                                      
               BROWN      IL     60076       802.35                   
               JONES      IL     60077       641.97                   
                          IL                1444.32                   
 TOTALS FOR THE STATE OF IL 
                                                                      
               SMITH      TX     75218       777.77                   
                          TX                 777.77                   
 TOTALS FOR THE STATE OF TX 
                                            2222.09                   
AFTER-LINE Report Procedure
The AFTER-LINE. PROC to print a literal string after a detail line on the report. The AFTER-LINE procedure in  Easytrieve
should be invoked immediately following the printing of each detail line on a report.
The AFTER-LINE procedure is invoked after each individual line in a line group. The system-defined field LINE-NUMBER
contains the number of the line in the group being processed.
NOTE
When the AFTER-LINE procedure is invoked, the detail line for the report has already been built. You cannot
modify the contents of the detail line with an AFTER-LINE procedure. (To modify the contents of a detail line on
a report, use a REPORT-INPUT or BEFORE-LINE procedure.)
An AFTER-LINE procedure must be delimited by an END-PROC statement. For more information, see PROC Statement .
This statement has the following format:
AFTER-LINE. PROC
Example
The following example shows how an AFTER-LINE procedure can cause information to be printed following a detail line of
a report:
Statements:
FILE FILE1                                                            
LAST-NAME  1  5 A                                                     
STATE      6  2 A                                                     
ZIP        8  5 N                                                     
PAY-NET    13 5 N 2                                                   
JOB INPUT FILE1 NAME MYPROG                                           
  PRINT REPORT1                                                       
 845 Easytrieve ® Report Generator 11.6
*                                                                     
REPORT REPORT1 LINESIZE 65 +                                          
  DTLCTL   EVERY                                                      
  SEQUENCE STATE ZIP LAST-NAME                                        
  CONTROL  STATE ZIP                                                  
  LINE 01  LAST-NAME STATE ZIP PAY-NET                                
*                                                                     
 AFTER-LINE. PROC                                                      
   IF PAY-NET GE 500                                                   
     DISPLAY '* EMPLOYEE ' LAST-NAME ' +                               
      EXCEEDED WEEKLY SALARY GOAL *'                                   
   END-IF                                                               
 END-PROC                                                               
Data:
BROWNIL6007612345                                                     
BROWNIL6007667890                                                     
JONESIL6007709876                                                     
JONESIL6007754321                                                     
SMITHTX7521811111                                                     
SMITHTX7521866666                                                     
Results:
                 LAST-NAME   STATE    ZIP     PAY-NET                  
                                                                       
                  BROWN      IL     60076      678.90                 
 * EMPLOYEE BROWN EXCEEDED WEEKLY SALARY GOAL *                     
                  BROWN      IL     60076      123.45                 
                             IL     60076      802.35                 
                                                                      
                  JONES      IL     60077      543.21                 
 * EMPLOYEE JONES EXCEEDED WEEKLY SALARY GOAL *                     
                  JONES      IL     60077       98.76                 
                             IL     60077      641.97                 
                                                                      
                             IL               1444.32                 
                                                                      
                  SMITH      TX     75218      666.66                 
 * EMPLOYEE SMITH EXCEEDED WEEKLY SALARY GOAL *                     
                  SMITH      TX     75218      111.11                 
                             TX     75218      777.77                 
                                                                      
                             TX                777.77                 
 846 Easytrieve ® Report Generator 11.6
                                                                      
                                              2222.09                 
AFTER-SCREEN Screen Procedure
The AFTER-SCREEN procedure in  Easytrieve  enables you to perform complex editing and perform I/O after data
entry.  Review an example of AFTER-SCREEN. PROC.
An AFTER-SCREEN procedure in  Easytrieve  is invoked after the screen activity receives data from the terminal. All
branch actions (REFRESH, RESHOW, EXIT, GOTO SCREEN) are valid in the AFTER-SCREEN procedure and in any
procedure performed by the AFTER-SCREEN procedure. The AFTER-SCREEN procedure is not executed if the key
pressed is assigned to execute a branch action with a KEY statement.
An AFTER-SCREEN procedure must be delimited by an END-PROC statement. For more information, see PROC
Statement .
This statement has the following format:
AFTER-SCREEN. PROC
Example
SCREEN NAME SCRN1
    KEY F3 NAME 'Exit' EXIT 
    KEY F8 NAME 'Forward'   
. . .
     AFTER-SCREEN. PROC
       GET PERSNL
       IF EOF PERSNL
         EXIT
       END-IF
     END-PROC  
Assignment Statement
The assignment statement in  Easytrieve  establishes a value in a field either from data in another field or literal, or from
an arithmetic or logical expression evaluation.
The assignment statement has a normal assignment format and a logical expression format.
The normal assignment format sets the value of receive-field-name  equal to the value of send-field-name , send-literal ,
or the arithmetic expression. For complete rules of the assignment statement and rules for converting from EBCDIC to
DBCS, see the Programming  section.
The logical expression format sets the value of receive-field-name  equal to the result of evaluating a logical expression.
The value of send-field-name  is logically acted upon by the value of bit-mask-field-name  or bit-mask-literal . The lengths of
all values must be the same and bit-mask-literal  must be hexadecimal.
 847 Easytrieve ® Report Generator 11.6
NOTE
If receive-field-name  is nullable, then its indicator is set to zero, indicating NOT NULL. If any operands on the
right-hand side contain nulls, a runtime error occurs.
The normal assignment format is as follows:
                             [ROUNDED  ] {= } { send-field-name      }
receive-field-name  [INTEGER] [         ] {  } { send-literal          }
                             [TRUNCATED] {EQ} { arithmetic-expression }
receive-field-name
Specify the field name to which a value is to be assigned.
INTEGER
Specify INTEGER to ignore the fractional portion of the value being assigned. INTEGER causes only the
numerics to the left of the decimal point to be transferred during the assignment.
ROUNDED or TRUNCATED
Specify ROUNDED or TRUNCATED when the receiving field (receive-field-name ) is too small to handle the
fractional result of the assignment. TRUNCATED is the default.
Specify ROUNDED to round off the fractional result of the assignment statement. The least significant digit of the
result (receiving field) has its value increased by one when the most significant digit of the excess decimal digits is
greater than or equal to five. For example, if 10.75 is the value of the sending field and the receiving field has one
decimal place, ROUNDED causes the receiving field to be 10.8.
Specify TRUNCATED to truncate the result of the assignment statement. Low order digits are truncated on the
right as necessary when the result is moved to the receiving field. If INTEGER is used with ROUNDED, the
result is rounded to the nearest integer before the INTEGER function is performed. If INTEGER is used with
TRUNCATED (the default), then only the INTEGER function is performed.
NOTE
INTEGER, ROUNDED, and TRUNCATED are valid only with numeric fields.
"= " or EQ
Use EQ or = to indicate equivalency.
send-field-name  or send-literal  or arithmetic-expression
Send-field-name  names the field that is copied to receive-field-name .
Send-literal  contains the literal that is copied to receive-field-name .
Arithmetic-expression  contains numeric values separated by arithmetic operators (+, -, *, /). The result of the
arithmetic-expression  is placed in receive-field-name .
The logical expression format is as follows:
                   {= }                 {AND} { bit-mask-field-name }
receive-field-name  {  } send-field-name  {OR } {                   }
                   {EQ}                 {XOR} { bit-mask-literal    }
receive-field-name
Specifies the field name to which a value is to be assigned.
"= " or EQ
Use EQ or = to indicate equivalency.
send-field-name
send-field-name  names the field that is copied to receive-field-name.
 848 Easytrieve ® Report Generator 11.6
AND or OR or XOR
Specify AND, OR, or XOR:
•AND—Zero bits in bit-mask-field-name or bit-mask-literal are carried forward to send-field-name and the result
is placed in receive-field-name.
•OR—One bits in bit-mask-field-name or bit-mask-literal are carried forward to send-field-name and the result is
placed in receive-field-name.
•XOR—Corresponding bits of bit-mask-field-name or bit-mask-literal, and send-field-name must be opposite
(zero and one) to result in a one bit in receive-field-name.
bit-mask-field-name  or bit-mask-literal
Bit-mask-field-name  is the name of a field that is logically combined with send-field-name , the result of which is
carried forward to receive-field-name .
Bit-mask-literal  is a literal bit mask that is logically combined with send-field-name , the result of which is carried
forward to receive-field-name .
Examples
The following examples of the assignment statement illustrate its various rules. Example 1:  The first example
shows assignment format 1 when the receive-field-name  is alphanumeric: Format 1 (Normal Assignment)
DEFINE F1A W 4 A
DEFINE F2A1 W 1 A VALUE 'A'
DEFINE F2A2 W 6 A VALUE 'ABCDEF'
DEFINE F2N1 W 2 N VALUE 12
DEFINE F2N2 W 3 P 1 VALUE 1234.5
...
         Resulting Value
F1A = F2A1        'A '
F1A = F2A2        'ABCD'
F1A = F2N1        '0012'
F1A = F2N2        '2345'
F1A = X'FF'       X'FF404040'
NOTE
For an example using varying length alphanumeric fields, see Programming .
Example 2:  This example shows assignment format 1 when the receive-field-name  is numeric: Format 1
(Normal Assignment)
DEFINE F1N W 4 N 1
DEFINE F2N1 W 4 N 1 VALUE 1
DEFINE F2N2 W 4 N 1 VALUE 2
DEFINE F2N3 W 4 N 1 VALUE 3
JOB INPUT NULL NAME MYPROG
 F1N = F2N1 + F2N2 + F2N3
 DISPLAY SKIP 2 +
   'F1N = F2N1 + F2N2 + F2N3 = ' F1N
 F1N = F2N1 + F2N2 / F2N3
 DISPLAY SKIP 2 +
   'F1N = F2N1 + F2N2 / F2N3 = ' F1N
 F1N = (F2N1 + F2N2) / F2N3
 849 Easytrieve ® Report Generator 11.6
 DISPLAY SKIP 2 +
   'F1N = (F2N1 + F2N2) / F2N3 = ' F1N
 F1N = ((F2N1 / F2N2) * 100) + .5
 DISPLAY SKIP 2 +
   'F1N = ((F2N1 / F2N2) * 100) + .5 = ' F1N
STOP
Results:
                 Resulting
                  Value
F1N = F2N1 + F2N2 + F2N3 = 6.0
  (1 + 2 + 3)
F1N = F2N1 + F2N2 / F2N3 = 1.6
  (1 + 2 / 3)
  (1 + 0.6666)
F1N = (F2N1 + F2N2) / F2N3 = 1.0
  (( 1 + 2) / 3)
      (3 / 3)
F1N = ((F2N1 / F2N2) * 100) + .5 = 50.5
  (( 1 / 2) * 100) + .5
    ((0.5 * 100) + .5)
         (50 + .5)
Example 3  The following example illustrates the use of the INTEGER, ROUNDED, and TRUNCATED
parameters:
If:
SENDFLD W 5 N 2 VALUE(10.75)
RCVFLD W 5 N 1
Then:
Assignment Statement RCVFLD Result
RCVFLD INTEGER ROUNDED = SENDFLD 11.0
RCVFLD INTEGER TRUNCATED = SENDFLD 10.0
 850 Easytrieve ® Report Generator 11.6
RCVFLD INTEGER = SENDFLD 10.0
RCVFLD ROUNDED = SENDFLD 10.8
RCVFLD TRUNCATED = SENDFLD 10.7
RCVFLD = SENDFLD 10.7
Format 2 (Logical Expression Evaluation)  Statements:
DEFINE F1P W 2 P MASK HEX
DEFINE F2P W 2 P VALUE X'123D'
JOB INPUT NULL NAME MYPROG
 F1P = F2P AND X'FFFE'
 DISPLAY SKIP 2 +
   'F1P = F2P AND X''FFFE'' = ' F1P
 F1P = F2P OR X'000F'
 DISPLAY SKIP 2 +
   'F1P = F2P OR X''000F'' = ' F1P
 F1P = F2P XOR X'FFFF'
 DISPLAY SKIP 2 +
   'F1P = F2P XOR X''FFFF'' = ' F1P
 F1P = F2P XOR F2P
 DISPLAY SKIP 2 +
   'F1P = F2P XOR F2P = ' F1P
STOP
Results:
         Resulting
          Value
F1P = F2P AND X'FFFE' = 123C
F1P = F2P OR X'000F' = 123F
F1P = F2P XOR X'FFFF' = EDC2
F1P = F2P XOR F2P = 0000
ATTR Parameter
The ATTR parameter in  Easytrieve  assigns screen attributes to a field or literal. Use the ATTR parameter in DECLARE,
DEFAULT, ROW, and TITLE statements.
You can specify a declared screen attribute name or a list of attribute keywords. You can use the ATTR parameter in the
following statements:
 851 Easytrieve ® Report Generator 11.6
•DECLARE
•DEFAULT
•ROW
•TITLE
When used in these statements, the ATTR parameter completely overrides any site or screen default attributes. For
information about how to set default screen attributes that override site attributes, see DEFAULT Statement.
The ATTR parameter can be specified without an attribute-name  or an attribute-list  only on the DECLARE statement. This
lets a named attribute be declared and then assigned later in the program. A runtime error occurs if a named attribute is
used without any attributes assigned to it. The DEFAULT, ROW, and TITLE statements require an attribute-name  or an
attribute-list  after the ATTR keyword.
This parameter has the following format:
ATTR  [attribute -name  ]                                                
      [( attribute -list)]                                                
 attribute-list  
 
[SENDONLY] +                                                            
 
[CURSOR] +                                                            
 
[ASKIP  ] +                                                             
[PROTECT]                                                               
 
[NUMERIC] +                                                             
 
[INTENSE  ] +                                                           
[INVISIBLE]                                                             
 
[GREEN         ]                                                        
[RED           ]                                                        
[BLUE          ]                                                        
[TURQ|TURQUOISE] +                                                      
[PINK          ]                                                        
[YELLOW        ]                                                        
[BLACK         ]                                                        
[WHITE         ]                                                        
 
[MUSTFILL] +                                                            
 
[MUSTENTER] +                                                           
 
[TRIGGER] +                                                             
 
[BLINK    ]                                                             
[REVERSE  ] +                                                           
[UNDERLINE]                                                             
 
[ALARM] +                                                               
 
[BOX  ]                                                                 
[LEFT ]                                                                 
 852 Easytrieve ® Report Generator 11.6
[RIGHT]                                                                 
[UNDER]                                                                 
[OVER ] 
attribute-name
Specify a declared screen attribute name. For more information, see DECLARE Statement .
SENDONLY
The SENDONLY parameter specifies that the field is not to be received. The field is ignored if entered.
SENDONLY is implied for literals.
CURSOR
Specify CURSOR to place the cursor on this field when displayed on the terminal. If more than one field contains
the CURSOR attribute, the cursor is placed on the first field that contains CURSOR.
CURSOR is ignored for literals.
Note:  The cursor cannot be moved into a field that also contains the ASKIP, PROTECT, or SENDONLY attributes.
[ASKIP ] or [PROTECT]
ASKIP specifies that the field is an auto-skip field. PROTECT specifies that the field is protected and not auto-
skipped. If neither is specified, the field is unprotected.
ASKIP is implied for literals.
[NUMERIC]
NUMERIC specifies that only numeric data can be entered in this screen field. Use NUMERIC for permitting only
numeric data in alphanumeric fields. NUMERIC is implied for all numeric data types, and ignored for literals.
[INTENSE] or [INVISIBLE]
INTENSE specifies that the field displays brightly. INVISIBLE specifies that the field is present on the screen but is
not displayed. INVISIBLE is ignored for literals.
On 3270 extended attribute terminals, INTENSE is ignored if a color attribute is also specified.
[GREEN], [RED], [BLUE], [TURQ|TURQUOISE], [PINK], [YELLOW], or [WHITE]
The value specified is the color of the field or literal when displayed on a screen. If no color is specified, hardware
defaults apply.
[MUSTFILL]
Specify MUSTFILL to require that all spaces have a non-blank character typed into them. MUSTFILL is ignored
for literals and on terminals that do not support a mandatory-fill attribute.
[MUSTENTER]
Specify MUSTENTER to send an error message to the terminal if the field was not changed. MUSTENTER is
ignored for literals and on terminals that do not support a mandatory-enter attribute. MUSTENTER is ignored for
literals.
[TRIGGER]
TRIGGER causes the screen to be received as soon as the terminal operator has modified the field and tries to
move the cursor out of the field. TRIGGER is ignored for literals and on terminals that do not support a trigger
attribute.
[BLINK] or [REVERSE] or [UNDERLINE]
BLINK displays the item blinking. REVERSE displays the item in reverse video. UNDERLINE displays the item
underlined.
[ALARM]
ALARM causes the terminal alarm to sound. ALARM is ignored for literals.
[BOX], [LEFT], [RIGHT], [UNDER], or [OVER]
BOX specifies that field outlining displays a box surrounding the field.
LEFT specifies that field outlining displays a vertical line to the left of a field.
RIGHT specifies that field outlining displays a vertical line to the right of a field.
 853 Easytrieve ® Report Generator 11.6
UNDER specifies that field outlining displays a horizontal line below a field.
OVER specifies that field outlining displays a horizontal line above a field.
Note:  BOX, LEFT, RIGHT, UNDER, and OVER are ignored on terminals that do not support outlining attributes.
BEFORE-BREAK Report Procedure
The BEFORE-BREAK procedure  in  Easytrieve  calculates percentages and average totals. A BEFORE-BREAK
procedure is invoked before printing the summary lines for a control break.
These values must be calculated immediately before printing.
The BEFORE-BREAK procedure is invoked once for each level of break. For example, assume two control fields are
specified. When the minor field causes a control break, the BEFORE-BREAK procedure is invoked only once. When the
major field causes a control break, BEFORE-BREAK is invoked twice.
The value of LEVEL (a system-defined field) can be used to determine which control break is being processed. The value
of BREAK-LEVEL (a system-defined field) contains the number of the field causing the control break. TALLY (a system-
defined field) contains the number of records in a particular control group. For examples of LEVEL and BREAK-LEVEL,
see Programming .
NOTE
If NOPRINT is specified on a CONTROL statement, the BEFORE-BREAK procedure is still executed.
A BEFORE-BREAK procedure must be delimited by an END-PROC statement. For more information, see PROC
Statement .
This statement has the following format:
BEFORE-BREAK. PROC
Example:
Consider the following percentage calculation, paying special attention to when and how PERCENT is calculated:
Statements:
FILE FILE1 FB(80 8000)                                                  
LAST-NAME  1  5 A                                                       
STATE      6  2 A                                                       
ZIP        8  5 N                                                       
PAY-NET   13  5 N 2                                                     
*                                                                       
PERCENT    W  2 N 2                                                     
TOTAL-NET  S  8 N 2                                                     
*                                                                       
JOB INPUT FILE1 NAME MYPROG                                             
*                                                                       
  TOTAL-NET = TOTAL-NET + PAY-NET                                       
  PRINT REPORT1                                                         
*                                                                       
REPORT REPORT1 LINESIZE 80 +                                            
  SUMMARY  SUMCTL DTLCOPY                                               
  SEQUENCE STATE ZIP LAST-NAME                                          
  CONTROL  STATE ZIP                                                    
  LINE 01 LAST-NAME STATE ZIP PAY-NET PERCENT                           
 854 Easytrieve ® Report Generator 11.6
*                                                                       BEFORE-BREAK. PROC    PERCENT = PAY-
NET * 100 / TOTAL-NET  END-PROC  
Data:
BROWNIL6007612345                                                       
BROWNIL6007667890                                                       
JONESIL6007709876                                                       
JONESIL6007754321                                                       
SMITHTX7521811111                                                       
SMITHTX7521866666                                                      
Results:
LAST-NAME   STATE    ZIP     PAY-NET     PERCENT                        
                                                                        
  BROWN      IL     60076      802.35     36.10                         
  JONES      IL     60077      641.97     28.89                         
             IL               1444.32     64.99                         
                                                                        
  SMITH      TX     75218      777.77     35.00                         
             TX                777.77     35.00                         
                                                                        
                              2222.09    100.00                        
The BEFORE-BREAK procedure computes the percentage for each control break by multiplying the sum of PAY-NET by
100 and then dividing by TOTAL-NET.
NOTE
TOTAL-NET is a static (S) working storage field summed in the JOB activity processing.
BEFORE-LINE Report Procedure
The BEFORE-LINE procedure in  Easytrieve  prints a literal string before a detail line on the report or to change the
contents of the detail line before printing.
A BEFORE-LINE procedure in Easytrieve is invoked immediately before the printing of each detail line on a report. The
BEFORE-LINE procedure is invoked before each individual line in a line group. The system-defined field LINE-NUMBER
contains the number of the line in the group being processed.
A BEFORE-LINE procedure must be delimited by an END-PROC statement. For more information, see PROC Statement .
For an example, see the AFTER-LINE Report Procedure .
This statement has the following format:
BEFORE-LINE. PROC
BEFORE-SCREEN Screen Procedure
The BEFORE-SCREEN procedure in  Easytrieve  performs I/O, initializes screen fields, or sets the cursor position.
A BEFORE-SCREEN procedure is invoked before the screen activity sends the data to the terminal. It precedes building
the screen and the terminal I/O process.
 855 Easytrieve ® Report Generator 11.6
You typically use a BEFORE-SCREEN procedure to perform I/O, initialize screen fields, or set the cursor position.
GOTO SCREEN, REFRESH, and RESHOW are invalid in the BEFORE-SCREEN procedure, and in any procedure
performed by the BEFORE-SCREEN procedure.
A BEFORE-SCREEN procedure must be delimited by an END-PROC statement. For more information, see the PROC
Statement .
This statement has the following format:
BEFORE-SCREEN. PROC
Example:
SCREEN NAME SCRN1
  KEY F3 NAME 'Exit' EXIT
  KEY F8 NAME 'Forward'
. . .  BEFORE-SCREEN. PROC       GET PERSNL       IF EOF PERSNL         EXIT       END-IF    END-PROC  
CALL Statement
The CALL statement in  Easytrieve  dynamically or statically invokes subprograms written in other programming
languages.
The program being called can be either statically or dynamically bound with your  Easytrieve  program. The way that the
called program is bound is determined by the following list, in order:
1.If the program was declared on a DECLARE statement, the STATIC or DYNAMIC keyword on the DECLARE
statement determines how it is bound.
2.If specified, the CALL parameter on the PARM statement supplies the default for all called programs in your 
Easytrieve  program.
3.The default is determined by the environment. The default on the mainframe and Windows is DYNAMIC. The default
on Unix platforms is STATIC.
COBOL programs cannot be called by  Easytrieve  programs in the CICS environment. For more information, see the IBM
CICS Programmer's Reference Manual .
Any mainframe program being called in a CICS environment must execute in conversational mode. The task must not be
terminated by a called program.
For more information about subprogram linkage, see Inter-Program Linkage .
This statement has the following format:
                  [        { field-name}     ]                         
CALL program-name [USING ( {          } ...)] [RETURNS return-field]
                  [        {' literal' }     ]                        
program-name
Program-name  is the name of the subprogram that you want invoked. It is loaded into storage as part of an
activity initiation.
NOTE
The underscore character ( _) is not allowed in the program-name.
 856 Easytrieve ® Report Generator 11.6
USING {field -name } or USING {' literal '}
USING specifies the parameter list that is passed to the subprogram.
Field-name  must identify a system-defined field, a working storage field, or a field defined in an accessible file.
'Literal'  can be any alphanumeric literal that is passed to the program.
NOTE
The field-name  for the USING parameter includes only the data. It does not include the leading two-byte
length value as in the field-name  for the USING parameter used with the PROGRAM  statement.
[RETURNS return-field]
RETURNS identifies a numeric field that contains the return code passed back by a called subprogram. If the
program is calling a COBOL subprogram, the return code is the value in the COBOL RETURN-CODE field. If
the program is calling an Assembler subprogram, the return code is the value contained in register 15 on the
mainframe. If you are coding a C subprogram, the return code is the value returned from the function.
Return-field  is a numeric  Easytrieve  field that contains the returned value. The field can be a user-defined field or
you can use the system-defined field, RETURN-CODE, to pass the return code to the operating system.
Examples
The first example shows a CALL statement without parameters; the second shows one with parameters:
CALL ASMPGM
CALL ASMPGM USING ('USERFIL', USERFLD)
CASE and END-CASE Statements
The CASE and END-CASE statements in  Easytrieve  conditionally execute one of several alternative groups of
statements based on the value of a specific field.
A CASE statement can be nested within a CASE statement. Other conditional execution statements can also be nested
within a CASE statement. A CASE statement can be nested within any other conditional execution statement.
This statement has the following format:
CASE   field-name                                                       
                                                                        
  WHEN compare-literal-1 [THRU range-literal-1]  [...]                  
    statement -1                                                         
                                                                        
  WHEN compare-literal-n [THRU range-literal-n]  [...]                  
    statement -n                                                         
                                                                        
  [OTHERWISE      ]                                                     
  [  statement -n+1]                                                     
                                                                        
END-CASE                                                               
The following diagram illustrates CASE statement logic:
 857 Easytrieve ® Report Generator 11.6
field-name
Field-name  specifies a field that contains a value that is compared to the values represented by compare-literal
[THRU range-literal ].
Field-name  can be a field of any type. If field-name  is numeric, it must have zero or no decimal places.
WHEN
You can specify as many WHEN conditions as necessary. At least one WHEN condition is required. You cannot
code statements between CASE and the first WHEN condition. You must supply a unique set of values to be
compared with field-name  in each WHEN condition.
compare-literal [THRU range-literal]
Compare-literal  is the value to be compared with field-name . You can specify a single literal, a series of literals, or
a range of literals. A range is represented by compare-literal  THRU range-literal . A range is satisfied when field-
name  is greater than or equal to the lesser of compare-literal  and range-literal  and is less than or equal to the
greater of compare-literal  and range-literal .
When field-name  is alphanumeric, compare-literal  and range-literal  must also be alphanumeric. The comparison
is based on the greater of the length of field-name  and compare-literal  or range-literal . The shorter field is padded
with spaces to equal the length of the longer field.
When field-name  is numeric, compare-literal  and range-literal  must also be numeric and must not have any
decimal places.
 858 Easytrieve ® Report Generator 11.6
The set of literal values that are specified for a given WHEN, including the unspecified values that are implied by a
range, must be unique as compared to the literal values of any other WHEN for the same CASE.
statement-1 to statement-n
Statement-1  and statement-n  represent any number of  Easytrieve  statements that are executed when the
WHEN comparison is satisfied. Whenever one or more of these statements is a CASE statement, the CASE
statements are considered to be nested.
OTHERWISE
OTHERWISE is an optional statement that specifies a group of statements to be executed if no WHEN
comparison was satisfied. If OTHERWISE is not specified and field-name does not equal any of the specified
WHEN conditions, execution continues with the statement following END-CASE.
statement-n+1
Statement-n+1  represents any number of  Easytrieve  statements that are executed when no WHEN comparisons
are equal. Whenever one or more of these statements is a CASE statement, the CASE statements are
considered to be nested.
END-CASE
END-CASE terminates the body of the CASE statement. END-CASE must be specified after each CASE
statement and its associated statements.
Example:
The following example uses CASE to analyze the data to select employees' years of service that fall into a range
(identified by the WHEN statement) and, as a result, display 'ONE WEEK VACATION' or 'TWO WEEKS VACATION', or for
all other cases, display 'THREE WEEKS VACATION'.
FILE EMPLOYEE
EMPYRS   5    2   N
...
 CASE EMPYRS
  WHEN 0 THRU 4 
    DISPLAY 'ONE WEEK VACATION'
  WHEN 5 THRU 10
    DISPLAY 'TWO WEEKS VACATION'
  OTHERWISE
    DISPLAY 'THREE WEEKS VACATION' END-CASE
...
CLOSE Statement
The CLOSE statement in  Easytrieve  closes a file.
At the termination of each activity, all files that were opened during the activity are automatically closed. You can use the
CLOSE statement to close the file before the activity terminates. The next I/O statement using the file reopens the file.
You can also close an SQL file with the CLOSE statement so that a new cursor can be created. For more information, see
SQL Database Processing .
Note: You cannot use the CLOSE statement to close a printer file or to close an automatic input or output file. Virtual files
without RETAIN are deleted when closed. CLOSE has no effect on IDMS files.
This statement has the following format:
 859 Easytrieve ® Report Generator 11.6
CLOSE file-name  
file-name
File-name  specifies the file to be closed.
Example
CLOSE FILEA
COMMIT Statement
The COMMIT statement in  Easytrieve  establishes a logical unit of work.
The COMMIT statement establishes the end of the current logical unit of work and the beginning of the next.
The COMMIT statement establishes a recovery point for updates. The ROLLBACK statement can then be used to recover
any recoverable actions since the last COMMIT. (The operating environment determines which actions are recoverable.
For more information, see Control Program Flow .)
COMMIT terminates any active holds on files. All open SQL cursors are closed and all updates to databases are
committed.
NOTE
Cursors defined with the HOLD option (DB2 only) are not closed.
This statement has the following format:
COMMIT
Example:
WRITE PERSNL ADD
. . .
 IF . . .  COMMIT
  ELSE
     ROLLBACK
END-IF
Conditional Expressions
Conditional expressions in  Easytrieve  are specified through IF and DO statements to offer an alternative to the normal
top-to-bottom execution of statements.
Easytrieve  accepts seven different conditions: Field Relational, Field Series, Field Class, Field Bits, File Presence, File
Relational, Record Relational.
This statement has the following format:
{IF       }             [ {AND}           ]                              
{DO WHILE }   condition [ {   }  condition ]...                           
{DO UNTIL }             [ {OR }           ]                             
Examples:
 860 Easytrieve ® Report Generator 11.6
The following list provides skeletal examples of each type of conditional expression that is used in an IF statement:
Type Example
Field Relational IF field-1 = field-2
Field Series IF field-1 = field-2, field-3, field-4
Field Class IF field-1 ALPHABETIC
Field Bits IF field-1 ON X'0F4000
File Presence IF EOF file-name
File Relational IF MATCHED file-1, file-2, file-3
Record Relational IF DUPLICATE file-name
Field Bits Condition
The field bits condition in  Easytrieve  compares selected bits of a field for on (1) or off (0) conditions.
This statement has the following format:
                           Relational                                   
                Subject     Operator    Object                          
                                                                        
{IF      }                    {ON } { field-name-2}                      
{DO WHILE} field-name-1 [NOT] {   } {            }                      
{DO UNTIL}                    {OFF} { literal     }                     
Subject
Field-name-1  is the subject of the comparison. It can be any field type. The NOT parameter indicates the
condition test is reversed.
Relational Operator
The relational operators ON and OFF test for bit values of one or zero respectively.
Object
Field-name-2  or a literal  identifies the bit mask to be tested.  Easytrieve  tests only those bits that correspond to
one (1) bits in the mask. The length of the object must equal the length of the subject. When you code a literal as
the object, it must be a hexadecimal literal. Indicate a hexadecimal literal by preceding it with an X and enclosing
it in single quotes.
If the subject is a VARYING field, the object must be equal to the length of the data portion of the subject. The test
is performed based on the actual length of the subject. The object cannot be a VARYING field.
Example:
This example illustrates the use of the field bits condition:
DEFINE FIELD-1    W 1  B VALUE X'20'                                    
DEFINE FIELD-NUM  W 4  B VALUE X'FF00FF00'                              
DEFINE PATTERN-8  W 1  B VALUE X'80'                                    
DEFINE LOWER-CASE W 1  A VALUE X'81'                                    
*                                                                       
JOB INPUT NULL NAME MYPROG                                                 IF FIELD-1 ON PATTERN-8            
                                  
      DISPLAY 'PERFORM CODE FOR PATTERN 8'                              
 861 Easytrieve ® Report Generator 11.6
   END-IF                                                                  IF LOWER-CASE OFF X'40'            
                                  
      DISPLAY 'THIS LETTER IS LOWER CASE'                               
   END-IF                                                                  IF FIELD-NUM  ON X'FF000000'       
                                  
      DISPLAY '1ST BYTE HIGH VALUES'                                    
   END-IF                                                               
STOP                                                                   
Field Class Condition
Review which conditions are determined by the field class condition in  Easytrieve .
The field class condition determines whether:
•All positions of a field contain alphabetic, numeric, space, or zero characters.
•A nullable field is null.
•The cursor is in a specific field on the screen.
•A field was modified by the terminal user.
•A field is active in a control break of the current report.
This statement has the following format:
               Subject          Object                                  
                                                                        
                             {ALPHABETIC   }                            
                             {BREAK        }                            
                             {CURSOR       }                            
                             {HIGHEST-BREAK}                            
{IF       }                  {MODIFIED     }                            
{DO UNTIL } field-name [NOT] {NULL         }                            
{DO WHILE }                  {NUMERIC      }                            
                             {SPACE        }                            
                             {SPACES       }                            
                             {ZERO         }                            
                             {ZEROS        }                            
                             {ZEROES       }
                             {HIGH-VALUES  }
                             {LOW-VALUES   }
Subject
Field-name  is the subject of the comparison. Each byte of the field must pass the test before the test is true. The
NOT parameter indicates that the condition test is reversed.
Field-name  can be indexed or subscripted.
Object
The object determines the class of data to be tested for.
{ALPHABETIC}
ALPHABETIC tests for the upper-case characters A to Z or a blank space in each byte of the subject field.
 862 Easytrieve ® Report Generator 11.6
{BREAK}
BREAK tests whether this field is currently being processed as a CONTROL break field on a report. The BREAK
test is an alternative to testing the field-name  LEVEL for a specific numeric value. Field-name  must be defined on
a CONTROL statement or it must be the reserved word FINAL.
{CURSOR}
CURSOR tests whether the cursor is in the specified field on the screen. CURSOR can be used only in screen
activity procedures.
If CURSOR is used, the condition must refer to a field on a ROW statement within the screen declaration.
NOTE
Results are unpredictable if:
•Field-name  contains the ASKIP, PROTECT, or SENDONLY attributes.
•Field-name  occurs more than once in a screen.
•Two screen fields redefine the same storage area and one of the fields is used in an IF test.
•The subject is indexed or subscripted and the value of the index or subscript has changed since the
screen was received.
•The test is performed after the user presses CLEAR, PA1, PA2, or PA3.
{HIGHEST-BREAK}
HIGHEST-BREAK tests whether this field caused the CONTROL break on a report. The HIGHEST-BREAK test is
an alternative to testing the field-name  BREAK-LEVEL for a specific numeric value. Field-name must be defined
on a CONTROL statement or it must be the reserved word FINAL.
{MODIFIED}
MODIFIED tests whether the terminal operator changed the data in the field. The field is considered MODIFIED
only if the contents of the field upon receipt of the screen do not equal the contents of the screen at the time the
screen is displayed.
MODIFIED can be used only in screen activity procedures.
If MODIFIED is used, the condition must refer to a field on a ROW statement within the screen declaration.
NOTE
Results are unpredictable if:
•Field-name  occurs more than once in a screen.
•Two screen fields redefine the same storage area and one of the fields is used in an IF test.
•The subject is indexed or subscripted and the value of the index or subscript has changed since the
screen was received.
•The test is performed after the user presses CLEAR, PA1, PA2, or PA3.
{NULL}
NULL tests whether a nullable field is NULL.
{NUMERIC}
NUMERIC tests for the digits 0 to 9 (in the correct format for the field's data type), and for a possible algebraic
sign in the low-order position of type-P fields or in the high-order position of type-N fields.
{SPACE}
SPACE and SPACES test for the character space in each byte of single-byte subjects.
{ZERO}
ZERO, ZEROS, and ZEROES test for the digit 0 (in the correct format for the field's data type), and for a possible
algebraic sign in the low-order position of type-P fields or in the high-order position of type-N fields.
 863 Easytrieve ® Report Generator 11.6
{HIGH-VALUES}
HIGH-VALUES tests for the character X'FF' in each byte of single-byte and MIXED format subjects and in each
double byte of DBCS subjects.
{LOW-VALUES}
LOW-VALUES tests for the character X'00' in each byte of single-byte and MIXED format subjects and in each
double byte of DBCS subjects.
Example
This example illustrates the use of the field class condition:
FILE PERSNL FB(150 1800)                                                
REGION           1    1 N                                               
BRANCH           2    2 N                                               
EMPNAME         17   20 A                                               
  NAME-LAST  EMPNAME     8 A                                            
  NAME-FIRST EMPNAME +8 12 A                                            
*                                                                       
TOTAL-NUMERIC       W 3  N VALUE 0                                      
TOTAL-NON-ZEROS     W 3  N VALUE 0                                      
TOTAL-ALPHABETIC    W 3  N VALUE 0                                      
*                                                                       
JOB INPUT PERSNL NAME MYPROG FINISH FINISH-PROC                          IF REGION NUMERIC 
     TOTAL-NUMERIC = TOTAL-NUMERIC + 1                                  
   END-IF                                                                IF BRANCH NOT ZERO 
     TOTAL-NON-ZEROS = TOTAL-NON-ZEROS + 1                              
   END-IF                                                                IF EMPNAME ALPHABETIC 
     TOTAL-ALPHABETIC = TOTAL-ALPHABETIC + 1                            
   END-IF                                                               
*                                                                       
FINISH-PROC. PROC                                                       
   DISPLAY TOTAL-NUMERIC                                                
   DISPLAY TOTAL-NON-ZEROS                                              
   DISPLAY TOTAL-ALPHABETIC                                             
END-PROC
Field Relational Condition
The field relational condition in  Easytrieve  compares fields with values.
This statement has the following format:
                           Relational                                   
              Subject       Operator        Object                      
                                                                        
{IF      }                {EQ|=        }                                 
{ELSE-IF }                {NE|Ø=|NQ    }  { field-name-2          }       
{        }  field-name-1  {LT|< |LS    }  { literal               }       
{DO WHILE}                {LE|<=|LQ|Ø> }  { arithmetic -expression  }       
 864 Easytrieve ® Report Generator 11.6
{DO UNTIL}                {GT|> |GR    }                                 
                          {GE|>=|GQ|Ø< }                                
Subject
Field-name-1  is the subject of the comparison.
Relational Operator
Code  any of the relational operators to control the condition's evaluation process.
Object Code
Code field-name-2 , a literal , or an arithmetic-expression  designates the object of the comparison.
NOTE
Alphanumeric literals must be enclosed within single quotes. For information about how Easytrieve
evaluates arithmetic expressions, see Assignments and Moves  in the Programming  section.
Alphanumeric Subjects
When the condition subject is an alphanumeric field, the following evaluation rules apply:
•The object must be either a field or an alphanumeric literal.
•If necessary, numeric field objects are converted to zoned decimal. Comparison of VARYING alphanumeric fields with
numeric fields is not permitted.
•The comparison is based on the greater of the length of the subject and the length of the object. The shorter item is
padded with spaces to the length of the longer item. For downward compatibility with existing Easytrieve  programs, this
rule is subject to the following exception:
–When a fixed length subject is compared with a longer fixed length object, the comparison is based on the length of
the subject.
–The object is truncated to match the length of the subject. The compiler then generates a warning message.
•Comparison is logical (bit-by-bit).
•Comparisons of varying length fields (fields which use the VARYING option of the DEFINE statement) are based on
the length of the data at the time of the comparison.
Numeric Subjects
When the condition subject is a numeric field, the following evaluation rules apply:
•The object must be a numeric field, a numeric literal, or an arithmetic expression.
•Comparison is arithmetic.
Mixed Subjects
When the condition subject is a MIXED field, the following evaluation rules apply:
 865 Easytrieve ® Report Generator 11.6
•Easytrieve  supports only equal (EQ =) and not equal (NE Ø=  NQ) conditions. If you use any of the other conditional
operators, an error occurs.
•The object must be a field, an alphanumeric literal, a MIXED literal, or a DBCS literal.
•A conversion is not performed if the object is an EBCDIC alphanumeric field or literal.
•If the object is a MIXED field or literal, the DBCS portion of data is converted into the DBCS code system of the
subject.  Easytrieve  also converts the shift codes to the values defined for the DBCS code system of the subject in the
DBCS Options module.
•If the object is a DBCS field or literal, the data is converted into the DBCS code system of the subject. When this
conversion occurs, the shift codes defined for the code system of the subject are added to the data.
•Numeric field objects are converted to zoned decimal (if necessary).
•To match the length of the subject, Easytrieve  truncates or pads the object. Padding uses the single-byte space
character. During truncation, no DBCS character is split. When truncation occurs within the DBCS portion of a field, the
truncation is adjusted to the nearest double byte boundary.
•Comparison is logical (bit-by-bit).
DBCS Subjects
When the condition subject is a DBCS field, the following evaluation rules apply:
•Easytrieve  supports only equal (EQ =) and not equal (NE Ø=  NQ) conditions. If you use any of the other conditional
operators, an error occurs.
•The object must be a field, an alphanumeric literal, a MIXED literal, or a DBCS literal.
•If the object is an EBCDIC alphanumeric field or literal, then each character is converted into the DBCS code system of
field-name-1 .
•If the object is a MIXED field or literal, the DBCS portion of data is converted into the DBCS code system of the
subject.  Easytrieve  also converts the EBCDIC portion of data to its equivalent DBCS value based on the code system
of the subject. Shift codes are removed.
•If the object is a DBCS field or literal, the data is converted into the DBCS code system of the subject.
•If necessary, numeric field objects are converted to zoned decimal and then converts the EBCDIC result into the
equivalent DBCS characters based on the code system of field-name-1 .
•To match the length of the subject, Easytrieve  truncates or pads the object. Padding uses the DBCS space character.
•Comparison is logical (bit-by-bit).
Example:
This example illustrates various field relational conditions:
FILE PERSNL FB(150 1800)                                                
  EMP#             9    5  N                                            
  EMPNAME         17   20  A                                            
    NAME-LAST  EMPNAME     8  A                                         
    NAME-FIRST EMPNAME +8 12  A                                         
  PAY-NET         90    4  P 2                                          
  PAY-GROSS       94    4  P 2                                          
  SEX            127    1  N                                            
TOTAL-EMP#         W    3  N VALUE 0                                    
TOTAL-SEX          W    3  N VALUE 0                                    
TOTAL-PAY          W    3  N VALUE 0                                    
TOTAL-FIRST-NAME   W    3  N VALUE 0                                    
MALE               W    1  N VALUE 1                                    
JOB INPUT PERSNL NAME MYPROG FINISH FINISH-PROC                          IF EMP# GT 10000 
     TOTAL-EMP# = TOTAL-EMP# + 1                                        
 866 Easytrieve ® Report Generator 11.6
   END-IF                                                                IF SEX NE MALE 
     TOTAL-SEX = TOTAL-SEX + 1                                          
   END-IF                                                                IF PAY-NET LT (PAY-GROSS / 2) 
     TOTAL-PAY = TOTAL-PAY + 1                                          
   END-IF                                                                IF NAME-FIRST EQ 'LINDA' 
     TOTAL-FIRST-NAME = TOTAL-FIRST-NAME + 1                            
   END-IF                                                               
*                                                                       
FINISH-PROC. PROC                                                       
   DISPLAY TOTAL-EMP#                                                   
   DISPLAY TOTAL-SEX                                                    
   DISPLAY TOTAL-PAY                                                    
   DISPLAY TOTAL-FIRST-NAME                                             
END-PROC                                                               
Field Series Condition
The field series condition in  Easytrieve  compares a field to a series or a range of values.
Evaluation rules for field series conditions are as follows:
•Alphanumeric (including DBCS and MIXED format fields) and numeric fields are evaluated as in the field relational
condition.
•An equal (=) relational operator tests if the subject is equal to or within range of any of the series of values comprising
the object.
•A not equal (Ø=) relational operator tests if the subject is unequal to or outside the range of all the series of values
comprising the object.
NOTE
A comparison within a range is satisfied if the subject is greater than the lesser of the two range values and the
subject is less than the greater of the two range values.
This statement has the following format:
                             Relational                                 
               Subject        Operator                                  
                                                                        
{IF       }                                                             
{ELSE-IF  }                {EQ | =       }                              
{         }  field-name-1  {             } +                            
{DO WHILE }                {NE | Ø= | NQ}                               
{DO UNTIL }                                                             
                                                                        
   Object                                                               
                                                                        
{field-name-2  [     { field-name-3  } ]   }                             
{              [THRU {              } ]...}                             
{literal-1     [     { literal-2     } ]   }                            
 867 Easytrieve ® Report Generator 11.6
Subject
Field-name-1  is the subject of the comparison.
Relational Operator
Equal  and notequal  are the only valid relational operators for field series conditions.
Object
Code field-name-2  or a literal-1  as often as you need to indicate the series of comparison objects. Field-name-2
THRU field-name-3 , field-name-2  THRU literal-2 , literal-1  THRU field-name-3 , or literal-1  THRU literal-2  designate
a value range.
Note:  Alphanumeric literals must be enclosed within single quotes.
Example:
This example illustrates the field series condition:
FILE PERSNL FB(150 1800)                                                
REGION           1 1 N                                                  
BRANCH           2 2 N                                                  
DEPT            98 3 N                                                  
MARITAL-STAT   128 1 A                                                  
*                                                                       
TOTAL-REGION     W 3 N VALUE 0                                          
TOTAL-BRANCH     W 3 N VALUE 0                                          
TOTAL-DEPT       W 3 N VALUE 0                                          
TOTAL-MARITAL    W 3 N VALUE 0                                          
WORK-REGION      W 2 N VALUE 04                                         
*                                                                       
JOB INPUT PERSNL NAME MYPROG FINISH FINISH-PROC                            IF REGION = 0, 8, 9                
                                  
     TOTAL-REGION = TOTAL-REGION + 1                                    
   END-IF                                                                  IF BRANCH NE 01, WORK-REGION       
                                  
     TOTAL-BRANCH = TOTAL-BRANCH + 1                                    
   END-IF                                                                  IF DEPT EQ 940 THRU 950            
                                  
     TOTAL-DEPT = TOTAL-DEPT + 1                                        
   END-IF                                                                  IF MARITAL-STAT NE 'M', 'S'        
                                  
     TOTAL-MARITAL = TOTAL-MARITAL + 1                                  
   END-IF                                                               
*                                                                       
FINISH-PROC. PROC                                                       
   DISPLAY TOTAL-REGION                                                 
   DISPLAY TOTAL-BRANCH                                                 
   DISPLAY TOTAL-DEPT                                                   
   DISPLAY TOTAL-MARITAL                                                
END-PROC                                                                
 868 Easytrieve ® Report Generator 11.6
File Presence Condition
The file presence condition in  Easytrieve  determines whether a record of the file is currently available for processing.
The object of the test is simply the availability of the record for processing. The file is available if the last GET or READ
operation was successful and there is a record that can be accessed.
NOTE
Results are unpredictable if data in a file is referenced after any output operation.
The optional EOF parameter causes the test to be true when the subject is at end-of-file. This test can never be true for
automatic input files.
The optional NOT parameter reverses the condition test.
For more information about file presence conditions, see the   Easytrieve  Programming Documentation .
This statement has the following format:
                          Subject                                       
                                                                        
{IF      }                                                              
{DO WHILE} [NOT]  [EOF] { file-name}                                     
{DO UNTIL}                                                             
Subject
File-name  designates the subject of the test.
Example 1
This example illustrates the use of the file presence condition:
FILE PERSNL INDEXED                                                     
%PERSNL                                                                 
*                                                                       
JOB INPUT NULL NAME MYPROG                                              
  READ PERSNL KEY '00970' STATUS                                          IF NOT PERSNL                       
                                  
    DISPLAY '00970 NOT ON FILE'                                         
  ELSE                                                                  
    DISPLAY EMPNAME                                                     
  END-IF                                                                
  STOP                                                                 
Example 2
This example illustrates the use of the file presence condition in synchronized file processing:
FILE PERSNL FB(150 1800)                                                
%PERSNL                                                                 
FILE INVENT FB(200 3200)                                                
%INVMSTR                                                                
FILE SORT1  FB(150 1800) VIRTUAL                                        
COPY PERSNL                                                             
FILE SORT2  FB(200 3200) VIRTUAL                                        
COPY INVENT                                                             
 869 Easytrieve ® Report Generator 11.6
COUNT-1        W 3 N VALUE 0                                            
COUNT-2        W 3 N VALUE 0                                            
*                                                                       
SORT PERSNL TO SORT1 USING (ADDR-STATE) NAME MYSORT1                    
SORT INVENT TO SORT2 USING (LOCATION-STATE) NAME MYSORT2                
*                                                                       
JOB INPUT (SORT1 KEY (ADDR-STATE), +                                    
           SORT2 KEY (LOCATION-STATE)) +                                
   NAME MYPROG FINISH FINISH-PROC                                          IF EOF SORT2                       
                                  
     DISPLAY 'EOF ON SECONDARY'                                         
     STOP                                                               
   END-IF                                                                  IF NOT PRIMARY                     
                                  
     DISPLAY 'NO PERSONNEL RECORD- ' LOCATION-STATE                     
   END-IF                                                                  IF NOT SECONDARY                   
                                  
     DISPLAY 'NO INVENTORY RECORD- ' ADDR-STATE                         
   END-IF                                                                  IF SORT1                           
                                  
* HOW MANY PERSONNEL RECORDS RETURNED                                   
     COUNT-1 = COUNT-1 + 1                                              
   END-IF                                                                  IF SORT2                           
                                  
* HOW MANY INVENT RECORDS RETURNED                                      
     COUNT-2 = COUNT-2 + 1                                              
   END-IF                                                               
*                                                                       
FINISH-PROC. PROC                                                       
   DISPLAY COUNT-1                                                      
   DISPLAY COUNT-2                                                      
END-PROC                                                               
File Relational Condition
The file relational condition in  Easytrieve  determines file presence and record matching for more than one file in JOBs
with synchronized file input.
This statement has the following format:
                   Subject                                              
                                                                        
                 [ file-name]                                            
IF [NOT] MATCHED [PRIMARY  ] ...                                        
                 [SECONDARY]                                           
 870 Easytrieve ® Report Generator 11.6
Subject
The optional file-name , PRIMARY, and SECONDARY parameters identify the files to be tested. If you do not code
this parameter, the condition is true only if all input files have matching records.
The optional NOT parameter reverses the condition test.
Example:
This example illustrates the use of the file relational condition:
FILE PERSNL FB(150 1800)                                                
%PERSNL                                                                 
FILE INVENT FB(200 3200)                                                
%INVMSTR                                                                
FILE SORT1  F(150) VIRTUAL                                              
COPY PERSNL                                                             
FILE SORT2  F(200) VIRTUAL                                              
COPY INVENT                                                             
COUNT-1     W 3 N VALUE 0                                               
*                                                                       
SORT PERSNL TO SORT1 USING (ADDR-STATE)     NAME MYSORT1                
SORT INVENT TO SORT2 USING (LOCATION-STATE) NAME MYSORT2                
*                                                                       
JOB INPUT (SORT1 KEY (ADDR-STATE), +                                    
           SORT2 KEY (LOCATION-STATE)) +                                
   NAME MYPROG FINISH FINISH-PROC                                          IF MATCHED                         
                                  
     COUNT-1 = COUNT-1 + 1                                              
   END-IF                                                               
*                                                                       
FINISH-PROC. PROC                                                       
   DISPLAY COUNT-1                                                      
END-PROC
Record Relational Condition
The record relational condition in  Easytrieve  determines the relationship of the current record of a file to the previous and
next records of the same file.
This test is valid only for synchronized file processing and single file keyed processing.
This statement has the following format:
                       Subject                                          
                                                                        
         {DUPLICATE} { file-name}                                        
IF [NOT] {FIRST-DUP} {PRIMARY  }                                        
         {LAST-DUP } {SECONDARY}                                       
{DUPLICATE}
DUPLICATE is true when the previous or next record has the same key as the current record.
{FIRST-DUP}
FIRST-DUP is true for the first of two or more records with the same key.
 871 Easytrieve ® Report Generator 11.6
{LAST-DUP}
LAST-DUP is true for the last of two or more records with the same key.
Subject
The file-name , PRIMARY, and SECONDARY parameters identify the file to be tested.
The optional NOT parameter reverses the condition.
Example:
This example illustrates the use of the record relational condition:
FILE PERSNL FB(150 1800)                                                
%PERSNL                                                                 
FILE INVENT FB(200 3200)                                                
%INVMSTR                                                                
FILE SORT1  FB(150 1800) VIRTUAL                                        
COPY PERSNL                                                             
FILE SORT2  FB(200 3200) VIRTUAL                                        
COPY INVENT                                                             
COUNT-1     W 3 N VALUE 0                                               
COUNT-2     W 3 N VALUE 0                                               
*                                                                       
SORT PERSNL TO SORT1 USING (ADDR-STATE) NAME MYSORT1                    
SORT INVENT TO SORT2 USING (LOCATION-STATE) NAME MYSORT2                
*                                                                       
JOB INPUT (SORT1 KEY (ADDR-STATE) +                                     
           SORT2 KEY (LOCATION-STATE)) +                                
   NAME MYPROG FINISH FINISH-PROC                                          IF DUPLICATE PRIMARY               
                                  
     COUNT-1 = COUNT-1 + 1                                              
   END-IF                                                                  IF DUPLICATE SORT2                 
                                  
     COUNT-2 = COUNT-2 + 1                                              
   END-IF                                                               
*                                                                       
FINISH-PROC. PROC                                                       
   DISPLAY COUNT-1                                                      
   DISPLAY COUNT-2                                                      
END-PROC                                                               
CONTROL Statement
The CONTROL statement in  Easytrieve  identifies control fields used for a report.
A control break occurs whenever the value of any control field changes or end-of-report occurs. The control break at end-
of-report is equivalent to the final break. A break level is also assigned to each control field. Comparison of control fields is
a logical compare.
You can specify one or more control breaks. If you do not specify any control breaks, a FINAL break is implied.
A break level is assigned to each control field. The system-defined field LEVEL contains the break level used in the
BEFORE-BREAK and AFTER-BREAK report procedures. LEVEL can have the following values:
 872 Easytrieve ® Report Generator 11.6
•1 when processing the minor field break
•The number of control fields ( n) when processing the major field break
•The number of control fields plus one ( n+1) when processing the FINAL control break
The system-defined field BREAK-LEVEL contains the break level of the highest field to break.
An alternative to testing the LEVEL and BREAK-LEVEL fields is to use the IF BREAK and IF HIGHEST-BREAK tests.
Coding IF BREAK field-name  is equivalent to coding IF LEVEL = x, where x is the break level assigned to field-name.
IF HIGHEST-BREAK performs the same function against the BREAK-LEVEL field. IF BREAK and IF HIGHEST-BREAK
have the advantage of dynamically changing the LEVEL value if fields are added to or removed from the CONTROL
statement.
Control fields are compared logically, rather than bit-by-bit. For example, packed fields containing zero with a C sign are
logically equal to zero with an F sign.
In an XML-formatted report, the CONTROL fields represent the hierarchy in the XML output file and all other CONTROL
statement parameters are ignored.
For detailed examples of the CONTROL statement, see Report Processing .
This statement has the following format:
        [ field-name ] [NEWPAGE]
CONTROL [          ] [       ] [NOPRINT]...
        [FINAL     ] [RENUM  ]
[field-name ] or [FINAL]
Prior to the first field-name, you can code FINAL to specify options for the control break at end-of-report. Field-
name specifies any non-quantitative field located in an active file or in a W-type working storage field.
Specify control fields in major to minor order.
NOTE
Varying length, K (DBCS/Kanji), and M (MIXED) fields cannot be specified on a CONTROL statement.
The following three options alter normal processing of a control break:
[NEWPAGE]
NEWPAGE causes a skip to top-of-page after control break processing is complete for the specified field.
[RENUM]
RENUM performs the same function as NEWPAGE, and also resets the page number to 1 on the page following
the control break.
[NOPRINT]
NOPRINT suppresses printing the summary line group for the specified control break. All other control break
processing for the specified control break is performed as usual.
Example
CONTROL FINAL NEWPAGE REGION NEWPAGE BRANCH DEPT
COPY Statement
The COPY statement in  Easytrieve  duplicates the field definitions of a named file.
You can code an unlimited number of COPY statements for any one file.  Easytrieve  duplicates the fields as if they were
coded at the place where  Easytrieve  encounters the COPY statement.
 873 Easytrieve ® Report Generator 11.6
The same rules of field definition apply when using the COPY statement (that is, field names must be unique in a given
file).
This statement has the following format:
     {file-name                       }                                 
COPY {                                }                                 
     {[database -file-name]:record-name}                                
file-name
File-name  is the name of a previously-defined file whose fields you want to duplicate.
[database-file-name]:record-name
Record-name  is the name of a previously-defined database record whose fields you want to duplicate. Optionally,
code database-file-name  for qualification.
Example 1
The following is a COPY statement example:
FILE PERSNL  FB(150 1800)                                               
  EMPNAME         17   20 A     HEADING ('EMPLOYEE NAME')               
    NAME-LAST  EMPNAME     8 A     HEADING ('LAST' 'NAME')              
    NAME-FIRST EMPNAME +8 12 A     HEADING ('FIRST' 'NAME')             
FILE SORTWRK FB(150 1800)   VIRTUAL                                     COPY PERSNL                           
                                  
SORT PERSNL TO SORTWRK USING +                                          
    (NAME-LAST NAME-FIRST) NAME MYSORT                                  
JOB INPUT SORTWRK NAME MYPROG                                           
   PRINT REPORT1                                                        
*                                                                       
REPORT REPORT1                                                          
LINE NAME-FIRST NAME-LAST                                              
Example 2
This example shows a COPY with IDMS:
FILE DBASE IDMS(DEMOSS03)
 RECORD CUSTOMER 104 KEY(CUST-NO)
  CUST-NO      1 10 A
  CUST-NAME   11 20 A
RECORD SALES   28
  SLS-CUST-NO  1 10 A
FILE DDBASE FB(28 280)  COPY SALES               (fields from RECORD SALES copied)
 JOB INPUT (DNASE) NAME MYPROG
   RETRIEVE DBASE +
     SELECT (CUSTOMER AREA 'CUSTOMER-REGION' +
             SALES    ID   'SA' SET 'CUSTOMER-SALES')
   IF PATH-ID EQ 'SA'
     MOVE LIKE SALES TO DDBASE
     PUT DDBASE
 874 Easytrieve ® Report Generator 11.6
   ELSE
     GO TO JOB
   END-IF
CURSOR Statement
The CURSOR statement in  Easytrieve  within a screen procedure sets the initial position of the cursor in a field for the
next display of the screen.
You can use the CURSOR statement only within screen procedures (AFTER-SCREEN, BEFORE-SCREEN, INITIATION,
TERMINATION), or within any procedure performed from a screen procedure.
The CURSOR statement must refer to a field on a ROW statement within the screen declaration.
NOTE
Results are unpredictable if:
•Field-name  contains the ASKIP, PROTECT, or SENDONLY attributes
•Field-name  occurs more than once in a screen
•Two screen fields redefine the same storage area and one is used in the CURSOR statement
Field-name  can be subscripted or indexed. However, if the value of the subscript or index changes between the time the
CURSOR statement is executed and the time the screen is actually displayed, the CURSOR positioning is ignored. The
CURSOR statement:
•Overrides cursor placement if a screen field contains the CURSOR attribute.
•Can be executed any number of times before displaying the screen. The last CURSOR statement executed
determines the cursor placement.
•Cannot be moved into an auto-skip (ASKIP) field.
For information about cursor placement hierarchy, see the Programming  section.
This statement has the following format:
CURSOR AT field-name 
field-name
Field-name  refers to a field on a ROW statement within the screen declaration.
Example:
SCREEN NAME SCRN1
  ROW 3 WORK-DESCRIPTION
  ROW 5 EMP#
. . .
  BEFORE-SCREEN. PROC  CURSOR AT EMP#
  END-PROC
DECLARE Statement
The DECLARE statement in  Easytrieve  declares named screen attributes and input edit patterns, and specifies how a
subprogram is linked.
Using declared attributes lets you dynamically change screen attributes during program execution. Using declared
attributes and edit patterns saves you coding time when the set of attributes or edit patterns are used many times.
 875 Easytrieve ® Report Generator 11.6
An attribute field can be assigned to another attribute field. Patterns and programs cannot be assigned.
Other than the assignment, declared screen attributes can be used only on DEFAULT, TITLE, and ROW statements.
Attributes can also be dynamically changed using the SET statement.
This statement has the following format:
             {ATTR [( attribute -list)] } 
DECLARE name {PATTERN ' pattern'       } 
             {PROGRAM {STATIC|DYNAMIC}}
name
Specify a name  up to 128 characters for the set of declared screen attributes or set of declared pattern
characters.
ATTR [(attribute-list )]
Specify a list of attribute values. The attribute list must be enclosed in parentheses. For a list and explanations of
valid attributes, see ATTR Parameter.
PATTERN 'pattern '
PATTERN lets you specify a sequence of characters that describe the format of the data in the field. The
character string must be enclosed in single quotes.
Note:  Use PATTERN to edit complex combinations of data types and character sequences. Use the MASK
parameter to edit numeric data.
The valid pattern characters and their meanings are listed in the following table:
Character Meaning
A Represents a lowercase or an uppercase letter.
B Represents a single blank.
D Represents a digit.
E Represents an empty string.
L Represents a lowercase letter.
N Represents an uppercase letter or a national character.
U Represents an uppercase letter.
X Represents any character.
"x" Double quotes surrounding a character or a sequence of
characters literally represent the character or sequence of
characters contained within. The x represents any character. . To
literally represent single or double quotes, use two sets of quotes
within the surrounding set of double quotes ('""""' or '"x""x"', '"''"' or
'"x''x"').
blank Blanks (unless contained in double quotes) serve as delimiters
but are otherwise ignored. They can be inserted into the pattern to
increase readability.
( ) Represents grouping to control the precedence of operators.
or | or , Represents a choice (or alternation operator).
 876 Easytrieve ® Report Generator 11.6
(m) or (m..n) or (m..*) or (*) or * Represents the repetition of the preceding pattern expression.
The m and n represent numbers and m must be less than n. A
single number with parentheses indicates the exact number of
repetitions. (m..n) represents a range of repetitions, minimum to
maximum. An asterisk in a range, (m..*), represents an infinite
maximum. An asterisk by itself, (*) or *, represents a range from 0
to infinity.
# or /-/ Represents the remove (or toss) operation. This operation applies
only to a single character set at a time and must immediately
follow that character set in the pattern. This operation removes the
character that matched the character set from the data.
+ Represents character set addition to form another character set.
- Represents character set difference to form another character set.
concatenation Concatenation is implied by proximity. For example, DDDU means
3 digits followed by an uppercase letter.
The precedence of operators from highest to lowest:
Grouping:           () " "  
Set construction:   + - 
Actions:            #   
Repetition:     (n) (m..n) (m..*) (*)   
Concatenation:      proximity   
Choice:         |   
The edit pattern is evaluated from left to right (the data from the screen is processed from left to right). Patterns examine
only one character at a time. They do not look ahead and they do not backtrack. For more information, see the  
Easytrieve  Programming Guide .
PROGRAM {STATIC|DYNAMIC}
PROGRAM lets you specify how you want to link a subprogram. Specify STATIC to indicate that you want
the subprogram to be linked with your  Easytrieve  program. Specify DYNAMIC to indicate that you want the
subprogram to be dynamically loaded. The default is taken from the PARM CALL statement.
Example
DECLARE PROTECT-FIELD ATTR (TURQ PROTECT)
DECLARE VARYING-ATTR  ATTR
DECLARE PART-ID       PATTERN 'A"-"DDA'
DEFAULT Statement
The DEFAULT statement in  Easytrieve  specifies screen-level overrides of system-defined attributes (Format 1) and
message attributes and locations (Format 2).
If used, DEFAULT statements must be the first statements coded in a screen activity.
You cannot code overlapping overrides. For example, the following code is in error because the attribute for
INFORMATION level messages is coded twice:
DEFAULT MESSAGE INFORMATION ATTR BLUE
DEFAULT MESSAGE (INFORMATION WARNING) ATTR GREEN
The following attributes are ignored for TITLE, LITERAL, and KEY:
 877 Easytrieve ® Report Generator 11.6
•CURSOR
•NUMERIC
•INVISIBLE
•MUSTFILL
•MUSTENTER
•TRIGGER
•ALARM
If coded,  Easytrieve  issues a warning message during compilation. All of the above attributes are also ignored for
MESSAGE, except for ALARM.
This statement has the following format:
Format 1
        {TITLE                                    }  
        {FIELD                 { attribute -name  } }   
DEFAULT {        [ERROR]  ATTR {                } }   
        {LITERAL               {( attribute -list)} }   
        {KEY                                      } 
Format 2
                                    {     { attribute -name  } }   
                  [INFORMATION]     {ATTR {                } }    
DEFAULT MESSAGE ( [WARNING    ]...) {     {( attribute -list)} }...
                  [ACTION     ]     {                        }    
                                    {ROW row-number          }  
TITLE
Use TITLE to override attributes for all screen titles (fields and literals) in a screen activity.
Note:  You can also override attributes at a title item level. See TITLE Statement .
LITERAL
Use LITERAL to override attributes for all row literals in a screen activity.
NOTE
You can also override attributes at a screen item level. See ROW Statement .
FIELD [ERROR]
Use FIELD to override attributes for all row fields in a screen activity. Optionally, specify ERROR to override
attributes for fields flagged in error by the automatic edit process.
NOTE
You can also override attributes at a screen item level. See ROW Statement .
KEY
Use KEY to override attributes for a function key display area in a screen activity.
ATTR {attribute-name} or ATTR {(attribute-list)}
Specify either a declared screen attribute name or one or more attribute keywords. For a list of attributes, see
ATTR Parameter. For information about how to declare screen attributes, see DECLARE Statement .
MESSAGE
Use MESSAGE to override attributes for any or all message levels (INFORMATION, WARNING, ACTION).
ROW row-number
Use ROW to override the placement of the message level (INFORMATION, WARNING, ACTION). Row-number
must be an unsigned integer that does not exceed the maximum screen size (SCREEN ROWCOUNT) and
specifies the row number on which the message is displayed.
 878 Easytrieve ® Report Generator 11.6
If ROW is not specified, all messages are displayed one line above the key display area, if used. For more
information, see KEY Statement .
Examples
Note the following examples of the message statement.
Example 1
You can use MESSAGE to display INFORMATION level messages in yellow and all other levels of messages in red:
DEFAULT MESSAGE INFORMATION       ATTR YELLOW
DEFAULT MESSAGE (WARNING ACTION)  ATTR (RED INTENSE)
Example 2
You can override the placement of messages on a screen using the ROW parameter:
SCREEN NAME MENU-SCREEN
  DEFAULT FIELD ATTR (TURQ PROTECT)
  DEFAULT FIELD ERROR ATTR (RED BLINK ALARM)
  DEFAULT MESSAGE (INFORMATION WARNING) ATTR YELLOW  ROW 23
  DEFAULT MESSAGE (ACTION)              ATTR RED     ROW 24
DEFINE Statement
The DEFINE statement in  Easytrieve  specifies data fields within a file or within working storage.
You can generate DEFINE statements automatically by using the SQL INCLUDE or IDD statements.
This article contains the following information:
Field Length and Decimal Positions
Use the following table when specifying field-length  and decimal-positions :
            Data    Maximum     Number of                           
           Format   Length       Decimal                            
            Code    (bytes)     Positions                           
             A      32,767*     not valid                           
             K      32,766*     not valid                           
             M      32,767*     not valid                           
             N         18         0 - 18                            
             P         10         0 - 18                            
             B          8         0 - 10                            
             U          9         0 - 18                            
             I          8         0                                 
 
 * For table file fields, ARG (argument) and DESC (description), the maximum length is 254 bytes.            
     
NOTE
In CICS, the maximum total field length ( field-length  multiplied by maximum-occurrences ) is 32,759.
Format
The DEFINE statement has the following format:
 879 Easytrieve ® Report Generator 11.6
DEFINE +                                                                         
 
[file-qualifier :] field-name +                                      } Field Name
 
{start-location                                       }              }            
{* [+offset-value]                                   }              }            
{W                                                   } +            } Location
{S                                                   }              }            
{[file-qualifier :] overlay-field-name [+offset-value]}              }  
 
{field-length {A|M|K|N|P|B|U|I} [ decimal-positions ] [EVEN]}         }                  
{                                                               } + } Attributes 
{[VARYING] [ file-qualifier :] model-field-name                   }   }            
 
[UPDATE] +                                                          }            
                                                                    }            
[HEADING ([# font-number] 'heading-literal' ...)] +                  }            
                                                                    }  
[INDEX ( index-field-name)] +                                        } 
                                                                    } 
[MASK ({[ mask-identifier ][BWZ][' mask-literal']|HEX})] +             } Characteristics
                                                                    }            
[OCCURS maximum-occurrences ] +                                      }            
                                                                    }            
[VALUE initial-value]  +                                            }            
                                                                    }            
[RESET]                                                             }           
Keyword
DEFINE
The DEFINE keyword must precede each field definition for definitions outside the library section.
You can omit the DEFINE keyword for fields defined after the associated FILE statement or for working storage
fields defined after any FILE statement.
Field Name
[file-qualifier: ] field-name
File-qualifier identifies the appropriate file, record, or working storage for the field you are defining.
Field-name  is the name of the field that you are defining. The field-name :
•Can be from 1 through 128 alphanumeric characters in length
•Can contain any character other than a delimiter
•Must begin with A through Z, 0 to 9, or a national character (#, @, $)
•Cannot be all numeric characters
Location
You must establish the location of the field's leftmost (starting) position in one of the following ways:
{start-location }
Start-location  specifies the starting position relative to position one of the current file or record.
NOTE
Start-location  must be specified as an unsigned integer.
 880 Easytrieve ® Report Generator 11.6
{* [+offset-value ]}
The * (asterisk) indicates that the field begins in the next available starting position (highest location defined so
far, plus 1). The optional +offset-value  is an offset you want added to the * value. There must be at least one blank
between the * and the optional + offset-value .
NOTE
+offset-value must be specified as a positive literal.
{W} or {S}
Coding W or S establishes a working storage field. S indicates a static working storage field. The product spools
W fields to report (work) files; it does not spool S fields.
NOTE
For more information about working storage fields, see Define Files and Fields .
{[file-qualifier: ] overlay-field-name  [+offset-value ]}
Specify overlay-field-name  if you want an overlay redefinition. If you use overlay redefinition, make sure that
field-name  fits within the storage boundaries of overlay-field-name . Overlaying fields with a different data format
is allowed but may result in unexpected results as contents are not revalidated. Any indexes associated with
overlay-field-name  also apply to field-name .
Specify the optional file-qualifier  if the redefined field is in a file or record other than the file or record currently
being defined.
The optional + offset-value  allows you to offset the field from the beginning of overlay-field-name .
Attributes
For each field-name  you define, you must specify the field length  in bytes, the data format, the number of decimal-
positions  (if any), and the optional VARYING parameter for varying length alphanumeric fields.
{field-length }
Field-length  specifies the length (in bytes) of the defined field. Field-length  must be an unsigned integer.
{A|M|K|N|P|B|U|I}
Specify the data format by entering one of the following letters:
A (alphanumeric)
-- Use A when none of the numeric data types applies to the associated field. A-type fields in files are
EBCDIC format, unless the associated file was declared ASCII on the CODE parameter of the PARM or
FILE statement. A-type fields in working storage are either EBCDIC or ASCII, depending on the PARM
CODE PROCESS value.
M (MIXED alphanumeric)
-- (Mainframe only) Use M when you know the data in the associated field is EBCDIC, DBCS, or a mixture
of both.  Easytrieve  processes the field assuming that it contains EBCDIC data. The DBCS data in this
field must be identified by the shift codes in the field's DBCS code system.  Easytrieve  assumes that the
field's DBCS code system is the CA-PSI/DBCS processing code system, unless the field belongs to a file
that has the CODE parameter specified on its FILE statement. This field type is invalid for those DBCS
code systems that do not have an assigned shift code system and cannot support a MIXED field type.
K (DBCS alphanumeric)
-- (Mainframe only) Use K when you know the data in the field is in DBCS format. The length of the field
must be a multiple of two. The data in this field is associated with the DBCS code system defined as the
CA-PSI/DBCS processing code, unless the field belongs to a file that has the CODE parameter specified
on its FILE statement.
N (zoned decimal)
-- Use N when the field contains digits 0 to 9 in external decimal form. For example, 0 = X'F0' in EBCDIC
and X'30' in ASCII.
 881 Easytrieve ® Report Generator 11.6
Note:  In the options table, ASCSIGN specifies which system to use to create zoned numeric fields. For
more information, see Compiler Options .
P (packed decimal)
-- Use P when the field contains numbers that meet the IBM definition of internal packed decimal. For
example, the two-byte packed field containing 123 looks like X'123F', and the two-byte packed field
containing -123 looks like X'123D'
B (binary)
-- Use B when the field contains binary data. In a quantitative binary field (a field with zero or more
decimal places specified), the high order bit is the sign bit. In a non-quantitative binary field (a field with no
decimal place specification), the high order bit is a binary digit.
NOTE
Information about signed (quantitative) and unsigned (non-quantitative) fields follows. For rules about
working with signed and unsigned fields, see Programming .
For example, in a one-byte quantitative binary field the following is true:
(HEX) 7F = (BIN) 0111 1111 = (DECIMAL) 127
(HEX) 80 = (BIN) 1000 0000 = (DECIMAL) 128-
For a one-byte non-quantitative binary field, the following is true:
(HEX) 7F = (BIN) 0111 1111 = (DECIMAL) 127
(HEX) 80 = (BIN) 1000 0000 = (DECIMAL) 128
The following table shows the length equivalent and maximum possible values for quantitative  binary fields:
Field Length (in Bytes) Digits Maximum Value Minimum Value
1 3 127 128-
2 5 32,767 32,768-
3 7 8,388,607 8,388,608-
4 10 2,147,483,647 2,147,483,648-
5 12 549,755,813,887 549,755,813,888-
6 15 140,737,488,355,327 140,737,488,355,328-
7 17 36,028,797,018,963,967 36,028,797,018,963,968-
8 19 9,223,372,036,854,775,807 9,223,372,036,854,775,808-
The following table shows the length equivalent and maximum possible values for non-quantitative  binary fields:
Field Length (in Bytes) Digits Maximum Unsigned Value
1 3 255
2 5 65,535
3 8 16,777,215
4 10 2,147,483,647
5 13 1,099,511,627,775
6 15 281,474,976,710,655
7 17 72,057,594,037,927,935
8 19 9,223,372,036,854,775,807
 882 Easytrieve ® Report Generator 11.6
U (unsigned packed decimal)
-- Use U for packed data where a sign is not needed. For example, a two-byte unsigned packed field containing
123 looks like X'0123'.
I (integer)
-- The field contains integer-formatted data in the native format of the host environment. The length of an Integer
(I) field must be two, four, or eight bytes. Decimal places must be blank or zero.
Numeric field capacities for signed I fields (quantitative) are:
Field Length (in Bytes) Maximum Value Minimum Value
2 32,767 -32,768
4 2,147,483,647 -2,147,483,648
8 9,223,372,036,854,775,807 -9,223,372,036,854,775,808
Numeric field capacities for unsigned I fields (non-quantitative) are:
Field Length (in Bytes) Maximum Unsigned Value
2 65,535
4 2,147,483,647
8 9,223,372,036,854,775,807
{[decimal-positions ]}
Decimal-positions  is an option that specifies the desired number of decimal positions for field-name . Decimal-
positions  must be specified as an unsigned integer. If decimal-positions  is specified (even if 0), the field is
considered to be quantitative. Otherwise, the field is considered non-quantitative. Quantitative fields are
automatically summed on reports. Decimal-positions  cannot be specified for data type A.
[EVEN]
Use EVEN to indicate that a packed decimal field (P) is to contain an even number of digits. The high order digit is
zero. For example, a two-byte packed even field can only contain two digits, such as X'012F'.
NOTE
EVEN is valid only for P fields.
[VARYING]
Use VARYING to indicate that field-name  is a varying length field. This means that the length of the data in this
field, for each occurrence in separate records, is unique. Varying length fields are alphanumeric and consist of a
two-byte length value followed by the data. VARYING fields typically are used for SQL VARCHAR columns.
NOTE
The VARYING parameter is not supported for M or K fields.
You can specify VARYING on type A fields. When VARYING is specified, the length attribute (field-length ) is the
total number of bytes that the varying length field can occupy (two-byte length plus maximum size of data).
You can specify VARYING for file fields or working storage fields. For file fields, the starting position (start-
location ) points to the two-byte indicator. For both file fields and working storage fields, overlay redefinition begins
with the two-byte length indicator.
When referencing a VARYING field in your program, you can use field-name  alone or suffixed as shown below.
Assume field-name  is FLDA:
•FLDA references the entire field (both length and data) as a variable length field
•FLDA:LENGTH references only the length (first two bytes) as a two-byte binary field
•FLDA:DATA references the data portion of the field (from byte three on) as an alphanumeric field
 883 Easytrieve ® Report Generator 11.6
When a VARYING field is displayed in your output, the data window is based on the maximum length of the field
(field-length  minus two). The length indicator does not display in output unless DISPLAY HEX is specified.
Length restrictions for varying length fields are as follows:
Field Type Minimum Length Maximum Length
A 3 32769
The default value for a varying field is a string of zero length. However, if the VALUE option is coded, its value and
length become the default for the field.
{[file-qualifier: ] model-field-name }
Optionally, you can specify a field name to use as a model for the field you are defining (field-name ). The
attributes used in model-field-name  are duplicated for field-name . If model-field-name  is in a different file or
record, specify the name of that file. If you use this option, you need not specify attributes for field-name .
Characteristics
[UPDATE]
Specify UPDATE for each SQL field to be modified. You can specify UPDATE only for fields defined in an 
Easytrieve  SQL file.
NOTE
Only SQL fields specified as UPDATE can be modified by the UPDATE statement.
If UPDATE is specified on the FILE statement, UPDATE is used for all fields defined in the file.
NOTE
You must have UPDATE authorization for the column in the SQL table that this file references.
[HEADING ([ #font-number ] 'heading-literal '...)]
The HEADING option specifies an alternative report heading for field-name  (the default is the actual field-name ).
NOTE
HEADING can be used in the  Easytrieve  Online Screen Painter as a default prompt for field-name .
[INDEX (index-field-name  ...)]
The INDEX option establishes indexes for field-name . You can specify multiple indexes by coding a list of index
names ( index-field-name ) enclosed in parentheses.
Easytrieve  automatically allocates a four-byte quantitative binary field for each index. Any references you make
to a field with the INDEX option cause that field's location to be adjusted by the amount contained in index-field-
name . For more information, see the Programming  section.
[MASK ({[mask-identifier ][BWZ]['mask-literal ']|HEX})]
The optional MASK parameter is used to format field-name  for display.
You can use any letter from A to Y as an optional mask-identifier . You can use the letter to identify a new mask or
to retrieve a mask that was previously defined either in the Options Table or by a mask parameter on a previous
field definition. If the new mask that you identify does not already exist,  Easytrieve  retains the mask for future
reference. If you subsequently reference field-name  for display,  Easytrieve  automatically uses the associated
letter identifier to determine the edit mask. Do not use the same identifier to establish more than one mask.
The BWZ (blank when zero) option suppresses the display of field-name  when it contains all zeros. BWZ can be
used by itself or with other options on the MASK parameter.
'mask-literal'
Defines an edit mask and must be enclosed within single quotes. The actual edit mask is coded according
to the rules specified under the MASK Parameter. For more information, see MASK Parameter .
HEX
Specifies a special edit mask that instructs  Easytrieve  to display the contents of field-name  in double-
digit hexadecimal format. You can display fields of up to 50 bytes with the HEX mask.
 884 Easytrieve ® Report Generator 11.6
NOTE
HEX edit masks are not allowed for VARYING fields.
[OCCURS maximum-occurrences ]
The OCCURS option establishes an array for field-name .
Maximum-occurrences  specifies the number of elements in the array (the number of occurrences of field-name ).
Maximum-occurrences  must be specified as an unsigned integer. The maximum value is 32,767. The total size
of the field (length * occurrences) is limited by the FLDMAX option in the options table. For more information on
FLDMAX, see Updating Options . You can reference the elements of this array by manipulating the INDEX defined
for field-name or by using subscripts. For more information, see the Programming  section.
[VALUE initial-value ]
The VALUE option initializes the contents of a field in working storage.
Initial-value  can be any valid literal whose type matches the field-name  type. If initial-value  is non-numeric, it must
be enclosed in single quotes. The maximum length for initial-value  is 254 bytes.
If the initial-value  does not match the length of field-name , it is truncated or padded according to assignment
rules.
[RESET]
Use RESET only for W working storage fields. When you code RESET on the field definition for a W field, RESET
returns the field to its initial value whenever a JOB, SCREEN, or SORT is executed. You can use RESET with
OCCURS for array fields but not for redefined fields (fields having overlay redefinition). When you use RESET on
multiple fields, the fields are reset in the order of the field definitions.
NOTE
When W working fields are referenced in report processing, a RESET is not performed during the
printing of spooled reports.
Examples
The DEFINE statement specifies data fields within a file or within working storage. You usually specify file
fields and work fields in your  Easytrieve  library section, but you can also define them within an activity, as the
following examples illustrate. Example 1: DEFINE Statement in the Library Section
               {  FILE PERSNL  FB(150 1800)                             
Library        {  DEFINE  EMP#         9    5  N                        
               {  DEFINE  EMPNAME     17   20  A                        
               {  DEFINE  EMP-COUNT    W    4  N                        
                 *                                                      
               { JOB INPUT PERSNL NAME MYPROG                           
               { EMP-COUNT = EMP-COUNT + 1                              
Activities     { PRINT REPORT1                                          
                 *                                                      
               { REPORT REPORT1                                         
               { LINE EMP# EMPNAME EMP-COUNT                           
Example 2: DEFINE Statement in an Activity
               { FILE PERSNL  FB(150 1800)                              
Library        { SALARY-CODE            134    2 N                      
               { *                                                      
               { JOB INPUT PERSNL NAME MYPROG                           
               { DEFINE  EMP#             9    5 N                      
               { DEFINE  EMPNAME         17   20 A                      
Activities     { PRINT REPORT1                                          
               { *                                                      
               { REPORT REPORT1                                         
 885 Easytrieve ® Report Generator 11.6
               { LINE EMP# EMPNAME SALARY-CODE                         
When fields are defined in an activity, each field definition must start with the DEFINE keyword and physically
be defined before the field is referenced. In the library section, the use of the DEFINE keyword is optional.
Record Description
The examples below illustrate two ways of describing a record from a personnel file. The first method uses an asterisk (*)
to define the starting location of the fields. The second method uses absolute starting positions. In this case, both methods
result in the same description. The DEFINE keyword is not needed when the field definitions immediately follow the FILE
statement.
Method 1  
          FILE PERSNL  FB(150 1800)                                     
          REGION           *    1 N                                     
          BRANCH           *    2 N                                     
          SSN              *    5 P                                     
          EMP#             *    5 N                                     
          JOB INPUT PERSNL NAME MYPROG                                  
             PRINT REPORT1                                              
          *                                                             
          REPORT REPORT1                                                
          LINE EMP# REGION BRANCH                                       
 
Method 2  
          FILE PERSNL  FB(150 1800)                                     
          REGION           1    1 N                                     
          BRANCH           2    2 N                                     
          SSN              4    5 P                                     
          EMP#             9    5 N                                     
          JOB INPUT PERSNL NAME MYPROG                                  
             PRINT REPORT1                                              
          *                                                             
          REPORT REPORT1                                                
          LINE EMP# REGION BRANCH                                      
Working Storage Initialization
Easytrieve  initializes numeric work fields to zeros and alphabetic work fields to blanks. To initialize these fields to other
values, use the VALUE parameter, as shown below:
DEFINE CURRENT-MONTH W 10 A VALUE 'JANUARY'
To reinitialize the field each time a JOB, SORT, or SCREEN activity is executed, add the RESET parameter.
Varying Length Fields
The VARYING parameter on the DEFINE statement designates varying length fields. An example of a varying length field
definition is as follows:
FLDA  W  250  A  VARYING
Because VARYING is used, this W type work field has two parts that are internally defined as follows:
W  2    B 0  forthetwo-bytefieldlength
 886 Easytrieve ® Report Generator 11.6
W  248  A    forthedata
Alternative Report Headings
The default report heading for a field is the field name. You can override this default by using the HEADING parameter, as
shown in the following example:
FILE PERSNL  FB(150 1800)                                     
  EMP#          9    5 N   HEADING('EMPLOYEE' 'NUMBER')
  PAY-NET      90    4 P2  HEADING('NET' 'PAY')                
  PAY-GROSS    94    4 P2  HEADING('GROSS' 'PAY')              
  WORK-FIELD    W    4 P2  HEADING('AMOUNT' 'OF' 'TAXES')
Edit Masks
To add an edit mask to a telephone number, use the MASK  parameter:
DEFINE PHONE    S   10   N   MASK    '(999) 999-9999'
Arrays
The following example defines an array. There are 10 occurrences of the 2-byte numeric field, ELEMENT, in the array.
When the array field is used to define the entire array, ARRAY can be used to refer to the entire storage area.
DEFINE      ARRAY      W      20    A 
DEFINE      ELEMENT    ARRAY  2     N 0    OCCURS 10
For more information about array processing, see Array Processing .
DELETE Statement
The DELETE statement in  Easytrieve  deletes a specific row from an  Easytrieve  SQL file.
DELETE performs a DELETE WHERE CURRENT OF cursor. The file must be defined with the UPDATE parameter.
Note: DELETE WHERE CURRENT OF cursor cannot be dynamically processed by the SQL interface for IDMS . To
perform SQL deletes, you must code native SQL statements using a searched delete statement.
This statement has the following format:
DELETE [FROM] file-name 
[FROM]
Optionally, code FROM for statement readability.
[file-name ]
File-name  must be the name of an  Easytrieve  SQL file.
Example
The following example selects a specific row from the table, and then deletes it:
FILE PERSNL SQL (PERSONNEL) UPDATE
EMPNAME       *   20  A
WORKDEPT      *   2   P   O
EMPPHONE      *   3   P   O
PROGRAM NAME RETRIEVE-PERSONNEL
 887 Easytrieve ® Report Generator 11.6
  SELECT FROM PERSNL WHERE EMPNAME = 'ROGERS  PAT' 
  FETCH FROM PERSNL
  IF EOF PERSNL
    DISPLAY 'EMPLOYEE NOT FOUND'
  ELSE
    DELETE FROM PERSNL
  END-IF
DISPLAY Statement
The DISPLAY statement in  Easytrieve  formats and transfers data to a system output device or a named file.
You can code DISPLAY to transfer printed data to the system output device, or you can optionally code a file name after
DISPLAY to cause data to be printed to the named file. The DISPLAY statement has three formats; Format 3 can only be
used when the file is associated with an extended reporting printer.
Unless you specify relative or absolute positioning, the first data entry of each DISPLAY statement begins in column 1 of
the print line. Each data entry that follows is printed next to the preceding entry. For HEX displays, the output is printed
five lines per 100 bytes of the record or field.
When you use DISPLAY in REPORT procedures, output is always in the appropriate place in the report. However, when
you use DISPLAY in a JOB activity, the output can be interspersed with the first unsequenced report if no file-name  is
specified.
Data displayed to an output file is in an edited format. DISPLAY is not valid for nullable fields, but DISPLAY HEX is valid.
This statement has the following format:
Format 1
        [ display-file-name] [{TITLE|NOTITLE}                     ]      
DISPLAY [                 ] [SKIP skip-integer                   ] +    
        [SYSPRINT         ] [CONTROL ' carriage -control-character ']      
                                                                        
        [ [            ] field-name]                                      
        [ [# font-number]          ]                                      
        [ [            ]' literal' ]                                      
        [+ offset                  ] ...                                  
        [- offset                  ]                                      
        [COL column-number        ]                                      
        [POS position -number      ]                                     
Format 2
        [ display-file-name] [{TITLE|NOTITLE}                     ]      
DISPLAY [                 ] [SKIP skip-integer                   ] +    
        [SYSPRINT         ] [CONTROL ' carriage -control-character ']      
                                                                        
            { file-name  }                                               
        HEX { field-name }                                               
            { record-name}                                              
Format 3
        [ display-file-name] [                         ]                 
 888 Easytrieve ® Report Generator 11.6
DISPLAY [                 ] [CONTROL ' control-literal']                 
        [SYSPRINT         ] [                         ]                
Format 1
[display-file-name ] or [SYSPRINT]
When you specify display-file-name ,  Easytrieve  prints data to the named file. The named file should be
designated as a PRINTER file or unpredictable results can occur. If you do not specify display-file-name, the
default is SYSPRINT. SYSPRINT implies the system output device. The actual destination of SYSPRINT is
determined by the environment or a site option. For more information, see your system administrator.
[{TITLE|NOTITLE}]
The TITLE option specifies that a skip to a new page occurs before the data is printed. It also produces any titles
and headings if coded in a report procedure. If not coded in a report procedure, no titles are produced.
NOTITLE specifies that a skip to a new page occurs but titles and headings are not produced.
[SKIP skip-integer ]
The SKIP skip-integer  option specifies the number of lines skipped before printing data. When skip-integer  is zero,
the current line being displayed overlays the previous line output to display-file-name .
[CONTROL ' carriage-control-character ']
The CONTROL ' carriage-control-character ' option sets the print carriage control character for the print line. Valid
alphanumeric values for ' carriage-control-character ' are 0 to 9, +, -, A, B, or C. Depending on the make and model
of impact printer used, these characters select a precoded channel on a carriage control tape that determines
print line positions associated with the form to be printed.
When display-file-name is associated with an extended reporting printer, the printer must support ANSI or
machine carriage controls.
Note:  This parameter is not valid for use in REPORT procedures.
[#font-number ]
#font-number  identifies the font that  Easytrieve  uses for the next display item. You can specify this option only if
display-file-name  has been associated with an extended reporting printer. #font-number  identifies the number of
a font defined for the extended reporting printer assigned to receive the print output. If you do not code the font
index, then the next display item uses the default font for the assigned extended reporting printer.
[field-name ] or ['literal ']
Code field-name  or 'literal ' in the order you want them to appear on the printed line.
Note:  K fields are not valid on a DISPLAY statement.
[+offset ] or [-offset ]
Use the space adjustment options to add (+ offset  ) or subtract (- offset ) horizontal line spaces preceding the next
display item.
Note:  ±offset  does not extend space beyond the left and right margin set points.
[COL column-number ]
The COL column-number  option specifies the absolute print column number on which  Easytrieve  begins to print
the next display item. Column-number  can be any value that does not extend beyond the line margins.
Note:  When using an extended reporting printer, an error occurs if two or more fields or literals overlap. For more
information, see the Programming Guide .
[POS position-number ]
The POS position-number  option coded in a DISPLAY statement within report procedures causes the next display
item to be left-justified under the corresponding position-number  item in the LINE 01 statement.
Note:  When using an extended reporting printer, an error occurs if two or more fields or literals overlap. For more
information, see the Programming Guide .
Format 2
 889 Easytrieve ® Report Generator 11.6
HEX {file-name } or HEX {field-name } or HEX {record-name }
Easytrieve  produces a hexadecimal and character dump of the current file-name  or field-name , whichever you
specify. For IDMS  files, record-name  refers to any record (segment); file-name  refers to all records (segments).
Note:  HEX file-name  cannot be used in REPORT procedures.
Format 3
You can use this format of the DISPLAY statement only when display-file-name  is associated with an extended reporting
printer. A syntax error occurs if display-file-name  is not an extended reporting printer. For more information about
extended reporting, see the Programming Guide .
[CONTROL ' control-literal ']
You can use the CONTROL parameter to output printer control records. 'Control-literal ' can be an alphanumeric
or hexadecimal literal that  Easytrieve  outputs to the print file without paper control information. These control
cards contain instructions to extended reporting printers. Print control records for some printing systems define
the specification of the font sets that  Easytrieve  uses for a particular report. These control cards can be output to
the print data set before a report that uses the loaded font sets.
Examples
Format 1
The following example illustrates the use of Format 1 of the DISPLAY statement:
FILE BADKEYS FB(150 1800) TERMINAL                                     
FILE PERSNL INDEXED                                                    
%PERSNL                                                                
FILE INKEYS                                                            
WHO * 5 N                                                              
JOB INPUT INKEYS NAME MYPROG                                           
   READ PERSNL KEY WHO STATUS                                          
   IF NOT PERSNL                                                       
     DISPLAY BADKEYS 'BAD KEY =' +1 WHO                                
     GOTO JOB                                                          
   END-IF                                                             
When executed, the statements in this example produce the following output:
BAD KEY = 00973
Format 2
The following example illustrates the use of Format 2 of the DISPLAY statement:
FILE PERSNL INDEXED                                                    
%PERSNL                                                                
FILE INKEYS                                                            
WHO * 5 N                                                              
JOB INPUT INKEYS NAME MYPROG                                           
   READ PERSNL KEY WHO                                                 
   DISPLAY SKIP 2 HEX PERSNL                                          
When executed, the statements in this example produce the following output:
CHAR  104   G 01963  7ARNOLD  LINDA       1569 COLONIAL TERR ANEW YORK    NY10012                 @    911 
 890 Easytrieve ® Report Generator 11.6
ZONE  FFF21683FFFFF44FCDDDDC44DCDCC4444444FFFF4CDDDDCCD4ECDD4CDCE4EDDD4444DEFFFFF4444444444444403670450FFF 
NUMR  1048327C019630071956340039541000000015690363659130359901556086920000581001200000000000000058C045C911 
      1...5...10...15...20...25...30...35...40...45...50...55...60...65...70...75...80...85...90...95..100 
                                                                                                           
                                                                                                           
CHAR    082942        21245140401S   1001101968                                                            
ZONE  44FFFFFF44444444FFFFFFFFFFFE444FFFFFFFFFF444444444                                                   
NUMR  00082942000000002124514040120001001101968000000000                                                   
    101...5...10...15...20...25...30...35...40...45...50
DLI Statement
The DLI statement in  Easytrieve  provides controlled input/output of an IMS/DLI database. This statement gives control
over the creation and maintenance of a database.
You can use the DLI statement in conjunction with (or independently of) the automatic input associated with RETRIEVE.
You can code the DLI statement at any place in a JOB activity that an input/output statement for any other file can be
coded. This statement provides complete control over the creation and maintenance of a database.
There are six different formats for the DLI statement:
Format 1
               { io-record-name} {'function -literal' }                   
 DLI file-name {              } {                   }  +                
               { io-field-name } {function -field-name}                   
 
 [                 ] [    {' search-value-literal' } ]                   
[SSANO ssa-number ] [SSA {                       } ] ...               
[                 ] [    { search-value-field-name} ]                  
Format 2
     {CHKP} {' seg-len-literal' }                                        
 DLI {    } {                  }  id-field-name  +                      
     {XRST} { seg-len-field-name}                                        
 
     [ {' checkpoint -len-literal' }                        ]             
     [ {                         }  checkpoint -field-name ] ...
     [ { checkpoint -len-field-name}                        ]             
Format 3
 DLI CHKP id-field-name 
Format 4
 DLI file-name FOR ACCESS                                              
Format 5
         {' psb-name-literal' }                                          
 DLI PCB {                   }                                          
         { psb-name-field-name}                                         
Format 6
 DLI TERM                                                              
 891 Easytrieve ® Report Generator 11.6
This section describes the parameters for each of the six formats of the DLI statement.
Format 1
file-name
File-name  identifies the database being processed. File-name  is the same as the name coded on the FILE file-
name  statement that identifies the DBD to be processed.
{io-record-name } or {io-field-name }
Io-record-name  or io-field-name  identifies the input/output area that is to receive the data. Io-record-name  must
be the same as a corresponding segment-name  coded on a RECORD statement. Io-field-name  can only be a
working storage field. In either case, the area specified must be large enough to contain the longest segment
retrieved from the database.
{'function-literal '} or {function-field-name }
You can specify any IMS/DL/I function code whose parameter requirements conform to Format 1. The function
code can be specified as either an EBCDIC alphabetic literal (' function-literal ') or an alphanumeric function-field-
name  that contains a four-byte alphabetic code. Valid function codes (for example, GNP) are described in IBM's
IMS/DL/I Application Programming publications.
[SSANO ssa-number ] or [SSA {' search-value-literal '}] or [SSA { search-value-field-name }]
Code the optional SSANO and SSA parameters when the database activity to be performed cannot be satisfied
without using segment search arguments. SSANO identifies a function-field-name  that represents a four-byte
binary field. Function-field-name  can be set dynamically to control the number of SSAs used in database system
calls. This value overrides the assumed number, which is equal to the count of SSA parameter entries.
The SSA parameter supplies segment search argument values. You can code the SSA values as search-value-
field-name  or an alphabetic literal (' search-value-literal '). The SSA value must contain the segment search
argument in the exact form required by IMS/DL/I. If search-value-field-name  contains DBCS data, the DBCS code
system of search-value-field-name  must equal the DBCS code system of file-name .
Note:  Multiple search value literals or search value field names must be enclosed in parentheses.
Format 2
Use Format 2 of the DLI statement to perform a symbolic checkpoint/restart. You must specify the compatibility option
(COMPAT=YES) for the PSB being processed; this option generates a dummy PCB that acts as an I/O PCB during
checkpoint/restart processing. Test CHKP-STATUS to determine the results of the call. For more information about CHKP-
STATUS, see "File Processing" in the Programming Guide . For more information about symbolic checkpoint/restart, see
IBM's IMS/DL/I Application Programming publications.
{CHKP} or {XRST}
Code CHKP to perform symbolic checkpoint or XRST to perform a symbolic restart.
{'seg-len-literal '} or {seg-len-field-name }
'Seg-len-literal ' or seg-len-field-name  specifies the length of the longest segment (or path of segments) in the
PSB. ' Seg-len-literal ' must be a four-byte binary field.
[id-field-name ]
Id-field-name  must identify a 12-byte area in working storage. The first eight bytes of this area contain the
checkpoint ID. You should set the 12-byte area to spaces before performing the DLI XRST operation, then test it
after performing the operation. If your program is being started normally, the area will still contain spaces. If your
program is being restarted from a checkpoint, the area will contain the checkpoint ID that you supplied during the
DLI CHKP operation and in the restart JCL.
Optionally, you can also specify up to seven checkpoint areas in working storage that are saved during each
checkpoint and restored during a restart.
{'checkpoint-len-literal ' } or {checkpoint-len-field-name }
'Checkpoint-len-literal ' or checkpoint-len-field-name  specifies the length of the checkpoint area defined by
checkpoint-field-name . Checkpoint-len-field-name  must be a four-byte binary field.
 892 Easytrieve ® Report Generator 11.6
[checkpoint-field-name ]
Checkpoint-field-name  must identify a field in working storage. The length of this checkpoint area is specified by
checkpoint-len-field-name  or 'checkpoint-len-literal '.
A checkpoint can be taken on a maximum of seven areas.
Format 3
Use Format 3 of the DLI statement to perform a basic checkpoint. For IMS, you must specify the compatibility option
(COMPAT=YES) for the PSB being processed; this option generates a dummy PCB that acts as an I/O PCB during
checkpoint processing. Test CHKP-STATUS to determine the results of the call. For more information of CHKP-STATUS,
see "File Processing" in the Programming Guide . For more information about basic checkpoints, see IBM's IMS/DL/I
Application Programming publications.
CHKP
CHKP causes a basic checkpoint to be performed.
id-field-name
Id-field-name  must identify an 8-byte area in working storage. This area contains the checkpoint ID.
Format 4
Use Format 4 of the DLI statement when you are calling a subprogram (such as a COBOL program) that accesses DL/I
records. Coding this statement before referencing DLI fields causes the fields to become available for processing.
DLI file-name  FOR ACCESS
File-name  refers to an  Easytrieve  file definition containing the appropriate PCB field, record, and record field
definitions.
Format 5
Use Format 5 to schedule a PSB. Format 5 is used for CICS execution only. In other environments, it is ignored. Any
program that executes under CICS must schedule the PSB before accessing any PSB, including programs that are
accessing DL/I with the RETRIEVE statement. For activities that use the RETRIEVE statement, the PSB must be
scheduled in a JOB START proc, or in a previously-executed activity. When a PSB is scheduled, it stays scheduled until
one of the following occurs:
•Task termination
•Syncpoint
•Execution of the DLI TERM statement (see Format 6)
Test the UIBFCTR and UIBDLTR system-defined fields to determine the results of the operation. For more information
about scheduling PSBs and the values of UIBFCTR and UIBDLTR, see IBM's IMS/DL/I Application Programming
publications.
{'psb-name-literal '} or {sb-name-field-name }
'Psb-name-literal ' or psb-name-field-name  specifies the PSB to be scheduled. The maximum length of a PSB
name is eight bytes.
Format 6
Use Format 6 to terminate a PSB. Format 6 is used only for CICS execution. In other environments, it is ignored. Test
the UIBFCTR and UIBDLTR system-defined fields to determine the results of the operation. For more information about
scheduling PSBs and the values of UIBFCTR and UIBDLTR, see IBM's IMS/DL/I Application Programming publications.
DO UNTIL and DO WHILE Statements
Easytrieve 's loop control statements DO UNTIL, DO WHILE, and END-DO control and delimit repetitive program logic.
DO WHILE
 893 Easytrieve ® Report Generator 11.6
The truth value of the conditional expression determines whether statement-1  to statement-n  are executed. Statement-1
... statement-n  represents any number of Easytrieve  statements. When the conditional expression is true, the statements
are executed and the program branches back to test the conditional expression. The program continues to loop as long
as the conditional expression is true. When the conditional expression is false, the program branches to the statement
following END-DO.
DO UNTIL
Statement-1  to statement-n  are executed. The truth value of the conditional expression determines whether the group of
statements are executed again. When the conditional expression is true, the program branches to the statement following
the END-DO. When the conditional expression is false, the program branches back to execute the statements. The
program continues to loop until the conditional expression is true.
This statement has the following format:
          {WHILE}
     DO   {     }     conditional -expression
          {UNTIL}
 
             statement -1
             ...
             statement -n
 
     END-DO
The following diagram illustrates DO and END-DO statement logic:
 894 Easytrieve ® Report Generator 11.6
{WHILE} or {UNTIL}
A WHILE loop evaluates the condition at the top of a group of statements. An UNTIL loop evaluates the condition
at the bottom of a group of statements.
conditional-expression
Specify the condition that is the basis for the continuing execution of the loop. For conditional expression syntax,
see Conditional Expressions in "Statements A - C."
END-DO
END-DO terminates the body of the loop associated with the DO statement. An END-DO statement must be
specified after each DO statement and its associated statements.
Examples
DO UNTIL statement example:
FILE FILEA
ELEMENT   1   10  A    OCCURS 10
CTR       W    2  N
JOB INPUT FILEA
  CTR = 1
 895 Easytrieve ® Report Generator 11.6
  DO UNTIL CTR > 10
    DISPLAY ELEMENT (CTR)
    CTR = CTR + 1
  END-DO
DO WHILE loop nesting example:
DEFINE COUNT-1 W 3 N VALUE 0                                           
DEFINE COUNT-2 W 3 N VALUE 0                                           
DEFINE RESULT  W 3 N VALUE 0                                           
*                                                                      
JOB INPUT NULL NAME MYPROG                                             
   DO WHILE COUNT-1 LT 10                                              
     COUNT-1 = COUNT-1 + 1                                             
     COUNT-2 = 0                                                       
     DO WHILE COUNT-2 < 10                                             
       COUNT-2 = COUNT-2 + 1                                           
       RESULT = COUNT-1 * COUNT-2                                      
       DISPLAY 'COUNT-1= '  COUNT-1 '  COUNT-2= ' COUNT-2 +            
               '  RESULT= ' RESULT                                     
     END-DO                                                            
   END-DO                                                              
STOP                                                                  
ENDPAGE Report Procedure
The ENDPAGE procedure in  Easytrieve  produces page footing information.
An ENDPAGE procedure is invoked whenever end-of-page is detected.
An ENDPAGE procedure must be delimited by an END-PROC statement. For more information, see PROC Statement in
"Statements N - R."
This statement has the following format:
ENDPAGE. PROC
Example
ENDPAGE is typically used to produce page totals or other annotations, as in the following example of page footer
annotation:
FILE FILE1                                                              
LAST-NAME  1  5 A                                                       
STATE      6  2 A                                                       
ZIP        8  5 N                                                       
PAY-NET    13 5 N 2                                                     
JOB INPUT FILE1 NAME MYPROG                                             
  PRINT REPORT1                                                         
*                                                                       
REPORT REPORT1 LINESIZE 65 +                                            
  SUMMARY  SUMCTL DTLCOPY                                               
  SEQUENCE STATE ZIP LAST-NAME                                          
  CONTROL  STATE NEWPAGE ZIP                                            
 896 Easytrieve ® Report Generator 11.6
  TITLE 'REPORT FOR THE STATE OF' STATE                                 
  LINE 01  LAST-NAME STATE ZIP PAY-NET                                  
*                                                                       
ENDPAGE. PROC                                                           
  DISPLAY SKIP 2 '* CONFIDENTIAL - FOR INTERNAL USE ONLY *'             
END-PROC                                                                
*                                                                      
END-PROC Statement
The END-PROC statement in  Easytrieve  delimits statements in a procedure.
A procedure is a group of user-written  Easytrieve  statements designed to accomplish a particular objective.
For more information, see PROC Statement in "Statements N - R."
This statement has the following format:
END-PROC   
ENDTABLE Statement
The ENDTABLE statement in  Easytrieve  delimits instream data used to create small tables.
ENDTABLE must be coded in the first eight positions of the source statement. The ninth position must be blank.
All data required to create an instream table file must be coded between the definition statements and the ENDTABLE
statement.
If the table data is to be stored in a macro, you must store the entire table definition from the FILE statement to the
ENDTABLE statement.
This statement has the following format:
ENDTABLE
Example
FILE  DAYTABL  TABLE   INSTREAM                                         
   ARG 1    1  A.   DESC   3  9  A                                      
1 SUNDAY                                                                
2 MONDAY                                                                
 ...                                                                    
7 SATURDAY                                                              
ENDTABLE       
EXECUTE Statement
The EXECUTE statement in  Easytrieve  invokes a JOB, SORT, or SCREEN activity from either a PROGRAM or
SCREEN activity.
The EXECUTE statement transfers control to an activity. After the activity is executed, control returns to the next
executable statement following the EXECUTE. You cannot invoke a JOB, SORT, or SCREEN activity in a JOB or SORT
activity.
 897 Easytrieve ® Report Generator 11.6
EXECUTE statements in a SCREEN activity can invoke other activities. This is called activity nesting. However, recursion
is not permitted. That is, activity A can EXECUTE activity B, but activity B cannot then EXECUTE activity A.
NOTE
Recursion cannot be detected in the program. If it is attempted, unpredictable results can occur.
You can use the EXECUTE statement to invoke multiple stacked windows from a SCREEN activity. When each stacked
window terminates with an EXIT, the full screen image is restored to the screen image that existed before the EXECUTE.
An EXIT from the primary screen does not restore the screen.
This statement has the following format:
EXECUTE { job-name |sort-name |screen-name }
{job-name |sort-name |screen-name }
Identifies the JOB, SORT, or SCREEN activity to be executed.
Example
PARM-FIELD  W  5  A                           
PROGRAM NAME SAMPLE-PROGRAM USING PARM-FIELD
  IF PARM-FIELD = 'DAILY'
    EXECUTE DAILY-JOB
  ELSE
    EXECUTE WEEKLY-JOB
  END-IF
  JOB NAME DAILY-JOB
  . . .
  JOB NAME WEEKLY-JOB
EXIT Statement
The EXIT statement in  Easytrieve  terminates a SCREEN activity.
When an EXIT statement is encountered and the SCREEN activity was invoked from a PROGRAM or SCREEN activity,
control is returned to the statement following the EXECUTE statement.
If a SCREEN activity was invoked by an implied PROGRAM activity, EXIT terminates the program.
EXIT is a branch action that can be invoked directly by pressing a particular attention key. For more information, see KEY
Statement in "Statements G - M."
This statement has the following format:
EXIT
Example
  SCREEN NAME MENU
  KEY F3
  ...
  AFTER-SCREEN. PROC
    IF KEY-PRESSED = F3
      EXIT
    END-IF
 898 Easytrieve ® Report Generator 11.6
  END-PROC
FETCH Statement
The FETCH statement in  Easytrieve  retrieves rows from an SQL file.
The FETCH statement retrieves rows from the open cursor and places the data in the file's data area. If the file does not
have an open cursor associated with it, the cursor previously selected is reopened. If no cursor was previously selected,
the default cursor (SELECT all defined fields FROM table) is opened.
You cannot use controlled statements (SELECT, FETCH, CLOSE) in a SORT or REPORT procedure.
The FETCH statement cannot reference an automatic input file in the same JOB activity. You can FETCH from a file other
than the automatic input file.
This statement has the following format:
FETCH [FROM] file-name 
[FROM]
Optionally, code FROM for statement readability.
file-name
File-name  is the name of an  Easytrieve  SQL file.
Example
Following is an example of a PROGRAM activity that uses a default cursor:
FILE PERSNL SQL (PERSONNEL)
 EMPNAME       *   20  A
WORKDEPT      *   2   P   0
PROGRAM NAME RETRIEVE-PERSONNEL
  FETCH FROM PERSNL
  DO UNTIL EOF PERSNL
    DISPLAY EMPNAME +2 WORKDEPT
    FETCH FROM PERSNL
  END-DO
The above PROGRAM activity simply fetches each row of the table and displays the fields. The DO loop repeats the
process until end-of-file.
FILE Statement
The FILE statement in  Easytrieve  describes files that your program references. Access SQL, IDMS , and IMS/DL/I
databases using  Easytrieve  files.
Code FILE statements at the beginning of a program after the PARM statement, if one is used. Not all parameters are
necessary (or valid) for describing any one file. A review of all parameters will quickly indicate those required for any
particular file.
Code the optional parameters and subparameters of the FILE statement in any order following the file name. As shown,
you must code multiple subparameters within parentheses. The complete syntax of the FILE statement is shown below.
To maintain compatibility of programs using VSAM files that were written in prior versions of the product, Easytrieve
supports FILE statements containing VS and its related keywords (as follows):
FILE file-name VS ([ES] [F] [PASSWORD ' literal'] +
 899 Easytrieve ® Report Generator 11.6
  CREATE [RESET|UPDATE] [NOVERIFY]
For more information about using the FILE statement, see the Programming  section.
This statement has the following format:
FILE filename +                                                              
 
  [SEQUENTIAL                              [CREATE [RESET]]  ]           }     
  [INDEXED                                 [UPDATE        ] ] +         }     
  [RELATIVE                                                 ]           }     
  [SQL ([ owner-name.] table-name [correlation -name]{,}...)  ]           } File 
  [IDMS ( subschema -name [RESET])                            ]           } Type 
  [     { relative -position             }                     ]           }      
  [DLI ({                             }[RESET])             ]           }      
  [     { dbd-name[relative -occurrence ]}                     ]           }      
 
  [         {' password -literal' } ]                                            
  [PASSWORD {                   } ] +                                          
  [         { password -field-name} ]                                            
 
  [NOVERIFY] +                                                                 
 
  [                   [        { parm-literal   }      ]           ]            
  [EXIT ( program-name [USING ( {               } ...) ] [MODIFY]) ]  +         
  [                   [        { parm-field-name}      ]           ]            
 
  [CARD                                                              ]  }        
  [PUNCH                                                             ]  } Device 
  [PRINTER [([PAGESIZE ( line-page-size [display-page-size]) +        ]  } Type   
  [          [LINESIZE line-length])]                                ]  }        
 
  [F [record-length]                       ]                            }        
  [                                        ]                            }        
  [V [record-length]                       ]                            }        
  [                                        ]                            }        
  [  [block-length]                        ]                            }        
  [U [FULLTRK     ]                        ]                            }        
  [                                        ]                            }        
  [FB [ ( record-length [block-length] ) ]   +                           } Record 
  [   [                [FULLTRK     ]   ]   ]                           } Format 
  [                                         ]                           }        
  [VB [ ( record-length [block-length] ) ]   ]                           }        
  [   [                [FULLTRK     ]   ]   ]                           }        
  [                                                                     }        
  [VBS [ ( record-length [block-length] ) ]  ]                           }        
  [    [                [FULLTRK     ]   ]  ]                           }        
 
  [WORKAREA area-length] +                                                      
 
  [      [INSTREAM         ] ]                                                   
  [TABLE [                 ] ] +                                                 
  [      [ max-table-entries] ]                                                   
 
 900 Easytrieve ® Report Generator 11.6
  [BUFNO buffers] +                                                              
 
  [DEFER] +                                                                      
 
  [ASA] +                                                                        
 
  [EXTENDED xrpt-printer]  +                                                     
 
  [CODE {EBCDIC|ASCII| dbcs-code-name}] +                                         
 
  [KEYkey-field-name]  +                                                        
  [        {' file-identifier '         }           ]                     }        
  [SYSNAME {                          }           ]                     }        
  [        { file-identifier -field-name}           ]                     }        
  [                                               ]                     }        
  [                  [MEMORY]                     ]                     }        
  [VIRTUAL ([RETAIN] [DISK  ] )                   ]                     }        
  [                                               ]                     }        
  [          [   {' terminal -id-literal' } ]       ]                     }        
  [TERMINAL ([ID {                      } ] +     ]                     }        
  [          [   { terminal -id-field-name} ]       ]                     }        
  [                                               ]                     }        
  [           [NOFORMFEED] +                      ]                     }        
  [                                               ]                     }        
  [           [        [BEFORE] ]                 ]                     }  Data  
  [           [NEWPAGE [AFTER ] ]... )            ]                     }  Set   
  [                                               ]                     }  Type  
  [        [      {' spool-class-literal' } ]      ]                     }        
  [SPOOL ( [CLASS {                      } ] +    ]                     }        
  [        [      { spool-class-field-name} ]      ]                     }        
  [                                               ]                     }        
  [        [     {' destination -literal' } ]       ]                     }        
  [        [NODE {                      } ] +     ]                     }        
  [        [     { destination -field-name} ]       ]                     }        
  [                                               ]                     }        
  [        [       {' user-id-literal' } ]         ]                     }        
  [        [USERID {                  } ] )       ]                     }        
  [        [       { user-id-field-name} ]         ]                     }       
file-name (return to top)
File-name  is a 1- to 128-character name used to define the file to  Easytrieve . All statements that operate on the
file refer to this name. Every FILE statement must have a file-name immediately following the FILE keyword. File-
names  must be unique in the program (that is, you can use a given file-name  for only one file). The first three
characters of file-name  must be different from the value of the work data set name prefix specified in the Site
Options Table (normally EZT).
For the relationship between a FILE statement and an external data set, see the SYSNAME parameter under
Data Set Types in this article.
File Types
Easytrieve  processes all standard file types available in the operating environment. On a mainframe, this includes QSAM
(Queued Sequential Access Method); VSAM (Virtual Storage Access Method); SQL; printer files directed to an online
printer, terminal, or the operating system spooling subsystem (JES2 or JES3 in z/OS and POWER in VSE); IDMS  and
IMS/DL/I database files; and the Easytrieve  Virtual File Manager (VFM). On non-mainframe platforms, these include fixed
 901 Easytrieve ® Report Generator 11.6
length sequential, variable length sequential (new-line delimited), indexed, relative, VFM, and SQL database files. If you
do not specify a file type, the file is assumed to be sequential.
[SEQUENTIAL] (return to top)
SEQUENTIAL designates a QSAM or VSAM Entry Sequenced Data Set (ESDS) on a mainframe. On other
platforms, the file can be a fixed length or a variable length (new-line delimited) file. SEQUENTIAL is the default
file type if a file type is not specified.
Note:  When SEQUENTIAL is specified, FILE-STATUS (a system-defined field) is available for the file.
[INDEXED] (return to top)
INDEXED designates a VSAM Key Sequenced Data Set (KSDS) or an ISAM file on a non-mainframe platform.
[RELATIVE] (return to top)
RELATIVE designates a mainframe VSAM Relative Record Data Set (RRDS), or a relative file on non-mainframe
platforms.
[SQL] ([owner-name. ] table-name  [correlation-name ] {,} ...) (return to top)
The SQL parameter designates an SQL file. This parameter enables the product to manage the SQL cursor.
NOTE
•Only UPDATE, DEFER, and CODE are valid FILE statement parameters for an SQL file.
Table-name is the name of the SQL table to be accessed. Optionally, qualify the table with owner-
name . Table-name must be enclosed in parentheses.
Correlation-name  is the name used to clarify or simplify the table to which a column belongs. If you
specify owner-name  and your DBMS does not permit more than one level of qualification ( IDMS ,
Ingres, or Oracle), you should code a correlation-name for each table.
•The comma is a required separator.
When you specify SQL, the file can be used as the subject of either automatic input or controlled
processing using the SELECT, FETCH, CLOSE, INSERT, UPDATE, and DELETE statements. These
statements support full read-write access to the tables but you do not have to declare, open, and
close cursors to manage the tables. Multiple tables for a single file are joined for inquiry only.
[IDMS (subschema-name  [RESET]) (return to top)
IDMS designates the file as an IDMS  database file.
Subschema-name  is a one- to eight-character name that specifies the subschema to be processed.
The optional RESET subparameter requests that all records under control of RETRIEVE be reset to binary zero
immediately prior to retrieving each root record.
When the first IDMS FILE statement is encountered, an IDMS  Communications Block is created in working
storage.
For more information about IDMS  processing, see the IDMS  Database Processing  section.
Note:  Fields cannot be defined in association with the IDMS FILE statement. Fields are defined following the
RECORD or ELEMENT-RECORD statement.
DLI ({relative-position } [RESET]) or DLI ({ dbd-name [relative-occurrence ]} [RESET]) (return to
top)
(Mainframe only) DLI designates the file as an IMS/DL/I database file.
Relative-position  is a positive numeric literal that identifies the relative position of the PCB within the PSB to be
processed.
Dbd-name  specifies the name of the DBD. Relative-occurrence is the relative occurrence of like-name DBDs in
the PSB. It is required only if two or more DBDs have the same name.
The optional RESET subparameter requests that all records under control of RETRIEVE be reset to binary zero
immediately prior to retrieving each root record.
For more information, see IMS/DL/I Database Processing .
[CREATE [RESET]] (return to top)
Use CREATE to load the associated file.
 902 Easytrieve ® Report Generator 11.6
(Mainframe only) If you specify RESET,  Easytrieve  overwrites an existing data set with the REUSE attribute. If
RESET is not specified, or if RESET is specified and the associated VSAM data set does not have the REUSE
attribute, then  Easytrieve  receives an error condition when the OPEN is executed.
Note:  In CICS, the use of RESET results in an execution error.
(Non-mainframe platforms only) If you specify RESET,  Easytrieve  deletes an existing data set before creation or
instructs the access method to overwrite the file. If RESET is not specified, new records are appended.
[UPDATE] (return to top)
Use UPDATE to permit the file to be updated.
For SQL, code UPDATE to specify that all columns defined for the file can be updated. If you do not specify
UPDATE for an SQL file, only those columns defined with the UPDATE parameter can be updated. UPDATE is
required to DELETE from or INSERT to an SQL file.
Note:  You must have UPDATE, INSERT, or DELETE authorization for the SQL table that this file references.
[PASSWORD {'password-literal'}] or [PASSWORD {password-field-name}] (return to top)
'Password-literal ' is the optional password for the file. You can specify the password as an alphabetic literal or a
hexadecimal quoted literal.
Password-field-name  is a field you define that contains the password for the file.  Easytrieve  accesses the value
in password-field-name when the file is opened. Any valid password is accepted.
[NOVERIFY] (return to top)
Code NOVERIFY to ignore a VSAM open error code of 116(X'74'). This error indicates that a previous job
terminated without properly closing the associated VSAM data set. It could also indicate that a job executing on
another CPU is using the associated VSAM data set.
WARNING
Indiscriminate use of NOVERIFY can cause loss of data records.
[EXIT]
EXIT invokes a user-written program for each  Easytrieve  operation on the file. EXIT is not valid for VFM, SQL,
DL/I, or IDMS .
program-name
Specify the name of the user program.
[USING {parm-literal }] or [USING { parm-field-name }]
USING appends the associated parameters ( parm-literal  or parm-field-name ) to the standard parameter
list passed to the exit program. Field names must be working storage or system-defined fields and must
be defined in the library section. There is a limit of 62 fields that can be passed to the exit program.
[MODIFY]
MODIFY specifies that  Easytrieve  provides input or output services, but that the exit can inspect and
modify each record after input and before output.
Device Types
The optional parameters CARD, PUNCH, and PRINTER specify the device type for SEQUENTIAL files. For MVS, if you
do not specify one of these parameters, the device type is determined by your JCL.
[CARD] (return to top)
(TSO and CMS usage) The CARD option retrieves the file data from the system input stream (SYSIN). Only one
file in an  Easytrieve  execution can use the CARD option. Files using this option must be 80-character unblocked
records.
Note:  In TSO and CMS, you cannot use a CARD file if you want to execute your program interpretively.
(Non-mainframe platform usage) The CARD option indicates the file is stdin. It is treated as a variable length file
(new-line delimited) with a maximum record length of 256.
 903 Easytrieve ® Report Generator 11.6
[PUNCH] (return to top)
(TSO and CMS only) The PUNCH option indicates punched card output. Files created with this option are 80-
character unblocked records.
[PRINTER] (return to top)
PRINTER indicates that the file receives printed output routed to a file, an online printer, a terminal, or a
subsystem (JES/POWER) data set. Although normal input/output statements (GET, PUT, READ, WRITE) cannot
reference PRINTER files, the DISPLAY statement and the PRINTER parameter of the REPORT statement can
reference PRINTER files.
[PAGESIZE (line-page-size  [display-page-size ])
Specify PAGESIZE to define the logical print length of a printed page. For complete rules for specifying
PAGESIZE, see REPORT - Statement.
[LINESIZE line-length ]
Code the LINESIZE parameter to specify the maximum number of data characters that can be printed on
a line. Line-length  must be an unsigned integer from 1 to 32767.
Line-length  must be at least one less than the length of the data portion of the file's logical record. If
the FILE definition does not provide the file's format and logical record length, then no compile time
verification of the line-length  is done.
Line-length  provides the default value for any REPORT specifying this file as its PRINTER file.
The default value of LINESIZE is calculated as one less than the data portion of the logical record if
the file format and record length are known at compile time. Otherwise, the default is taken from the
LINESIZE site option.
There are additional control characters (forms control information) that also must be stored in a logical
record. If one of the record format parameters is specified, it must be large enough to hold both the forms
control information and the data characters. The value of line-length  must be less than or equal to the
maximum record length minus the size of the forms control information.
Record Format (return to top)
You can optionally code the record format of non-VSAM files for z/OS programs. If you do not code a record
format in z/OS,  Easytrieve  obtains it from the operating system when the file is opened. For input files, 
Easytrieve  always obtains the record format from z/OS. The record format and length are required for VSE and
non-mainframe FILE statements.
[F [record-length]                       ]
[                                        ]
[V [record-length]                       ]
[                                        ]
[U [block-length]                        ]
[  [FULLTRK     ]                        ]
[                                        ]
[FB [ (record-length [block-length] ) ]  ]
[   [                [FULLTRK     ]   ]  ]
[                                        ]
[VB [ (record-length [block-length] ) ]  ]
[   [                [FULLTRK     ]   ]  ]
[                                        ]
[VBS [ ( record-length [block-length] ) ] ]
[    [                [FULLTRK     ]   ] ]
Easytrieve  supports fixed (F), variable (V), and undefined (U) formats. Fixed and variable length records can be
blocked (FB,VB), though the blocking factor is ignored on non-mainframe platforms.
[VBS] (return to top)
(z/OS only) z/OS systems can process Variable Block Spanned (VBS) records using BFTEK=A
processing.
 904 Easytrieve ® Report Generator 11.6
[record-length] (return to top)
Record-length  specifies the maximum record length.
[block-length] (return to top)
Block-length  specifies the file's maximum block length.
For mainframe variable format files, allow four bytes of the record length for the Record Description Word
(RDW) and, if the file is blocked, four bytes of the block size for the Block Description Word (BDW).
NOTE
To obtain an MVS/DFP system determined block size within  Easytrieve  on the mainframe, do
one of the following:
•Include the DSORG, LRECL and RECFM parameters in the original JCL or TSO dynamic
allocation. This forces SMS to establish the block size before  Easytrieve  gets control in
OPEN processing. This is applicable for disk data sets only.
•Define a value of zero for the block length value. If you want  Easytrieve  to pick up the
logical record length from your JCL, code a zero for record-length. You must also code a
BLKSIZE=0 in your JCL or code no BLKSIZE parameter at all.
Examples
FILE file-name FB(0 0)
This tells  Easytrieve  to pick up the LRECL from the JCL and to utilize the block size set by SMS.
FILE file-name FB(150 0)
This tells  Easytrieve  to pick up the LRECL from this definition and to utilize the block size set by SMS.
FILE file-name FB(150 3000)
This tells  Easytrieve  to pick up this definition and ignore both the JCL and the SMS-determined block size.
NOTE
If you code a zero block size within  Easytrieve  or in your JCL, and your data set is not SMS managed,
your program will abend with a 013 open problem.
[FULLTRK] (return to top)
A block length designation of FULLTRK establishes an output block size that equals the maximum track capacity
of the direct access device, or the next lower multiple of record size for FB files.
[WORKAREA area-length ] (return to top)
The WORKAREA option establishes the number of bytes to be allocated as a work area for the file. WORKAREA
cannot be coded if the CARD parameter is specified. Area-length  specifies the number of bytes to be allocated
and must be large enough to contain the longest record processed.
WORKAREA allows you to reference the fields in a file prior to the normal allocation of a file's data buffer. For
more information, see File Processing .
Note:  WORKAREAs are not initialized by  Easytrieve .
[TABLE] (return to top)
The TABLE option declares the file as the source for a SEARCH statement to access a table.
NOTE
VARYING length fields cannot be used for TABLE files.
[INSTREAM] or [max-table-entries]
The INSTREAM option indicates that the table file immediately follows the file description. The size of an
INSTREAM table is limited only by the amount of available memory. Max-table-entries  specifies the maximum
number of entries in an external table. If INSTREAM or max-table-entries  is not specified, the file is an external
table whose maximum number of entries is limited by the site option TBLMAX.
 905 Easytrieve ® Report Generator 11.6
[BUFNO buffers ] (return to top)
BUFNO establishes the number of buffers allocated for the file. Buffers  can be 1 to 255 for MVS programs. The
default value is obtained from the Site Options Table.
[DEFER] (return to top)
Coding the DEFER option instructs  Easytrieve  to delay the opening of the file until the first input or output
operation for the file occurs. The default opens all referenced files at the beginning of each  Easytrieve  activity.
[ASA] (return to top)
For MVS, the optional ASA parameter sets the DCB A option for RECFM.
For non-mainframe platforms, the optional ASA parameter causes output records to be written using the set of
mainframe ASA characters in column one. Without ASA, all records are formatted using ASCII printer control
characters.
[EXTENDED xrpt-printer ] (return to top)
The EXTENDED parameter indicates that the file is to be associated with an extended reporting printer. This
means that input/output statements (GET, PUT, READ, WRITE) cannot reference these printer files. However, the
DISPLAY statement and REPORT statements can reference these printer files. Unless you code them, record
length and block size default to those defined for the printer in the printer set definition module.
Xrpt-printer  identifies the extended reporting printer whose characteristics are to be associated with this file. You
must define the xrpt-printer  in the printer set definition module.
For more information, see Extended Reporting  and the Programming  section.
[CODE {EBCDIC|ASCII| dbcs-code-name }] (Mainframe only) (return to top)
Use CODE dbcs-code-name  to define the DBCS code system to be used for all K and M fields for this file. If this
is not specified, the default is taken from the CODE parameter on the PARM statement for this program. If the
CODE parameter is not specified on the PARM statement, then the default is taken from the processing code
system as defined in the CA-PSI Subsystems DBCS Options table.
[KEY key-field-name ] (return to top)
Use the KEY parameter to specify the key field for your non-mainframe ISAM file.  Easytrieve  uses this
parameter only when the file is created. After the file is created, this parameter is ignored and key information is
obtained from the access method. If KEY is not specified during creation, the first field defined in the file is used
as the key field.
Data Set Types
SYSNAME {' file-identifier '} or SYSNAME { file-identifier-field-name } (return to top)
Code SYSNAME to associate an  Easytrieve  file with an external data set.
file-identifier
Must be an alphanumeric string.
file-identifier-field-name
Must be defined as an alphanumeric field of the required length.
The value of file-identifier-field-name  is accessed when the file is opened. The required length and the set
of valid characters depend on the file type, the implementation, and the operating system.
NOTE
If SYSNAME is not specified, the file-name  specified after the FILE keyword is used. The length
of file-name  must conform to operating system standards.
For CICS:
For file types SEQUENTIAL, INDEXED, and RELATIVE, this is the FCT name of the associated
VSAM data set. The requirements for the format of the file-identifier character string are the same as
the requirements for the FCT name. If fewer than eight characters are provided, the value is padded
with blanks on the right to obtain a string of eight characters. File-identifier-field-name must be an
alphanumeric field of any format. Only uppercase alphabetic and numeric digits are allowed. The first
 906 Easytrieve ® Report Generator 11.6
character must not be a digit. If File-identifier-field-name is defined with a length greater than eight, the
FCT name must reside in the first 8 (or less) bytes with the remainder set to blanks.
For device type PRINTER, the SYSNAME parameter cannot be used. An execution error occurs.
For TSO:
For file types SEQUENTIAL, INDEXED, and RELATIVE, and device type PRINTER, this is the DDname
of the associated data set. The requirements for the format of the file-identifier character string are the
same as the requirements for the DDname. If fewer than eight characters are provided, the value is
padded with blanks on the right to obtain a string of eight characters. File-identifier-field-name must be
an alphanumeric field of any format. Only uppercase alphabetic and numeric digits are allowed. The first
character must not be a digit. If File-identifier-field-name is defined with a length greater than eight, the
DDname must reside in the first 8 (or less) bytes with the remainder set to blanks.
For data set type VIRTUAL, the SYSNAME parameter is ignored.
For CMS:
For file types SEQUENTIAL, INDEXED, and RELATIVE, and device type PRINTER, this is the FILEDEF
or DLBL name of the associated data set. The requirements for the format of the file-identifier character
string are the same as the requirements for the FILEDEF or DLBL. If fewer than eight characters are
provided, the value is padded with blanks on the right to obtain a string of eight characters. File-identifier-
field-name must be an alphanumeric field of any format. Only uppercase alphabetic and numeric
digits are allowed. The first character must not be a digit. If File-identifier-field-name is defined with a
length greater than eight, the FILEDEF or DLBL name must reside in the first 8 (or less) bytes with the
remainder set to blanks.
For non-mainframe platforms:
For SEQUENTIAL, INDEXED, and RELATIVE file types and the PRINTER device type, SYSNAME
is either a file description string or an environment variable specifying the file description string. If the
value of SYSNAME contains a path separator (/ or \), it is treated as a file description string. If it does not
contain a path separator,  Easytrieve  searches for an environment variable with the same name. If such a
variable is found, the value of the variable is used as the file description string. If the variable is not found,
the SYSNAME value is used as the path.
For more information about the file description string, see File Description String (Non-Mainframe Only) .
The length of SYSNAME is limited to the lesser of 256 characters or the maximum path length supported
by your operating system.
[VIRTUAL] (return to top)
VIRTUAL identifies a file as an  Easytrieve  Virtual File Manager (VFM) file.  Easytrieve  virtual files are temporary
sequential work files that are normally deleted after the file is read and closed.
[RETAIN]
RETAIN inhibits the automatic deletion of a VFM file after it is read. The file is deleted if it is opened for
OUTPUT or CREATE in a subsequent JOB activity or at program termination.
[MEMORY] or [DISK]
MEMORY and DISK indicate the type of CICS temporary storage that  Easytrieve  is to use for storing this
file. MEMORY indicates a main storage resident temporary storage queue in CICS. DISK indicates an
auxiliary storage resident temporary storage queue. DISK is the default.
[TERMINAL] (return to top)
Code the TERMINAL parameter to route the output for this printer file to an online terminal. The TERMINAL
parameter is mutually exclusive with the SPOOL, VIRTUAL, and SYSNAME parameters.
A device type of PRINTER is implied.
[ID {'terminal-id-literal '}] or [ID {terminal-id-field-name }] (CICS only)
Specify the name of the destination terminal in ' terminal-id-literal ' or terminal-id-field-name . This terminal
can be either a display terminal or an online printer. Any valid terminal ID is accepted.
When ID is not specified, output directed to this file is spooled until the file is closed. The output can then
be browsed at the originating terminal using the Report Display Facility. You can also then print the file.
 907 Easytrieve ® Report Generator 11.6
[NOFORMFEED]
Code NOFORMFEED to indicate that the form feed character cannot be used to start a new page. If
NOFORMFEED is not specified, then  Easytrieve  can use the form feed character to start a new page.
NEWPAGE [BEFORE] or NEWPAGE [AFTER]
Code NEWPAGE to eject the page each time the file is opened and each time it is closed. Specify
NEWPAGE BEFORE to eject the page each time the file is opened. Specify NEWPAGE AFTER to eject
the page each time the file is closed.
If NEWPAGE is not specified,  Easytrieve  does nothing to position the page.
[SPOOL] (return to top)
Code the SPOOL parameter to route the output for this printer file to the operating system spooling subsystem.
The SPOOL parameter is mutually exclusive with the VIRTUAL, TERMINAL and SYSNAME parameters. In CMS,
the printer device must be spooled to RSCS. SPOOL is ignored in non-mainframe platforms.
A device type of PRINTER is implied.
CLASS {'spool-class-literal'} or CLASS {spool-class-field-name}
Code CLASS to specify the spool class for the file. CLASS can be specified as a literal or as a field name.
Any valid class is accepted.
The default is CLASS A.
NODE {'destination-literal '} or NODE { destination-field-name }
Code NODE to specify the destination for the file. This destination is usually a local or remote printer
device name or a network node name, but can be anything meaningful to the operating system spooling
subsystem.
NODE can be specified as a literal or as a field name. Any valid node is accepted.
Note:  If NODE is not specified, the destination for the file is not passed to the operating system spooling
subsystem.
USERID {' user-id-literal '} or USERID { user-id-field-name }
Code USERID to specify the user of the printed output. The NODE subparameter must also be specified
and must contain a network node name.
USERID can be specified as a literal or as a field name. Any valid user ID is accepted.
Note:  If the USERID subparameter is not specified, the user ID is not passed to the operating system
spooling subsystem.
For mainframe tape files, if no BLKSIZE is explicitly specified on the FILE statement or in the JCL, the SAM Large Block
Interface (LBI) is used. This allows block sizes larger than 32760 for tape files.
Examples
The following examples illustrate FILE statements for various files.
Sequential (SAM) Files in z/OS
To define a sequential (SAM) file in z/OS, use:
FILE SEQFILE
Entry-sequenced, Fixed-length VSAM Files
To load an entry-sequenced, fixed-length VSAM file, use:
FILE  ENTSEQ SEQUENTIAL F CREATE RESET
Virtual Files with RETAIN
To define a virtual file with RETAIN, use:
FILE VRTFILE V(200)    +
     VIRTUAL RETAIN
 908 Easytrieve ® Report Generator 11.6
Printer Files to Be Viewed at the Terminal
To define a printer file to be viewed at the terminal, use:
FILE PRTFILE PRINTER (PAGESIZE 20 LINESIZE 80)   +
     TERMINAL
GET Statement
The GET Statement in  Easytrieve  places the next or previous sequential record of the named file into the file's record
buffer.
To ensure record availability when using the GET statement, you must test for end-of-file (EOF) or file presence (IF file-
name ). If you specify GET PRIOR, an EOF means you have reached the beginning of the file.
When you reverse the direction of a GET statement by using GET PRIOR, the record returned is the record immediately
preceding the record previously placed in the file's record buffer. When you reverse the direction of a GET PRIOR
statement by using only GET, the record returned is the record immediately following the record previously placed in the
field's record buffer.
You cannot issue a GET PRIOR statement following a POINT statement, or a GET statement following a POINT PRIOR
statement. For more information, see POINT Statement in "Statements N - R."
You cannot use GET for a file designated as automatic input. To inhibit automatic input, specify INPUT NULL on the JOB
statement:
JOB INPUT NULL
You can use GET to access a secondary file while automatically accessing a primary file.
This statement has the following format:
                      [HOLD  ]         
GET file-name [PRIOR] [      ] [STATUS]
                      [OHOLD ]        
file-name
File-name  identifies the input file defined in the library section. File-name can be any file type except SQL.
[PRIOR]
Specify PRIOR to place the previous sequential record of the named file into the file's record buffer. If you specify
PRIOR and the position in the file is not established, the last record in the file is placed in the file's record buffer.
Note:  If the access method of the operating system does not support retrieval of previous records, an execution
error occurs.
[HOLD] or [NOHOLD]
Except in CICS,  Easytrieve  automatically issues a hold request for records when UPDATE is specified on the
FILE statement. Use NOHOLD to override this process. In CICS, NOHOLD is the default.
Specify HOLD to hold a record for update. HOLD is invalid if UPDATE is not specified on the FILE statement.
HOLD does not mean you are required to perform the update; it holds the position in the file. Records are
automatically released when the update operation completes or a commit point is taken. You can also manually
release the hold on any record with the RELEASE statement.
NOHOLD specifies that a record is not to be held for update.
NOTE
In CICS, if you specify HOLD, you cannot browse (GET) a file; an execution error occurs. When you
want to update a record, use the READ statement.
 909 Easytrieve ® Report Generator 11.6
[STATUS]
Specify STATUS whenever the possibility exists for an unsatisfactory completion of the input/output request.
STATUS checks input/output processing to see if it was performed properly. STATUS causes the file's FILE-
STATUS field to be set with the appropriate return code. For information about how to determine the meaning of
the contents of FILE-STATUS, see the appendix "System-Defined Fields." Normally, a zero or non-zero test is
sufficient.
NOTE
FILE-STATUS is not defined if you do not specify a file type parameter on the FILE statement.
If you do not code STATUS and the operating system returns a non-zero status,  Easytrieve  issues an
appropriate diagnostic message.
Examples
The following code illustrates the use of the GET statement:
FILE PERSNL INDEXED
%PERSNL
PROGRAM NAME MYPROG    GET PERSNL STATUS
   IF PERSNL:FILE-STATUS NE 0
     DISPLAY PERSNL:FILE-STATUS
   ELSE
     DISPLAY HEX PERSNL
   END-IF
The following code illustrates testing for EOF when using the GET statement:
FILE MASTER
... GET MASTER
  IF EOF MASTER
     STOP
  END-IF
...
GOTO Statement
The GOTO statement in  Easytrieve  modifies the natural top to bottom logic flow of statement execution.
The GOTO statement has the following format:
{GOTO }  { label }
{     }  {JOB   }
{GO TO}  {SCREEN}
{label}
Specify label  to immediately transfer execution control to the first statement following the associated label.
Processing then continues in a top-to-bottom sequence. The label must be contained in the same activity or
procedure. A label:
 910 Easytrieve ® Report Generator 11.6
•Can be up to 128 alphanumeric characters in length
•Can contain any character other than a delimiter
•Can begin with A to Z, 0 to 9, or a national character (#, @, $)
•Must not consist of all numeric characters.
A statement label  is a complete  Easytrieve  statement that you can code before the following statements:
 911 Easytrieve ® Report Generator 11.6
•Assignment
•CASE
•COMMIT
•DELETE
•DLI
•END-DO
•END-PROC
•EXIT
•GET
•IDMS
•INSERT
•MOVE
•PERFORM
•PRINT
•READ
•RELEASE
•ROLLBACK
•SELECT (except non-file SQL)
•SQL
•STOP
•UPDATE
•CALL
•CLOSE
•CURSOR
•DISPLAY
•DO
•END-IF
•EXECUTE
•FETCH
•GOTO
•IF
•MESSAGE
•MOVE LIKE
•POINT
•PUT
•REFRESH
•RESHOW
•SEARCH
•SET
•Statement label
•TRANSFER
•WRITE
{JOB}
GOTO JOB causes an immediate branch to the top of the current JOB activity. It does not include execution of the
START procedure. When used in a START procedure, GOTO JOB terminates the START procedure. When used
in a FINISH procedure, GOTO JOB terminates the FINISH procedure.
 912 Easytrieve ® Report Generator 11.6
{SCREEN}
GOTO SCREEN branches immediately to the top of the current SCREEN activity, including execution of the
BEFORE-SCREEN procedure. It does not include execution of the INITIATION procedure. When used in an
INITIATION procedure, GOTO SCREEN terminates the INITIATION procedure.
GOTO SCREEN cannot be coded in a BEFORE-SCREEN procedure. If GOTO SCREEN is coded in a
TERMINATION procedure, GOTO SCREEN terminates the screen activity.
Example
The following example illustrates the use of GOTO in a program. The arrows indicate that control is passed to the first
executable statement following the label or job statement.
HEADING Statement
The HEADING statement in  Easytrieve  defines an alternative heading for a field. Using the HEADING statement in a
report allows you to override the default field headings for that report.
The HEADING statement overrides default field headings defined in the library section. The HEADING statement also
provides alternative heading capabilities for system-defined fields such as TALLY and LEVEL.
This statement has the following format:
HEADING field-name ([#font-number] 'heading-literal'...)
field-name
For reports, field-name specifies a field in your program. The heading you define is used for fields identified on
LINE 01 of your report declaration.
 913 Easytrieve ® Report Generator 11.6
[#font-number ]
#Font-number  defines the number of a font that  Easytrieve  uses to format ' heading-literal ' in the heading area of
a report. You can only specify #font-number  if you direct the report to an extended reporting printer. If you direct
the report to a normal printer, a syntax error occurs when you code #font-number . You can specify a unique font
index for each ' heading-literal ' by coding the # sign and a value for # font-number  before ' heading-literal '. Any
'heading-literal ' that does not have a font index assigned uses the default font for the assigned extended reporting
printer.
'heading-literal '
'Heading-literal ' can be up to 128 characters in length.
For reports, a single line of alphanumeric text replaces the default header and prints as a header over a column
or field. Multiple literals, each enclosed within single quotes ('') and separated by one or more blanks within the
parentheses, are stacked vertically over the column or field when printed.
Examples
The following example illustrates various report heading options:
Statements:
 
FILE PERSNL FB(150 1800)
  SSN              4   5 P MASK '999-99-9999' +           HEADING('SOCIAL' 'SECURITY' 'NUMBER')
  EMPNAME            17   20 A 
    NAME-LAST  EMPNAME     8 A 
    NAME-FIRST EMPNAME +8 12 A 
  PAY-NET         90    4 P 2 
JOB INPUT PERSNL NAME MYPROG 
  PRINT REPORT1 
* 
REPORT REPORT1 LINESIZE 65   HEADING PAY-NET ('NET', 'PAY')
  LINE EMPNAME SSN '* NO OVERTIME *' PAY-NET
Results: 
                        SOCIAL 
                       SECURITY                         NET 
       EMPNAME          NUMBER                          PAY 
   WIMN    GLORIA     025-30-5228   * NO OVERTIME *     251.65 
   BERG    NANCY      121-16-6413   * NO OVERTIME *     547.88
IDD FILE Statement
The IDD FILE statement in  Easytrieve  identifies a non- IDMS  file in the IDD and builds file and field definitions.
The file-name  can be qualified by the file-name' s version. All records defined within the file are used to generate the file's
field definitions, unless the optional SELECT parameter identifies specific records to be used.
This statement has the following format:
                   [        {HIGHEST}]                                 
 914 Easytrieve ® Report Generator 11.6
IDD FILE file-name [VERSION {LOWEST }]  +                              
                   [        { nnnn   }]                                 
                                                                       
                   [SELECT ( record-name...)]  +                        
                                                                       
                   [FILENAME new-file-name]                           
file-name
File-name  is the one to 32-character name that specifies the IDD file. File-name  becomes the name of the FILE
created by the IDD FILE statement. To override this name, see the FILENAME parameter.
[VERSION {HIGHEST}] or [VERSION {LOWEST}] or [VERSION { nnnn }]
Specify HIGHEST, LOWEST, or nnnn  (a positive integer) as the version of the file.
[SELECT ( record-name  ...)]
Record-name  is a 1- to 32-character name that identifies a record of the file-name  defined. Repeat the record-
name  to identify as many records as needed. If you want to define all the field definitions for the file-name , omit
the SELECT clause.
[FILENAME new-file-name ]
New-file-name  is a 1- to 128-character name specifying the name of the file created by the IDD FILE statement.
IDD NAME Statement
The IDD NAME statement in  Easytrieve  establishes or re-establishes the dictionary entity retrieval environment,
and specifies the program name, the database name of the data dictionary, the Central Version Node, and the Secondary
Load Area's dictionary name and dictionary node.
IDD entities are retrieved from the designated dictionary/node until the environment is altered by issuing another IDD
NAME statement. You can use the IDD NAME statement as many times as required and before any other IDD statement.
However, you can use the PROGRAM-NAME parameter only once.
This statement has the following format:
 IDD NAME [PROGRAM-NAME ' program-literal']  +                           
          [DBNAME ' db-name-table-literal']  +                           
          [NODE ' node-literal']  +                                      
          [DICTNAME ' dictionary -literal']  +                            
          [DICTNODE ' dictionary -node-literal']                         
[PROGRAM-NAME ' program-literal ']
'Program-literal ' identifies the program name used to access an authorized subschema. ' Program-literal ' must be
alphanumeric and is padded to the right (if necessary) to create an eight-byte value.
[DBNAME ' db-name-table-literal ']
'Db-name-table-literal ' identifies the DB Name Table of the data dictionary that contains definitions of schema,
subschema, records, and fields. ' Db-name-table-literal ' must be alphanumeric and is padded to the right (if
necessary) to create an eight-byte value.
[NODE 'node-literal ']
'Node-literal ' specifies the IDMS  Central Version Node that will process  Easytrieve  IDD requests. ' Node-literal '
must be alphanumeric and is padded to the right (if necessary) to create an eight-byte value.
[DICTNAME ' dictionary-literal ']
'Dictionary-literal ' identifies the Secondary Load Area dictionary name. ' Dictionary-literal ' must be alphanumeric
and is padded to the right (if necessary) to create an eight-byte value.
 915 Easytrieve ® Report Generator 11.6
[DICTNODE ' dictionary-node-literal ']
'Dictionary-node-literal ' identifies the Secondary Load Area dictionary node. ' Dictionary-node-literal ' must be
alphanumeric and is padded to the right (if necessary) to create an eight-byte value.
IDD RECORD Statement
The IDD RECORD statement in  Easytrieve  identifies and defines IDMS  and non- IDMS  records.
The elements defined within the record are used to generate field definitions at the location specified. The IDD RECORD
statement identifies and defines IDMS  and non- IDMS  records. The record-name  can be qualified by the record's version.
The elements defined within the record are used to generate field definitions at the location specified.
This statement has the following format:
                       [        {HIGHEST}]                             
IDD RECORD record-name [VERSION {LOWEST }]  +                          
                       [        { nnnn   }]                             
                                                                       
  [         { start-position }]                                          
  [         {* [+ offset]   }]                                          
  [LOCATION {              }]                                          
  [         {W             }]                                          
  [         {S             }]                                         
record-name
The record-name is the 1- to 32-character name that specifies the IDD logical record or the IDD standard record.
[VERSION {HIGHEST}] or [VERSION {LOWEST}] or [VERSION { nnnn }]
Specify HIGHEST, LOWEST, or nnnn  (a positive integer) as the version of the file.
[LOCATION]
Use this optional parameter to specify the location at which the field definitions will be generated. If you do not
specify LOCATION, W (a W-type working storage field) is the default.
{start-position }
Start-position specifies the starting position relative to position one of the record.
{* [+offset ]}
The * (asterisk) indicates that the field begins in the next available starting position (highest position assigned
so far, plus 1). The optional +offset  is an offset you want added to the * value. There must be at least one blank
between the * and the optional + offset .
{W or S}
Coding W or S establishes a working storage field. W fields are spooled to report (work) files; S fields are not. W
is the default location if the LOCATION parameter is not coded.
IDD SUBSCHEMA Statement
The IDD SUBSCHEMA statement in  Easytrieve  identifies the subschema and builds the file, record, logical record,
element record, and field definitions for a subschema.
The subschema can be qualified by the schema and version. You can use the optional SELECT parameter to request that
only specific records be defined. If the SELECT parameter is omitted, the definitions of logical records are not generated.
Only database records can be defined in this way. The SELECT parameter must be used to generate logical record
definitions.
This statement has the following format:
 916 Easytrieve ® Report Generator 11.6
IDD SUBSCHEMA subschema -name  +                                         
              [                   [        {HIGHEST}]]                   
              [SCHEMA schema-name [VERSION {LOWEST }]]  +               
              [                   [        { nnnn   }]]                   
              [RESET]   +                                               
              [SELECT ( record-name...)]  +                              
              [FILENAME file-name]                                     
subschema-name
Subschema-name  is a 1- to 8-character name specifying the SUBSCHEMA that contains the record and field
definitions to be retrieved. Subschema-name  becomes the name of the FILE created by the IDD SUBSCHEMA
statement. For information about how to override this name, see FILENAME Parameter.
[SCHEMA schema-name  [VERSION {HIGHEST} or {LOWEST} or { nnnn }]]
Schema-name is the one to eight-character name that specifies the schema that owns the subschema (when a
subschema can be owned by multiple schemas). The optional VERSION parameter specifies the version of the
schema.
[RESET]
The optional RESET parameter requests that all element records under control of RETRIEVE be reset to binary
zero immediately prior to retrieving each root record.
[SELECT ( record-name  ...)]
The optional SELECT clause identifies specific subschema records. Record-name  is a one to 32-character name
that identifies a record for which the definition is accessed. Repeat record-name  to specifically identify all the
records you need. To access all the database records (but not logical records) defined for the subschema, you
can omit the SELECT parameter.
[FILENAME file-name ]
File-name  is a 1- to 128-character name specifying the name of the file created by the IDD SUBSCHEMA
statement.
IDD VERSION Statement
The IDD VERSION statement in Easytrieve set a global override of the Site Options Table VERFILE, VERREC, and
VERSCHM defaults.
Other IDD statements appearing after the IDD VERSION statement, that have VERSION parameters as part of their
syntax but no VERSION parameter coded, default to the version specified in the IDD VERSION statement. IDD
statements that have a VERSION parameter coded override the VERSION statement. The defaults specified by the IDD
VERSION statement remain in effect until another IDD VERSION statement is issued.
You can code as many IDD VERSION statements as you require. If the IDD VERSION statement is not used, the default
versions are retrieved from the Site Options Table.
This statement has the following format:
             [       {HIGHEST}]                                         
 IDD VERSION [SCHEMA {LOWEST }]  +                                      
             [       { nnnn   }]                                         
                                                                        
             [     {HIGHEST}]                                           
             [FILE {LOWEST }]  +                                        
             [     { nnnn   }]                                           
                                                                        
 917 Easytrieve ® Report Generator 11.6
             [       {HIGHEST}]                                         
             [RECORD {LOWEST }]                                         
             [       { nnnn   }]                                        
[SCHEMA {HIGHEST}] or {LOWEST} or { nnnn }]
Specify HIGHEST, LOWEST, or a positive integer (nnnn ) to identify the default version of the SCHEMA. Any
request to retrieve a subschema that specifies a schema but not a version uses this value.
[FILE {HIGHEST}] or {LOWEST} or { nnnn }]
Specify HIGHEST, LOWEST, or a positive integer (nnnn ) to identify the default version of any FILE to be retrieved
when the version is not specified on the IDD FILE statement.
[RECORD {HIGHEST}] or {LOWEST} or { nnnn }]
Specify HIGHEST, LOWEST, or a positive integer (nnnn ) to identify the default version of any RECORD to be
retrieved when the version is not specified on the IDD RECORD statement.
IDMS ACCEPT DBKEY Statement
The IDMS ACCEPT DBKEY statement in  Easytrieve  transfers database keys to program storage.
Format 1 returns the current database key for the record, set, or area specified. Format 2 returns the database key that is
the next, prior, or owner of the specified set. The IDMS ACCEPT DBKEY statement transfers database keys to program
storage. The IDMS ACCEPT DBKEY statement has two formats. Format 1 returns the current database key for the
record, set, or area specified. Format 2 returns the database key that is the next, prior, or owner of the specified set.
This statement has the following format:
Format 1
                                     [{RECORD} { currency -field-name}]  
IDMS ACCEPT DBKEY receive-field-name [{AREA  } {                   }]  
                                     [{SET   } {' currency -literal' }] 
Format 2
                                     {NEXT } { set-field-name}          
IDMS ACCEPT DBKEY receive-field-name {PRIOR} {              }          
                                     {OWNER} {' set-literal' }         
Format 1
receive-field-name
Receive-field-name  identifies the four-byte binary field to receive the specified database key.
{RECORD} or {AREA} or {SET}
Specify RECORD, SET, or AREA.
{currency-field-name } or {'currency-literal '}
Currency-field-name  or 'currency-literal'  identifies the currency for the desired key. Currency-field-name  must be
a 16-byte alphanumeric field. 'Currency-literal'  must be alphanumeric and is padded to the right (if necessary) to
create a 16-byte value. The default is the current record of the run-unit.
Format 2
receive-field-name
Receive-field-name  identifies the four-byte binary field to receive the specified database key.
{NEXT} or {PRIOR} or {OWNER}
Specify NEXT, PRIOR, or OWNER.
 918 Easytrieve ® Report Generator 11.6
{set-field-name } or {'set-literal '}
Set-field-name  or 'set-literal'  identifies the name of the desired set. Set-field-name  must be a 16-byte
alphanumeric field. 'Set-literal'  must be alphanumeric and is padded to the right (if necessary) to create a 16-byte
value.
IDMS ACCEPT PAGE-INFO Statement
The IDMS ACCEPT PAGE-INFO statement in  Easytrieve  transfers database page information to program storage.
This statement has the following format:
                                         {      } { currency -field-name}  
IDMS ACCEPT PAGE-INFO receive-field-name {RECORD} {                   }  
                                         {      } {' currency -literal' } 
receive-field-name
Receive-field-name  identifies the four-byte binary field to receive the page information.
{currency-field-name } or {'currency-literal '}
Currency-field-name  or 'currency-literal'  identifies the record name for the desired key. Currency-field-name  must
be a 16-byte alphanumeric field. 'Currency-literal'  must be alphanumeric and is padded to the right (if necessary)
to create a 16-byte value.
IDMS ACCEPT PROCEDURE Statement
The IDMS ACCEPT PROCEDURE statement in  Easytrieve  returns information from the Application Program Information
Block (APIB) associated with a database procedure to the program.
This statement has the following format:
                      { proc-field-name}                                
IDMS ACCEPT PROCEDURE {               } TO apib-field-name             
                      {' proc-literal' }                               
{proc-field-name } or {'proc-literal '}
Proc-field-name or 'proc-literal' identifies the name of a DBA-written database procedure. Proc-field-name must
be an eight-byte alphanumeric field. 'Proc-literal' must be alphanumeric and is padded to the right (if necessary) to
create an eight-byte value.
TO apib-field-name
Apib-field-name  is a 256-byte alphanumeric area of storage to which the APIB is copied.
IDMS ACCEPT STATISTICS Statement
The IDMS ACCEPT STATISTICS statement in  Easytrieve  retrieves the system statistics.
For more information about the statistics produced, see your IDMS  documentation.
This statement has the following format:
IDMS ACCEPT STATISTICS stat-field-name 
stat-field-name
Stat-field-name  identifies a 100-byte field that you must define in working storage to receive the current system
runtime statistical information.
 919 Easytrieve ® Report Generator 11.6
IDMS BIND Statement
The IDMS BIND statement in  Easytrieve  signs on the activity with the database management system.
This statement has the following format:
          { subschema -name     }                                       
IDMS BIND {                   }  +                                    
          {' subschema -literal'}                                       
                                                                      
       [             { program-name     }]                             
       [PROGRAM-NAME {                 }]  +                          
       [             {' program-literal'}]                             
                                                                      
       [       { db-name-table-name     }]                             
       [DBNAME {                       }]  +                          
       [       {' db-name-table-literal'}]                             
                                                                      
       [     { node-name     }]                                        
       [NODE {              }]  +                                     
       [     {' node-literal'}]                                        
                                                                      
       [         { dictionary -name     }]                              
       [DICTNAME {                    }]  +                           
       [         {' dictionary -literal'}]                              
                                                                      
       [         { dictionary -node-name     }]                         
       [DICTNODE {                         }]                         
       [         {' dictionary -node-literal'}]                        
{subschema-name } or {'subschema-literal '}
Subschema-name  identifies the subschema to be processed with IDMS . Subschema-name  must be an eight-byte
alphanumeric field. 'Subschema-literal'  must be alphanumeric and is padded to the right (if necessary) to create
an eight-byte value.
[PROGRAM-NAME { program -name }] or [PROGRAM-NAME {' program -literal '}]
Program-name  or 'program-literal'  specifies the name used to identify the program to IDMS  during execution.
Program-name  must be an eight-byte alphanumeric field. 'Program-literal'  must be alphanumeric and is padded to
the right (if necessary) to create an eight-byte value.
[DBNAME { db-name -table -name }] or [DBNAME {' db-name -table -literal '}]
Db-name-table-name  or 'db-name-table-literal'  specifies a DB Name Table. Data retrieved during execution of
the user's program will be from the named database. Db-name-table-name  must be an eight-byte alphanumeric
field. 'Db-name-table-literal'  must be alphanumeric and is padded to the right (if necessary) to create an eight-byte
value.
[NODE {node -name }] or [NODE {' node -literal '}]
Node-name  or 'node-literal'  specifies the Central Version Node that will host the IDMS  activity generated by the
user's program. Node-name  must be an eight-byte alphanumeric field. 'Node-literal'  must be alphanumeric and is
padded to the right (if necessary) to create an eight-byte value.
[DICTNAME { dictionary -name }] or [DICTNAME {' dictionary -literal '}]
Dictionary-name  or 'dictionary-literal'  specifies the dictionary name of a secondary load area. Dictionary-name
must be an eight-byte alphanumeric field. 'Dictionary-literal'  must be alphanumeric and is padded to the right (if
necessary) to create an eight-byte value.
 920 Easytrieve ® Report Generator 11.6
[DICTNODE {dictionary-node-name}] or [DICTNODE {'dictionary-node-literal'}]
Dictionary-node-name  or 'dictionary-node-literal'  specifies the dictionary node of a secondary load area.
Dictionary-node-name  must be an eight-byte alphanumeric field. 'Dictionary-node-literal'  must be alphanumeric
and is padded to the right (if necessary) to create an eight-byte value.
IDMS BIND FILE Statement
The IDMS BIND FILE statement in  Easytrieve  gives the database management system access to the record in program
storage.
This statement has the following format:
IDMS BIND FILE file-name RECORD record-name 
file-name
File-name  identifies the file where the record-area is to be allocated.
RECORD record -name
Record-name  identifies the record to be bound with IDMS .
IDMS BIND PROCEDURE Statement
The IDMS BIND PROCEDURE statement in  Easytrieve  establishes communications between a program and a DBA-
written database procedure.
This statement has the following format:
                    { proc-field-name}                                  
IDMS BIND PROCEDURE {               } TO receive-field-name            
                    {' proc-literal' }                                 
{proc-field-name } or {'proc-literal '}
Proc-field-name  or 'proc-literal ' identifies the name of a DBA-written database procedure. Proc-field-name  must
be an eight-byte alphanumeric field. ' Proc-literal ' must be alphanumeric and is padded to the right (if necessary) to
create an eight-byte value.
TO receive-field-name
Receive-field-name  must be a 256-byte alphanumeric field. The contents of receive-field-name  are copied to the
APIB as part of the execution of the IDMS BIND PROCEDURE statement.
IDMS COMMIT Statement
The IDMS COMMIT statement in  Easytrieve  requests the creation of a checkpoint.
This statement has the following format:
IDMS COMMIT [ALL]                                                     
[ALL]
This optional parameter controls which locks are released. The default is ALL EXCEPT THOSE HELD.
IDMS CONNECT Statement
The IDMS CONNECT statement in  Easytrieve  establishes a record as a member of a set occurrence.
 921 Easytrieve ® Report Generator 11.6
This statement has the following format:
                    { record-field-name}     {set-field-name}           
IDMS CONNECT RECORD {                 } SET {              }           
                    {' record-literal' }     {' set-literal' }          
{record-field-name } or {'record-literal '}
Record-field-name  or 'record-literal ' identifies the record to be connected. Record-field-name  must be a 16-byte
alphanumeric field. ' Record-literal ' must be alphanumeric and is padded to the right (if necessary) to create a 16-
byte value.
{set-field-name } or {'set-literal '}
Set-field-name  or 'set-literal ' specifies the set to which the record is to be connected. Set-field-name  must be a 16-
byte alphanumeric field. ' Set-literal ' must be alphanumeric and is padded to the right (if necessary) to create a 16-
byte value.
IDMS DISCONNECT Statement
The IDMS DISCONNECT statement in  Easytrieve  cancels the relationship between a record and a set occurrence.
This statement has the following format:
                       { record-field-name}     {set-field-name}        
IDMS DISCONNECT RECORD {                 } SET {              }        
                       {' record-literal' }     {' set-literal' }       
RECORD { record-field-name } or RECORD {' record-literal '}
Record-field-name  or 'record-literal'  identifies the record to be disconnected. Record-field-name  must be a 16-byte
alphanumeric field. 'Record-literal'  must be alphanumeric and is padded to the right (if necessary) to create a 16-
byte value.
SET {set-field-name } or SET {' set-literal '}
Set-field-name  or 'set-literal'  specifies the set from which the record is to be disconnected. Set-field-name  must be
a 16-byte alphanumeric field. 'Set-literal'  must be alphanumeric and is padded to the right (if necessary) to create
a 16-byte value.
IDMS ERASE Statement
Format 1 of the IDMS ERASE statement in  Easytrieve  makes a record unavailable for further processing and removes it
from all set occurrences. Format 2 makes a logical record unavailable for further processing.
This statement has the following format:
Format 1
                                      [MEMBERS  ]                      
                  { record-field-name} [PERMANENT]                      
IDMS ERASE RECORD {                 } [         ]                      
                  {' record-literal' } [SELECTIVE]                      
                                      [ALL      ]                     
Format 2
                                                                       
 922 Easytrieve ® Report Generator 11.6
IDMS ERASE RECORD logical-record-name [WHERE ( boolean-expression )]     
Format 1
RECORD { record-field-name } or RECORD {' record-literal '}
Record-field-name  or 'record-literal'  identifies the record to be erased. Record-field-name  must be a 16-byte
alphanumeric field. 'Record-literal'  must be alphanumeric and is padded to the right (if necessary) to create a 16-
byte value.
[MEMBERS] or [PERMANENT] or [SELECTIVE] or [ALL]
This optional parameter controls the type of erasure. The default is MEMBERS.
Format 2
RECORD logical-record-name
Logical-record-name  is a one to 16-character name that identifies the logical record to be erased. Logical-record-
name  must be the name of a logical record defined by a LOGICAL-RECORD statement.
[WHERE ( boolean-expression )]
Code the optional WHERE clause to provide a Boolean expression IDMS  uses to select the logical records to be
erased.
IDMS FIND and IDMS OBTAIN Statements
The IDMS FIND statement in  Easytrieve  locates a record. The IDMS OBTAIN statement locates and then retrieves a
record. Review the six formats of these statements.
The IDMS FIND and IDMS OBTAIN statements are described together because their formats are the same. The IDMS
FIND statement only locates (positions to) a record; the IDMS OBTAIN statement locates and then retrieves a record.
These statements have six formats:
•Format 1 locates/retrieves a record based on its DBKEY.
•Format 2 locates/retrieves the current occurrence of the record type, set, or area.
•Format 3 locates/retrieves a record within a set or area.
•Format 4 locates/retrieves the owner record within the set.
•Format 5 locates/retrieves a record based on its CALC key.
•Format 6 locates retrieves an ordered (sorted) record from a set.
NOTE
For information about how to retrieve logical records, see IDMS OBTAIN Statement in this article.
This statement has the following format:
Format 1
                                     [            { record-field-name}]
                                     [   RECORD   {                 }]
     {FIND  }       { key-field-name} [            {' record-literal' }] [SHARE|SHR    ]
 IDMS {      } DBKEY {              } [                               ] [             ]
     {OBTAIN}       {' key-literal' } [            { page-field-name  }] [EXCLUSIVE|EXC]
                                     [  PAGE-INFO {                 }]
                                     [            {' page-literal'   }]
Format 2
     {FIND  }         [{RECORD} { field-name}] [SHARE|SHR    ]                 
IDMS {      } CURRENT [{SET   } {          }] [             ]                 
 923 Easytrieve ® Report Generator 11.6
     {OBTAIN}         [{AREA  } {' literal' }] [EXCLUSIVE|EXC]                
Format 3
     {FIND  }# {NEXT                 }  [       { record-field-name}]            
IDMS {      }# {PRIOR                }  [RECORD {                 }]  +         
     {OBTAIN}# {FIRST                }  [       {' record-literal' }]            
              {LAST                  }                                          
              {     { nth-field-name} }                                          
              {NTH  {              } }                                          
              {     { nth-literal   } }                                          
                                                                                
     {SET } { search-field-name} [SHARE|SHR    ]                                 
     {    } {                 } [             ]                                 
     {AREA} {' search-literal' } [EXCLUSIVE|EXC]                                
Format 4
     {FIND  }           { set-field-name} [SHARE|SHR    ]                        
IDMS {      } OWNER SET {              } [             ]                        
     {OBTAIN}           {' set-literal' } [EXCLUSIVE|EXC]                       
Format 5
     {FIND  } {CALC     }        { record-field-name} [SHARE|SHR    ]            
IDMS {      } {         } RECORD {                 } [             ]            
     {OBTAIN} {DUPLICATE}        {' record-literal' } [EXCLUSIVE|EXC]           
Format 6
                                                                                
     {FIND  }                  { record-field-name}     {set-field-name}         
IDMS {      } [CURRENT] RECORD {                 } SET {              }  +      
     {OBTAIN}                  {' record-literal' }     {' set-literal' }         
                                                                                
            { control-field-name}     [SHARE|SHR    ]                            
     USING ({                  }...) [             ]                            
            {' control-literal' }     [EXCLUSIVE|EXC]                            
Format 1
DBKEY {key-field -name } or DBKEY {' key-literal '}
Key-field-name  or 'key-literal'  identifies the key of the database record. Key-field-name  must be a four-byte binary
field. 'Key-literal'  must be a four-byte hexadecimal value.
[RECORD { record -field -name }] or [RECORD {' record -literal '}]
Record-field-name  or 'record-literal'  identifies the record to be located/retrieved. Record-field-name  must be a 16-
byte alphanumeric field. 'Record-literal'  must be alphanumeric and is padded to the right (if necessary) to create a
16-byte value. The default is any record type that satisfies the DBKEY.
[PAGE-INFO {page -field -name}] or [PAGE-INFO {'page -literal '}]
Page-field-name  or 'page-literal'  identifies the record to be located/retrieved by its page information. Page-field-
name  must be a 4-byte binary field. 'Page-literal'  must be a 4-byte hexadecimal value.
 924 Easytrieve ® Report Generator 11.6
[SHARE|SHR] or [EXCLUSIVE|EXC]
These optional parameters determine the type of lock to be placed on the object record.
Format 2
[{RECORD|SET|AREA} { field -name| 'literal '}]
Field-name  or 'literal'  identifies the record, set, or area to be located/retrieved. Field-name  must be a 16-byte
alphanumeric field. 'Literal'  must be alphanumeric and is padded to the right (if necessary) to create a 16-byte
value. The default locates/retrieves the current record of the run-unit.
[SHARE|SHR] or [EXCLUSIVE|EXC]
These optional parameters determine the type of lock to be placed on the object record.
Format 3
{NEXT} or {PRIOR} or {FIRST} or {LAST} or {NTH { nth-field -name |nth-literal }}
Nth-field-name  or nth-literal  identifies the record occurrence of the set or area to be located/retrieved. Nth-field-
name  must be a four-byte binary integer. Nth-literal  must be a positive or negative integer.
[RECORD { record-field-name }|'record-literal '}]
Record-field-name  or 'record-literal'  identifies the record to be located/retrieved. Record-field-name  must be a 16-
byte alphanumeric field. 'Record-literal'  must be alphanumeric and is padded to the right (if necessary) to create a
16-byte value. The default is the record that otherwise satisfies the search criteria.
{SET|AREA}{ search-field-name |'search-literal '}
Search-field-name  or 'search-literal'  identifies the set or area that determines the scope of the search. Search-
field-name  must be a 16-byte alphanumeric field. ' Search-literal'  must be alphanumeric and is padded to the right
(if necessary) to create a 16-byte value.
[SHARE|SHR ] or [EXCLUSIVE|EXC]
These optional parameters determine the type of lock to be placed on the object record.
Format 4
OWNER SET { set-field-name |'set-literal '}
Set-field-name  or 'set-literal'  identifies the set to search. Set-field-name  must be a 16-byte alphanumeric field.
'Set-literal'  must be alphanumeric and is padded to the right (if necessary) to create a 16-byte value.
[SHARE|SHR] or [EXCLUSIVE|EXC]
These optional parameters determine the type of lock to be placed on the object record.
Format 5
{CALC} or {DUPLICATE}
This parameter determines whether the first (CALC) or next (DUPLICATE) record is located/retrieved.
RECORD { record-field-name|'record-literal' }
Record-field-name  or 'record-literal'  identifies the record to locate/retrieve. Record-field-name  must be a 16-byte
alphanumeric field. 'Record-literal'  must be alphanumeric and is padded to the right (if necessary) to create a 16-
byte value.
[SHARE|SHR] or [EXCLUSIVE|EXC]
These optional parameters determine the type of lock to be placed on the object record.
Format 6
[CURRENT]
This optional parameter controls the start of the search. The default begins with the owner of the current record
within the set.
 925 Easytrieve ® Report Generator 11.6
RECORD { record-field-name|'record-literal' }
Record-field-name  or 'record-literal'  identifies the record to locate/retrieve. Record-field-name  must be a 16-byte
alphanumeric field. 'Record-literal'  must be alphanumeric and is padded to the right (if necessary) to create a 16-
byte value.
SET {set-field-name|'set-literal' }
Set-field-name  or 'set-literal'  identifies the set to search. Set-field-name  must be a 16-byte alphanumeric field.
'Set-literal'  must be alphanumeric and is padded to the right (if necessary) to create a 16-byte value.
USING {control-field-name|'control-literal' }
Control-field-name or 'control-literal' identifies the control data item. The length and code system of the control
data item must match that in the database.
[SHARE|SHR] or [EXCLUSIVE|EXC]
These optional parameters determine the type of lock to be placed on the object record.
IDMS FINISH Statement
The IDMS FINISH statement in  Easytrieve  signs off the database management system.
This statement has the following format:
IDMS FINISH 
IDMS GET Statement
The IDMS GET statement in  Easytrieve  retrieves current data records.
This statement has the following format:
          [       { record-field-name}]                                 
IDMS GET  [RECORD {                 }]                                 
          [       {' record-literal' }]                                
RECORD { record-field-name|'record-literal '}
Record-field-name  or 'record-literal'  identifies the record to locate/retrieve. Record-field-name  must be a 16-byte
alphanumeric field. 'Record-literal'  must be alphanumeric and is padded to the right (if necessary) to create a 16-
byte value. The default record is the current record type of the run-unit.
IDMS IF Statement
The IDMS IF statement in  Easytrieve  tests the status of a set.
This statement has the following format:
                             {MEMBER  }                                
            { set-field-name} {NOMEMBER}                                
IDMS IF SET {              } {        }                                
            {' set-literal' } {EMPTY   }                                
                             {NOEMPTY }                               
SET {set-field-name|'set-literal' }
Set-field-name  or 'set-literal'  identifies the set to search. Set-field-name  must be a 16-byte alphanumeric field.
'Set-literal'  must be alphanumeric and is padded to the right (if necessary) to create a 16-byte value.
 926 Easytrieve ® Report Generator 11.6
{MEMBER} or {NOMEMBER} or {EMPTY} or {NOEMPTY}
This parameter determines the type of test:
•Specify MEMBER if the current record is a member of specified set.
•Specify NOMEMBER if the current record is not a member of specified set.
•Specify EMPTY if no member record occurrences exist.
•Specify NOEMPTY if member record occurrences exist.
The IDMS IF statement is similar to the  Easytrieve  IF statement in that a corresponding END-IF statement is required
and the ELSE statement is optional. For more information, see the following sections in this article:
•IF Statement
•ELSE-IF Statement
•ELSE Statement
•END-IF Statement
IDMS KEEP Statement
The IDMS KEEP statement in  Easytrieve  places a shared or exclusive lock on a record.
This statement has the following format:
          [{RECORD} { field-name}]                                     
IDMS KEEP [{SET   } {          }] [EXCLUSIVE]                         
          [{AREA  } {' literal' }]                                    
[{RECORD|SET|AREA} { field -name| 'literal '}]
Field-name  or 'literal'  identifies the desired record, set, or area to be locked. Field-name  must be a 16-byte
alphanumeric field. 'Literal'  must be alphanumeric and is padded to the right (if necessary) to create a 16-byte
value.
[EXCLUSIVE]
This optional parameter controls the lock for the record. The default is SHARED LOCK.
IDMS MODIFY Statement
Format 1 of the IDMS MODIFY statement in  Easytrieve  updates a record within the database. Format 2 updates a logical
record within the database.
This statement has the following format:
Format 1
                   { record-field-name}                                 
IDMS MODIFY RECORD {                 }                                 
                   {' record-literal' }                                
Format 2
IDMS MODIFY RECORD logical-record-name [WHERE ( boolean-expression )]   
Format 1
 927 Easytrieve ® Report Generator 11.6
RECORD { record-field-name|'record-literal' }
Record-field-name  or 'record-literal'  identifies the record to be modified. Record-field-name  must be a 16-byte
alphanumeric field. 'Record-literal'  must be alphanumeric and is padded to the right (if necessary) to create a 16-
byte value.
Format 2
RECORD logical-record-name
Logical-record-name  is a 1- to 16-character name that identifies the logical record to be modified by IDMS .
[WHERE ( boolean-expression )]
Code the optional WHERE clause to provide a Boolean expression to IDMS  to select the logical records to be
modified.
IDMS OBTAIN Statement
The IDMS OBTAIN statement in  Easytrieve  is used to retrieve logical records.
NOTE
For information about how to retrieve database records, see IDMS FIND and IDMS OBTAIN Statements.
This statement has the following format:
            {FIRST}                                                       
IDMS OBTAIN {     } RECORD logical-record-name [WHERE( boolean-expression )]
            {NEXT }                                                      
{FIRST} or {NEXT}
Specify FIRST to retrieve the first occurrence of the logical record. Specify NEXT to retrieve subsequent
occurrences.
RECORD logical-record-name
Logical-record-name  is a 1- to 16-character name that identifies the logical record to be retrieved. Logical-record-
name  must be the name of a logical record defined by a LOGICAL-RECORD statement.
[WHERE ( boolean-expression )]
Code the optional WHERE clause to provide a Boolean expression IDMS  uses to select the logical records to be
retrieved.
IDMS READY Statement
The IDMS READY statement in  Easytrieve  establishes area availability with the database manager.
This statement has the following format:
           [     { area-field-name}] [{RETRIEVAL} [PROTECTED]]           
IDMS READY [AREA {               }] [{         } [         ]]           
           [     {' area-literal' }] [{UPDATE   } [EXCLUSIVE]]          
[AREA {area-field-name|'area-literal' }]
Area-field-name  or 'area-literal'  identifies the area to be made available for processing. Area-field-name  must be a
16-byte alphanumeric field. 'Area-literal'  must be alphanumeric and is padded to the right (if necessary) to create
a 16-byte value. If not specified, all areas in the subschema are readied.
[{RETRIEVAL|UPDATE} [PROTECTED|EXCLUSIVE]]
These  optional parameters determine the type of access. The default is RETRIEVAL.
 928 Easytrieve ® Report Generator 11.6
IDMS RETURN Statement
The IDMS RETURN statement in  Easytrieve  retrieves the database key for an indexed record without retrieving the
record itself.
This statement has the following format:
                                          { set-field-name}             
IDMS RETURN DBKEY receive-field-name FROM {              }  +          
                                          {' set-literal' }             
                                                                       
           [KEY symbolic -key]   +                                      
                                                                       
           {                           }                               
           {CURRENCY                   }                               
           {FIRST [CURRENCY]           }                               
           {LAST [CURRENCY]            }                               
           {NEXT [CURRENCY]            }                               
           {PRIOR [CURRENCY]           }                               
           {                           }                               
           {       { key-field-name}    }                               
           {USING ({              }...)}                               
           {       {' key-literal' }    }                              
DBKEY receive-field-name
This is a four-byte binary field with zero (0) decimal places. This field receives the DBKEY of the indexed record.
FROM {set-field-name|'set-literal' }
Set-field-name  or 'set-literal'  identifies the index set to be accessed. Set-field-name  must be a 16-byte
alphanumeric field. 'Set-literal'  must be alphanumeric and is padded to the right (if necessary) to create a 16-byte
value.
[KEY symbolic-key ]
This parameter retrieves the record's symbolic key into symbolic-key . Symbolic-key  is the name of an
alphanumeric field that is large enough to contain the record's symbolic key.
{CURRENCY|FIRST [CURRENCY]|LAST [CURRENCY]|{NEXT [CURRENCY]|{PRIOR [CURRENCY]} {USING
{key-field -name| 'key-literal '}}
These parameters determine the record for which the database key is returned:
•CURRENCY -- the current index entry
•FIRST [CURRENCY] -- the first entry in the index
•LAST [CURRENCY] -- the last entry in the index
•NEXT [CURRENCY] -- the entry following current of index. If the current of index is the last entry, an error
status of 1707 (END OF INDEX) is returned.
•PRIOR [CURRENCY] -- the entry before current of index
•USING -- the first index entry whose symbolic key matches the key-field-name  or 'key-literal' . If no such entry
exists, a status code of 1726 (INDEX ENTRY NOT FOUND) is returned. The attributes of key-field-name  or
'key-literal'  must match the symbolic key of the index.
IDMS ROLLBACK Statement
The IDMS ROLLBACK statement in  Easytrieve  requests recovery.
This statement has the following format:
 929 Easytrieve ® Report Generator 11.6
IDMS ROLLBACK [CONTINUE]
[CONTINUE]
This optional parameter specifies the action taken after the recovery. The default is to terminate the run-unit.
IDMS STORE Statement
Format 1 of the IDMS STORE statement in  Easytrieve  places a new record occurrence into the database. Format 2
places a new logical record occurrence into the database.
This statement has the following format:
Format 1
                  { record-field-name}   
IDMS STORE RECORD {                 }   
                  {' record-literal' }  
Format 2
IDMS STORE RECORD logical-record-name [WHERE ( boolean-expression )]    
Format 1
RECORD { record-field-name|'record-literal' }
Record-field-name  or 'record-literal ' identifies the record to store. Record-field-name  must be a 16-byte
alphanumeric field. ' Record-literal ' must be alphanumeric and is padded to the right (if necessary) to create a 16-
byte value.
Format 2
RECORD logical-record-name
Logical-record-name  is a one to sixteen-character name that identifies the logical record that IDMS  stores.
[WHERE ( boolean-expression )]
Code the optional WHERE clause to provide a Boolean expression IDMS  uses to select the logical records to be
stored.
IF, ELSE-IF, ELSE, and END-IF Statements
The IF statement in  Easytrieve  controls execution of associated statements. ELSE-IF identifies a conditional expression
tested when the previous conditional expression is false. Associated statements are coded between IF and END-IF.
The truth value of conditional-expression-1  determines whether statement-1 is executed. If conditional-expression-1  is
true,  Easytrieve  executes statements designated by statement-1. If conditional-expression-1  is false,  Easytrieve  tests
conditional-expression-2 , if ELSE-IF is specified.
If ELSE-IF is specified, the truth value of conditional-expression-2  determines whether statement-2 is executed. If
conditional-expression-2  is true,  Easytrieve  executes statements designated by statement-2. If conditional-expression-2
is false,  Easytrieve  tests the conditional expression of the next ELSE-IF, if specified. If the conditional expression of the
last ELSE-IF statement is also false,  Easytrieve  executes statements designated by statement-3. You can nest as many
ELSE-IF statements within the IF as necessary. You must terminate the IF statement with a single END-IF.
If ELSE-IF is not specified and conditional-expression-1  is false,  Easytrieve  executes statements designated by
statement-3.
 930 Easytrieve ® Report Generator 11.6
If the ELSE statement is not specified and the conditional-expression is false, no statements are executed and control
passes to the statement following END-IF.
Statement-1, statement-2, and statement-3 each represent any number of  Easytrieve  statements. Whenever one or
more of these statements is an IF statement, the IF statements are considered to be nested. The format of nested IF
statements is that statement-1, statement-2, and statement-3 of any IF can be an IF statement.
This statement has the following format:
IF  conditional -expression -1
        [ statement -1]
 
[ELSE-IF  conditional -expression -2]  [ . . . ]
[             [ statement -2]       ]  [       ]
 
[ELSE            ]
[  [statement -3] ]
                  
END-IF
The following diagram illustrates IF, ELSE-IF, ELSE, and END-IF logic:
 931 Easytrieve ® Report Generator 11.6
conditional-expression
For conditional expression syntax, see Conditional Expressions in "Statements A - C."
ELSE-IF
ELSE-IF is optional and identifies a conditional expression to be tested when the previous conditional expression
is false. ELSE-IF statements allow multiple conditions to be nested without requiring an END-IF statement on
each condition. You can code as many ELSE-IF statements as necessary.
ELSE
ELSE is optional and identifies the statements to be executed when conditions are false. When the conditions of
the preceding IF or ELSE-IF are not satisfied,  Easytrieve  continues execution with the statement following ELSE.
NOTE
ELSE must be on a source statement by itself, unless it is followed by a period and a space.
END-IF
END-IF terminates the logic associated with the previous IF statement. An END-IF statement must be specified
after each IF statement and its associated statements. You do not specify an END-IF for an ELSE-IF.
Examples
 932 Easytrieve ® Report Generator 11.6
The following three examples illustrate the IF statement usage. In each of the illustrated cases, the field XMAS-BONUS
is computed to be three or five percent over PAY-GROSS. If the field PAY-GROSS is non-numeric, a warning message is
issued and the record is bypassed from further processing.
Example 1, Without Nested IF Statements:
FILE PERSNL FB(150 1800)                                                
%PERSNL                                                                 
XMAS-BONUS       W 4 P 2 VALUE 0                                        
TOT-XMAS-BONUS   W 6 P 2 VALUE 0                                        
*                                                                       
JOB INPUT PERSNL NAME MYPROG FINISH FINISH-PROC                          IF PAY-GROSS NOT NUMERIC 
     DISPLAY EMP# '  PERSONNEL RECORD IS DAMAGED'                       
     GO TO JOB                                                           END-IF    IF PAY-GROSS > 500.00 
     XMAS-BONUS = PAY-GROSS * 1.03                                        ELSE 
     XMAS-BONUS = PAY-GROSS * 1.05                                        END-IF 
   TOT-XMAS-BONUS = TOT-XMASBONUS +                                     
                    + XMAS-BONUS                                        
   PRINT MYREPORT                                                       
*                                                                       
FINISH-PROC. PROC                                                       
DISPLAY                                                                 
DISPLAY 'TOTAL $ SPENT IN BONUS ' +                                     
        'MONEY ====> ' TOT-XMAS-BONUS                                   
END-PROC                                                                
*                                                                       
REPORT MYREPORT                                                         
LINE NAME-LAST XMAS-BONUS                                              
Example 2, with Nested IF Statements:
FILE PERSNL FB(150 1800)                                                
%PERSNL                                                                 
XMAS-BONUS      W 4 P 2 VALUE 0                                         
TOT-XMAS-BONUS  W 6 P 2 VALUE 0                                         
*                                                                       
JOB INPUT PERSNL NAME MYPROG FINISH FINISH-PROC                          IF PAY-GROSS NOT NUMERIC 
     DISPLAY EMP# '  PERSONNEL RECORD IS DAMAGED'                       
     GOTO JOB                                                            ELSE   IF PAY-GROSS > 500.00 
        XMAS-BONUS = PAY-GROSS * 1.03                                    ELSE 
        XMAS-BONUS = PAY-GROSS * 1.05                                    END-IF   END-IF 
   TOT-XMAS-BONUS = TOT-XMAS-BONUS + XMAS-BONUS                         
   PRINT MYREPORT                                                       
*                                                                       
 933 Easytrieve ® Report Generator 11.6
FINISH-PROC. PROC                                                       
DISPLAY                                                                 
DISPLAY 'TOTAL $ SPENT IN BONUS ' +                                     
        'MONEY ====> ' TOT-XMAS-BONUS                                   
END-PROC                                                                
*                                                                       
REPORT MYREPORT                                                         
LINE NAME-LAST XMAS-BONUS     
Example 3, with ELSE-IF Statements:
FILE PERSNL FB(150 1800)                                                
%PERSNL                                                                 
XMAS-BONUS      W 4 P 2 VALUE 0                                         
TOT-XMAS-BONUS  W 6 P 2 VALUE 0                                         
*                                                                       
JOB INPUT PERSNL NAME MYPROG FINISH FINISH-PROC                          IF PAY-GROSS NOT NUMERIC 
     DISPLAY EMP# '  PERSONNEL RECORD IS DAMAGED'                       
     GOTO JOB                                                            ELSE-IF PAY-GROSS > 500.00 
        XMAS-BONUS = PAY-GROSS * 1.03                                    ELSE 
        XMAS-BONUS = PAY-GROSS * 1.05                                    END-IF 
   TOT-XMAS-BONUS = TOT-XMAS-BONUS + XMAS-BONUS                         
   PRINT MYREPORT                                                       
*                                                                       
FINISH-PROC. PROC                                                       
DISPLAY                                                                 
DISPLAY 'TOTAL $ SPENT IN BONUS ' +                                     
        'MONEY ====> ' TOT-XMAS-BONUS                                   
END-PROC                                                                
*                                                                       
REPORT MYREPORT                                                         
LINE NAME-LAST XMAS-BONUS       
INITIATION Screen Procedure
An INITIATION procedure in  Easytrieve  is invoked once during the start of the screen activity to perform actions that are
to be executed only once.
An INITIATION procedure is invoked once during the start of the screen activity.
You use INITIATION to perform actions that are to be executed only once. Typically, you use INITIATION to initialize a field
or position a file at a specific starting position.
REFRESH and RESHOW are invalid in an INITIATION procedure.
If GOTO SCREEN is executed in an INITIATION procedure, the INITIATION procedure is terminated and the BEFORE-
SCREEN procedure is invoked.
An INITIATION procedure must be delimited by an END-PROC statement. For more information, see PROC Statement in
"Statements N - R."
 934 Easytrieve ® Report Generator 11.6
This statement has the following format:
INITIATION. PROC
Example
 INITIATION. PROC
  MESSAGE 'Enter an employee number.' LEVEL INFORMATION
  MOVE ZERO TO EMP-NO
  MOVE SPACES TO EMPNAME
END-PROC
INSERT Statement
The INSERT statement in  Easytrieve  inserts a row into an Easytrieve SQL file.
Use the INSERT statement to insert a row into an  Easytrieve  SQL file.
INSERT does not require an open cursor. If no cursor is open for the file, one is not opened automatically. If a cursor is
open, the inserted record does not appear in the cursor's result set until the cursor is closed and re-opened with a new
SELECT statement.
The file must be specified with the UPDATE parameter.
This statement has the following format:
INSERT [INTO] file-name 
[INTO]
Optionally, code INTO for statement readability.
file-name
File-name  identifies an  Easytrieve  SQL file.
Example
The following example inserts a new row into a table:
FILE PERSNL SQL (PERSONNEL) UPDATE
EMPNAME       *   20  A
WORKDEPT      *   2   P   0
EMPPHONE      *   3   P   0
PROGRAM NAME RETRIEVE-PERSONNEL
  EMPNAME = 'WIMN    GLORIA'
  WORKDEPT = 921
  EMPPHONE = 3478   INSERT INTO PERSNL  
JOB Statement
The JOB statement in  Easytrieve  defines and initiates a processing activity.
In a JOB activity, statements can specify various processing tasks including retreiving input files and databases,
examining and manipulating data, start print reports, and producing output files. The JOB statement defines and initiates a
processing activity. In a JOB activity, statements can specify various processing tasks:
 935 Easytrieve ® Report Generator 11.6
•Retrieval of input files and databases
•Examination and manipulation of data
•Initiation of printed reports
•Production of output files and databases
The JOB statement can also identify the name of an automatic input file (which can be any file or database that is
processed sequentially).
JOB activities can be executed by PROGRAM or SCREEN activities. If a PROGRAM activity is not coded, JOB and
SORT activities are automatically executed sequentially until a SCREEN activity is encountered.
This statement has the following format:
JOB +                                                                   
                                                                        
[      {( file-name [KEY field-name-1...)]...)} ]                        
[INPUT {NULL                                 } ] +                      
[      {SQL                                  } ]                        
                                                                        
[START start-proc-name] +                                               
                                                                        
[FINISH finish-proc-name] +                                             
                                                                        
[NAME job-name] +                                                       
[           {     }]
[ENVIRONMENT{NONE }]      +
[           {COBOL}]
                                                                        
[        [ACTIVITY  ] [TERMINAL  ] ]                                    
[COMMIT ([          ] [          ])]                                    
[        [NOACTIVITY] [NOTERMINAL] ]                                   
[INPUT]
The optional INPUT parameter identifies the automatic input to the activity.
When you do not specify INPUT,  Easytrieve  automatically provides an input file. If a SORT activity immediately
preceded the current JOB activity, the default input is the output file from that SORT activity. Otherwise, the
default input is the first file named in the library section.
{file-name }
File-name  identifies the automatic input file. File-name  identifies any file defined in the library section of the
program eligible for sequential input processing. When  Easytrieve  processes the last automatic input record, 
Easytrieve  terminates the job activity.
NOTE
Except in CICS,  Easytrieve  issues a GET HOLD for a VSAM file with the UPDATE parameter as
automatic input. This lets you update an automatic input file in all environments except CICS.
For more information about database processing, see the Programming Guide .
{[KEY (key-field -name  ...)]}
Specify key fields for JOB statement activities.
Code KEY (key-field-name)  for each file-name  of a synchronized file input process. During synchronized file
processing,  Easytrieve  sequentially processes the files, using KEY fields. KEY fields can be any fields from the
associated file. The only exceptions are varying length, index, or subscript fields, which cannot be used as keys.
For more detailed information about synchronized file processing, see the Programming Guide .
 936 Easytrieve ® Report Generator 11.6
NOTE
Synchronized file processing is not allowed for IDMS  and IMS/DLI database files.
{NULL}
Code NULL as a file-name  to inhibit automatic input. Use this when no input is required or when input is retrieved
by statements in the activity. When NULL is used, a STOP or TRANSFER statement must be executed in the JOB
activity, otherwise the activity executes indefinitely.
{SQL}
Code SQL instead of a file-name  to use automatic retrieval of an SQL database without a file. The selection
criteria for the input are specified on the non-file SQL SELECT statement that must immediately follow the JOB
statement. For more information about automatic retrieval without a file and SQL database processing, see the
Programming Guide .
[START start-proc-name ]
The optional START start-proc-name  parameter identifies a procedure to be executed during the initiation of the
JOB.
Easytrieve  optionally performs the procedure coded in start-proc-name  before it retrieves the first automatic input
record. A typical START procedure sets working storage fields to an initial value or positions a file to a specific
record. You cannot reference fields in automatic input files, because no records have been retrieved at this stage
of processing.
If GOTO JOB is executed in a START procedure, the START procedure is terminated.
[FINISH finish-proc-name ]
The optional FINISH  finish-proc-name  parameter identifies a procedure to be executed during the normal
termination of the JOB. After  Easytrieve  processes the last automatic input record, it performs the finish-proc-
name  procedure. A typical finish-proc-name  procedure displays control information accumulated during the
activity.
If GOTO JOB is executed in a FINISH procedure, the FINISH procedure is terminated at that point.
If STOP EXECUTE is executed in the JOB activity, the FINISH procedure is not performed.
ENVIRONMENT (z/OS only)
Specifies to establish the proper execution environment prior to calling any COBOL subprograms. The
environment is established prior to the JOB activity and is terminated after the activity termination.
ENVIRONMENT(COBOL) is ignored if the JOB activity contains no CALL statement and if no FILE EXITs are
specified. When used on the JOB statement, it establishes the ENVIRONMENT for only that JOB activity.
This processing is different if the JOB activity is invoked from within a PROGRAM activity if that PROGRAM
activity had activated the ENVIRONMENT, (through the PROGRAM ENVIRONMENT(COBOL) parm). In that
case, the PROGRAM activity's ENVIRONMENT will remain active during the execution of the invoked JOB
activity, and the ENVIRONMENT will not end at the JOB activity termination.  Even if ENVIRONMENT(NONE) is
specified on the JOB or PARM statements, the PROGRAM activity's ENVIRONMENT will remain active during the
JOB activity execution.
When this parameter is absent, the default for ENVIRONMENT depends on how the ENVIRON system option
was set at installation and whether the ENVIRONMENT parameter of the PARM statement was specified. Using
the subparameter NONE overrides an existing default of COBOL and using COBOL overrides a default of
NONE. See the discussion of the PROGRAM statement, and see "Subprograms" for more information about this
parameter and the functionality of this feature.
[NAME job-name ]
The NAME parameter names the JOB activity. Job-name :
•Can be up to 128 characters in length
•Can contain any character other than a delimiter
•Can begin with A to Z, 0 to 9, or a national character (#, @, $)
•Must not consist of all numeric characters
This parameter is used for documentation purposes or to identify this JOB on an EXECUTE statement.
 937 Easytrieve ® Report Generator 11.6
[COMMIT [ACTIVITY|NOACTIVITY] [TERMINAL|NOTERMINAL]]
Specify the COMMIT parameter to control the logical unit of work. COMMIT indicates when the activity commits
recoverable work. Each commit point posts all updates, additions, and deletions, terminates holds, and closes
SQL cursors.
Specify ACTIVITY to commit all recoverable work during the normal termination of the activity. Specify
NOACTIVITY to tell  Easytrieve  not to commit at the end of the activity. NOACTIVITY is the default.
Specify TERMINAL to commit all recoverable work during any terminal I/O operation. In CICS, this results in
terminal I/O being performed in a pseudo-conversational mode. Specify NOTERMINAL to tell  Easytrieve  not to
commit during a terminal I/O. TERMINAL is the default.
If this activity is executed by an activity that has NOTERMINAL specified, this activity performs terminal I/O as if
NOTERMINAL was specified.
NOTE
You can also issue your own COMMIT and ROLLBACK statements to commit or recover work on a
controlled basis.
For more information, see the Programming Guide .
Examples
Example 1
The following example illustrates the position of the JOB activities in an  Easytrieve  program.
Environment
...
 Library
...
 Activities                {JOB...
...                        {...
JOB, SCREEN                {  job procedures
and/or                     {  ...
 SORT                      {  ...
...                        {  reports
...                        {  ...
For more information about JOB activity flow control, see the Programming Guide .
Example 2
The following example illustrates a JOB statement that automatically reads a sequential file:
JOB INPUT PERSNL NAME SCAN-PERSONNEL-RECORDS
Example 3
The following example illustrates synchronized file processing. It shows a JOB statement for matching a transaction file
(TRANFILE) with a master file (MASTFILE). The JOB uses the FINISH parameter to execute a procedure when all the
input records have been recorded.
JOB NAME MATCH-FILES INPUT (TRANFILE KEY TRAN-EMP-NO  +
                            MASTFILE KEY MAST-EMP-NO) +
    FINISH DISPLAY-EOJ-MESSAGE
 938 Easytrieve ® Report Generator 11.6
KEY Statement
The KEY statement in  Easytrieve  defines valid keys for a screen, specifies descriptive text to be displayed for each valid
key, and assigns automatic functions for execution for each valid key.
If a key that is not defined on a KEY statement is pressed, an error message is displayed on the terminal prompting the
user to press a valid key.
If no KEY statements are coded, all keys are valid and you must provide code for all keys in your SCREEN activity
procedures.
The function key area is built depending on the sequence of keys specified in KEY statements. You must specify keys in
the order you want them displayed.
The key display area is built on the bottom line of a screen. If the key display area requires additional lines because of the
number of keys and the length of the descriptive text, additional lines at the bottom of the screen are used.
When used as the result of pressing an IMMEDIATE key, REFRESH redisplays the screen image with the original data
displayed on the screen. This is useful when the terminal user enters erroneous data on the screen and wants to restore
the screen with its original data.
When used as the result of a non-IMMEDIATE key, REFRESH can be used to rebuild the screen using current data from
the screen.
REFRESH can also be invoked by using the REFRESH statement. For more information, see REFRESH Statement in
"Statements N - R."
EXIT can also be invoked indirectly by executing it in a screen procedure. For more information, see EXIT Statement in
"Statements D - F."
NOTE
If you specify that one or more message areas use the same screen row as the function key area, messages
might overlap the function key area. The default for the message area is the row immediately preceding the key
display area.
Note: The CLEAR, PA1, PA2, and PA3 keys do not transmit data from the screen to the program. Also, cursor positioning
cannot be determined when these keys are pressed.
This statement has the following format:
                                                [EXIT   ]      
KEY key-name [THRU key-name]...[NAME ' literal'] [       ] [IMMEDIATE]   
                                                [REFRESH]              
key-name
Specify a symbolic name for a terminal key as described by the system-defined field, KEY-PRESSED.
KEY-PRESSED is a two-byte binary field that contains a value representing the most recent terminal key pressed
by the terminal user.
Easytrieve  automatically defines symbolic names that correspond to values for the most common keys:
Terminal Key Symbolic Name Constant Value
Enter ENTER 1
Clear CLEAR 11
PA1 to PA3 PA1 to PA3 12 to 14
PF1 to PF24 F1 to F24 21 to 44
F1 to F12 F1 to F12 21 to 32
 939 Easytrieve ® Report Generator 11.6
NOTE
Only terminal keys with a KEY-PRESSED symbolic name can be used on a KEY statement. If other terminal
keys (such as test request) are required, you must test KEY-PRESSED using the constant value of the
terminal key in your program code. If you test for terminal keys without a symbolic name, you cannot code KEY
statements in your program.
[THRU key-name ]
Use THRU  key-name  to specify a range of key-names . A range of key-names  includes all keys whose constant
values for KEY-PRESSED fall between the constant values of the keys you specify for the range. For example, if
you code:
KEY CLEAR THRU F12
the PA1, PA2, and PA3 keys are also valid. The constant values of the PA keys (12, 13, 14) fall between the value
for CLEAR (11) and F12 (32).
NOTE
You can also specify a series of non-consecutive key-names  by omitting THRU. You can optionally
separate a series of key-names  with commas for readability. You can specify a range of key-names  and
a series of key-names  on the same KEY statement. See the examples below.
[NAME 'literal ']
The optional NAME parameter allows you to specify descriptive text to be displayed with the key on the screen.
The format displayed on the screen is:
key-name=literal
Example:
F1=Help  F3=Exit  F12=Cancel
'Literal'  can contain a maximum of 20 characters.
To display only the key-name  on a screen, code NAME 'literal'  with a blank space between single quotes (' ').
If you do not code NAME, no display is created for the key.
[EXIT|REFRESH]
Optionally, you can code EXIT or REFRESH to specify the branch action taken when a user presses key-name .
If EXIT or REFRESH is specified, the action is automatically executed by  Easytrieve  and the AFTER-SCREEN
procedure (if any) is not executed.
Specify EXIT to terminate the screen activity after editing and extracting data from screen fields into program
fields.
Specify REFRESH to restore the initial screen image by rebuilding it with current values of the program fields.
Data in screen fields is edited and extracted into program fields.
If no action is specified for key-name , you can test for key-name  in your SCREEN activity procedures with the
system-defined field, KEY-PRESSED.
[IMMEDIATE]
Specify IMMEDIATE to execute a branch action, or the AFTER-SCREEN procedure if no action is specified,
without editing data in screen fields and moving it into the program fields.
Examples
The following table shows KEY statement examples:
Code Meaning
KEY F1 F1 is valid, but nothing is displayed on the screen. You must
provide code.
KEY F1 THRU F24 F1 to F24 are valid keys, but nothing is displayed on the screen.
You must provide code for all keys.
KEY F1 NAME 'Help' F1 is valid. F1=Help is displayed on the screen. You must provide
code.
 940 Easytrieve ® Report Generator 11.6
KEY F1 F4 F1 and F4 are valid keys, but nothing is displayed on the screen.
You must provide code.
KEY F1 THRU F4, F8 F1, F2, F3, F4, and F8 are valid keys, but nothing is displayed on
the screen. You must provide code for all keys.
KEY F12 EXIT NAME +
'CANCEL' IMMEDIATEF12 terminates the screen activity without moving data from
screen fields into program fields. The AFTER-SCREEN procedure
(if any) is not executed. F12=CANCEL is displayed on the screen.
KEY F3 IMMEDIATE The AFTER-SCREEN procedure (if any) is executed without
editing or moving data in screen fields to program fields. Nothing
is displayed on the screen. You must provide code for F3.
KEY F3 EXIT F3 terminates the activity after editing and moving data from the
screen.
KEY F5 IMMEDIATE + REFRESH NAME + 'Refresh' F5 ignores the data on the screen and rebuilds the screen with
the values currently in memory. F5=Refresh is displayed on the
screen.
LINE Statement
The LINE statement in  Easytrieve  defines the contents of a report line.
One or more field values or literals can be contained on a report line; each as a line item. The data format of the field or
literal remains unchanged.
For control reports, any quantitative field on the LINE statement is automatically totaled on each summary line. This
feature can be overridden on the SUM statement.
In an XML-formatted report, only one LINE statement is allowed. All LINE statement parameters except field-name  and
'literal' are ignored . For a detailed description of the XML report feature, see the Programming Guide .
This statement has the following format:
                   {[            ] field-name }                           
                   {[# font-number]            }                           
                   {[            ] ' literal'  }                           
LINE [line-number] {+offset                   } ...                       
                   {- offset                   }                           
                   {COL column-number         }                           
                   {POS position -number       }                          
[line-number ]
Specify the optional line number with line-number . The line number specifies the position of the line in the line
group. The value must be from 1 to 99; the default is 1. You can omit line-number  for the first LINE. You must
specify the line numbers for multiple LINE statements in ascending order with no duplicates. Specify at least one
data item ( field-name  or literal ) on each LINE statement.
[#font-number ]
#Font-number  identifies the font specifications to be used for the next display item. You can only specify this
option if the report has been associated with an extended reporting printer. #Font-number  identifies the number of
a font defined for the associated extended reporting printer. If you do not code the font, the next display item uses
the default font for the assigned extended reporting printer.
 941 Easytrieve ® Report Generator 11.6
{field-name }
Field-name  can specify any field contained in an active file or in working storage. If the field is contained in a
file or W storage, data is transferred to the print line at the time the PRINT statement is executed. If the field is
contained in S storage, data is transferred to the print line at the time the line is printed.
NOTE
Field-name  cannot specify a K field.
{'literal '}
'Literal'  defines a static value for a line item. It must be a numeric literal, a hexadecimal literal, or an alphanumeric
literal. Alphanumeric literals must be enclosed within single quotes.
{+offset|-offset }
The space adjustment parameters, + offset  or -offset , modify the spacing between line items. The offset value is
added to or subtracted from the SPACE value on the REPORT statement to give the absolute spacing between
line items. The absolute space value can range from zero to any amount that still allows the next line item to fit in
the line defined by LINESIZE on the REPORT statement.
{COL column-number }
COL specifies the column number where the next line item is placed. The value of column-number  has a valid
range of 1 to nnn, where nnn cannot be so large that the following line item extends beyond the end of the line
defined by LINESIZE.
NOTE
You must specify the NOADJUST parameter on the REPORT statement to use the COL parameter.
When the report is associated with an extended reporting printer, an error results if two or more fields and/or
literals overlap.
{POS position-number }
The POS parameter lets you position line items on lines 2 to 99 so that they line up under particular line items on
the first line. Position-number  corresponds to the line item number of LINE 01 under which the line item is placed.
Example
LINE 1  REGION BRANCH +5 DEPT EMPNAME
LINE 2  POS 4 ADDRESS
LINE 3  'NET==>' -2 PAY-NET POS 4 CITY ST ZIP
LINK Statement
The LINK statement in  Easytrieve  transfers control from the current program (parent program) to another named
program (child program).
When the child program terminates, execution is then returned to the statement following the LINK statement in the parent
program.
You can use LINK to invoke any program written in any language that is supported by the operating system in which the
program is executing, including Easytrieve . Similarly, the program can issue any command supported by the operating
system.
A program invoked using the LINK statement can issue terminal I/O or display reports, but only in fully-conversational
mode. For more information, see the Programming  section.
NOTE
If you code the USING or GIVING parameter on the LINK statement, you must code a PROGRAM statement to
handle the parameters in the child program when it is written in Easytrieve .
 942 Easytrieve ® Report Generator 11.6
This statement has the following format:
       { program-field-name }
LINK   {                  } +
       {' program-name '    }
[      { field-name }       ]
[USING {          }       ] +
[      {' literal' }       ]
[GIVING field-name         ]
{program-field-name |'program-name '}
Program-field-name  is the name of the field that contains the name of the program to which you want to LINK.
'Program-name ' is the name of the program to which you want to LINK.
USING {field-name |'literal '}
Code USING to pass a single parameter to the child program.
Field-name  is the name of a field containing the parameter you want to pass to the child program.
'Literal ' is a literal value you want to pass to the child program.
[GIVING field-name ]
Specify GIVING to indicate that the parent program can accept a return parameter from the child program.
Field-name  is the name of a field to which the returned parameter is written. For more information, see the
Programming  section.
NOTE
If the child program returns a value, but the GIVING parameter is not specified, the value is ignored. Not
all operating systems allow the child program to return data to the parent program.
Example
LINK 'PROGB' USING EMP# GIVING PROGB-RETURN
LIST Statement
The LIST statement in  Easytrieve  regulates the printing or suppression of all statements in the printed output.
You can place a LIST statement anywhere in  Easytrieve  source code. LIST must be on a record by itself.
LIST does not appear in the printed output.
NOTE
The LIST statement and LIST option in the PARM statement are supported in r11.6 and use the same syntax
as r6.4. Note that the LIST option from r6.4 was renamed to LISTPRM, LISTFIL and LISTUC in r11.0. These
options are valid only in the Options table context (managed with ETOPLOAD).
To suppress all  Easytrieve  listing information, use the following:
LIST OFF
 943 Easytrieve ® Report Generator 11.6
PARM LIST(NOPARM)
For more information, see PARM Statement in "Statements N - R."
This statement has the following format:
     [ON ] [MACROS  ]                                                   
LIST [   ] [        ]                                                   
     [OFF] [NOMACROS]                                                  
[ON|OFF]
ON specifies that all subsequent statements are to be printed. OFF suppresses the printing of all subsequent
statements.
[MACROS|NOMACROS]
MACROS specifies that macro statements are to be printed if a LIST ON is in effect. NOMACROS suppresses the
printing of macro statements.
Default: LIST ON MACROS.
MACRO Statement
The MACRO prototype statement in  Easytrieve  optionally defines the parameters of a macro. Use positional and
keyword parameters.
The MACRO prototype statement must be the first statement of a macro. The definition of positional and keyword
parameters follow the same rules as Field and Label names (see "Syntax Rules").
This statement has the following format:
MACRO [positional -count] +                                              
                                                                        
      [positional -parameters ] ... [keyword-parameters ] ...             
MACRO
MACRO must be the first word on a prototype statement.
[positional-count ]
Positional-count  is an optional parameter that specifies the number of positional-parameters  on the prototype
statement. It is required only when you use keyword-parameters  and positional-parameters . You must code the
value as zero when you specify only keyword-parameters  on the prototype statement.
[positional-parameters ]
Use positional-parameters  when a value is always required for the parameters each time the macro is invoked.
Frequently-used parameters are often positional, because you need only code the value of the parameter.
You must code positional-parameters  before any keyword-parameters . The positional values are substituted
according to their position on the prototype statement.
[keyword-parameters ]
Use keyword-parameters:
•To help keep track of a large number of parameters
•For optionally-used parameters
•To specify a default value for parameters
Keyword-parameters  have two parts: the keyword name and the default value.
Examples
 944 Easytrieve ® Report Generator 11.6
The following series of examples depict the coding of macro prototype statements. For more information about system
services, see the Programming Guide .
Macro with No Substitution MACRO
...
...
Macro with Only Positional MACRO  POS1  POS2                                                       
...                                                                     
...                                                                    
The number of positional-parameters  is not indicated. You could have coded the optional positional-count  parameter as a
'2.'
Macro with Only Keyword MACRO  0  KEY1 VALUE1  KEY2 VALUE2                                      
...                                                                     
...                                                                    
Code the number of positional-parameters  as zero. Positional-count  is a required parameter when you use keyword-
parameters .
Macro with Positional and Keyword MACRO 1  POS1  KEY1  VALUE1                                             
...                                                                     
...                                                                    
Macros with both positional  and keyword-parameters  require that you supply positional-parameters  first, and also supply a
positional-count .
MASK Parameter
The optional MASK parameter in  Easytrieve  establishes a pattern (edit mask) for a field name.
The MASK parameter can be coded in the syntax of the following Easytrieve  statements:
•DEFINE
•ROW
This statement has the following format:
[MASK ({[ mask-identifier ][BWZ][' mask-literal']|HEX })]
[mask-identifier ]
Any letter from A to Y can be used as an optional mask-identifier . You can use the letter to identify a new mask
or to retrieve a mask that was previously defined in the Site Options Table or by a mask parameter on a previous
field definition. If the new mask that you identify does not already exist, the mask is retained for future reference.
If you subsequently reference a field-name  for display, the associated letter identifier is automatically used to
determine the edit mask. Do not use the same identifier to establish more than one mask. You can define 192
unidentified edit masks and 25 identified edit masks for a total of 217 edit masks.
[BWZ]
The BWZ (blank when zero) option suppresses the display of field-name  when it contains all zeros. BWZ can be
used by itself or with other options on the MASK parameter.
['mask-literal ']
'Mask-literal'  defines an edit mask and must be enclosed within single quotes. For information about coding the
actual edit mask, see the Editing Rules section that follows.
 945 Easytrieve ® Report Generator 11.6
HEX
HEX is a special edit mask that instructs the product to display the contents of field-name  in double-digit
hexadecimal format. You can display fields of up to 50 bytes with the HEX mask.
NOTE
HEX edit masks are not allowed for VARYING fields.
Editing Rules
•Easytrieve  edits field data only at the time of display and according to a specified edit mask pattern.
•The MASK parameter of the DEFINE and ROW statements specifies the edit mask pattern.
•Each digit of the field must be designated in the mask by an edit mask character:
Symbol Meaning
9 Prints a digit.
Z Prints a digit, except for leading zeros.
* Prints asterisks instead of leading zeros.
- Prints a minus sign prior to the first non-zero digit of a negative
number.
$ Prints a currency symbol prior to the first non-zero digit. The type
of currency symbol ($, ¥, £, _, etc.) is determined by the MONEY
Site Option.
x Insertion symbol -- prints any character with the edited data.
Decimal Digits
•When you display data, there is no implied relationship between the number of decimal digits in the edit mask and the
number of decimal digits in the field definition. You must code the correct number of decimal digits in the mask.
•When screen data is edited against a mask, the decimal point is automatically aligned.
Alphanumeric Fields
•Alphanumeric fields cannot be edited. (The exception is MASK HEX.)
Currency Symbols
•The currency symbol indicator is recognized in the input edit mask and appears in the output edit mask. For example, if
the currency symbol is set to #, a valid edit mask is '###,##9.99.'
Insertion Symbols
•Z, $, -, and * print digits only when coded as the first symbol of the edit mask, and only up to the first nine symbols.
All other symbols before the last digit position are treated as insertion symbols, including Z, $, -, and *. The symbols
comma (,) and period (.) can also be used as insertion symbols.
Insertion symbols before the first digit position always print.
•Insertion symbols between digit positions print according to the following rules:
–If the symbol that prints a digit following the insertion symbol is a 9, the insertion characters always print.
–If the digit position following the insertion symbols is a Z, $, -, or *, the insertion symbols print only if the digit position
prints. If the digit position does not print, the insertion symbols are replaced by fill symbols.
For example, in the mask 'ZZZ,999.99,' the comma always prints. In the mask 'ZZZ,Z99,99,' the comma prints only if the
digit prior to the comma is non-zero.
Fill Characters
 946 Easytrieve ® Report Generator 11.6
•The default fill character for an edit mask is a blank, unless an * (asterisk) is specified.
Mask Display Length
•When the first symbol of an edit mask is a dash (-) or a currency symbol, the display length of the mask is the length of
the mask plus one.
•The mask for a SUM field in a report is automatically increased by the number of digits that are specified by the
SUMSPACE parameter on the REPORT statement. The first digit position is duplicated the required number of times.
Negative Indicators
•Symbols following the last digit position specify the negative indicator. The symbols print if the value edited is negative.
If the value edited is positive, the symbols are replaced by fill characters.
System Default Masks - Numeric Fields
When you do not specify a mask, the following defaults apply:
 Number of                                             
 Decimals                       Mask                                    
 
   none            ZZZZZZZZZZZZZZZZZZ  *                                
     0        ZZZ,ZZZ,ZZZ,ZZZ,ZZZ,ZZZ-                                  
     1         ZZ,ZZZ,ZZZ,ZZZ,ZZZ,ZZZ.9-                                
     2          Z,ZZZ,ZZZ,ZZZ,ZZZ,ZZZ.99-                               
     3            ZZZ,ZZZ,ZZZ,ZZZ,ZZZ.999-                              
     4             ZZ,ZZZ,ZZZ,ZZZ,ZZZ.9999-                             
     5              Z,ZZZ,ZZZ,ZZZ,ZZZ.99999-                            
     6                ZZZ,ZZZ,ZZZ,ZZZ.999999-                           
     7                 ZZ,ZZZ,ZZZ,ZZZ.9999999-                          
     8                  Z,ZZZ,ZZZ,ZZZ.99999999-                         
     9                    ZZZ,ZZZ,ZZZ.999999999-                        
    10                     ZZ,ZZZ,ZZZ.9999999999-                       
    11                      Z,ZZZ,ZZZ.99999999999-                      
    12                        ZZZ,ZZZ.999999999999-                     
    13                         ZZ,ZZZ.9999999999999-                    
    14                          Z,ZZZ.99999999999999-                   
    15                            ZZZ.999999999999999-                  
    16                             ZZ.9999999999999999-                 
    17                              Z.99999999999999999-                
    18                               .999999999999999999-               
* For zoned decimal fields with no decimals, the default mask           
  is '999999999999999999'.                                             
Your system administrator can define additional edit masks in the Site Options Table when the product is installed.
Leading Zeros
Various methods are available for processing leading zeros.
Display
 947 Easytrieve ® Report Generator 11.6
When leading zeros are an important part of the number (such as social security numbers and part numbers) an edit mask
that displays these zeros is essential. These are examples of edit masks that display leading zeros:
Mask Field Contents Displayed Results
999-99-9999 053707163 053-70-7163
(99)-9999 006421 (00)-6421
Suppress
In some instances, leading zeros add unnecessary information and can confuse the reader. You can suppress the display
of leading zeros by using one of the following masks:
Mask Field Contents Displayed Results
$$,$$9 01234 $1,234
$$,$$9 00008 $8
$$,$$9.99 0123456 $1,234.56
ZZZ,ZZ9 000123 123
---,--9 +001234 1,234
---,--9 -001234 -1,234
Replace
In cases where fields must be protected (such as check amounts), you can use edit masks that replace leading zeros with
other symbols:
Mask Field Contents Displayed Results
**9 001 **1
**,**9 01234 *1,234
**,**9.99 0123456 *1,234.56
Negative Numbers
The symbols that are used as negative number indicators are displayed to the right of the last digit of the negative data
that you edit. You can use any symbols as negative number indicators, although the most typical indicators are the minus
sign (-) and the credit indicator (CR). If the number is positive, display of these symbols is inhibited. However, when the
field contents turn negative, the negative number indicators are edited into the displayed output as follows:
Mask Field Contents Displayed Results
ZZZ- -123 123-
ZZZ- +123 123
ZZZ CR -123 123 CR
ZZZ CR +123 123
ZZZ IS MINUS -123 123 IS MINUS
Examples
 948 Easytrieve ® Report Generator 11.6
The following edit mask examples illustrate editing mask rules:
Mask Field Contents Displayed Results
'Z,ZZZ,ZZZ.99' .01 .01
'ZZHELLOZZ9.99' 123.01 123.01
'ZZHELLOZZ9.99' 1234.01 1HELLO234.01
'**HELLO**9.99' 11.01 ********11.01
'**HELLO**9.99' 123.99 *******123.99
'**HELLO**9.99' 1234.99 *1HELLO234.99
'$$99$$99.99' 1234.99 $02$$34.99
'999Z999.99' 12345.99 012Z345.99
'SSN 999-99-9999' 123456789 SSN 123-45-6789
'ZZZ.99 MINUS' 12.45 12.45
'ZZZ.99 MINUS' -12.45 12.45 MINUS
'***.99 MINUS' 12.45 *12.45******
'***.99 MINUS' -12.45 *12.45 MINUS
'---.99' 123.45 123.45
'---.99' -123.45 -123.45
MEND Statement
The MEND statement in  Easytrieve  is an optional macro termination command used at the end of a macro.
MEND is required at the end of an instream macro. See also MSTART Statement.
MEND must be coded on a line by itself.
This statement has the following format:
MEND
MESSAGE Statement
The MESSAGE statement in  Easytrieve  allows you to issue your own specific messages for a screen activity.
You define the message type and specify the message text using the MESSAGE statement.
You can code the MESSAGE statement in a screen procedure or in another activity.
You can determine where messages of a particular level are displayed on the screen by overriding the default message
area on a DEFAULT statement. (The default message area is one line above the function key display area at the bottom
of the screen.) You can also use the DEFAULT statement to override default message attributes.
Easytrieve  maintains an internal message area for each type of message. The MESSAGE statement updates the
pending message area. When the next screen is displayed, the screen message area is built from the pending message.
If different levels of messages are displayed on the same line (by default or override), then the message displayed is
controlled by message precedence. If two messages are sent to the same line on the screen, the message with the
highest severity is displayed. The severity precedence from highest to lowest is:
 949 Easytrieve ® Report Generator 11.6
•ACTION
•WARNING
•INFORMATION
If multiple MESSAGE statements of the same precedence are issued before displaying the screen, the last message
issued is displayed. There are Site Options that determine the display attributes for the three levels of messages. You can
override these attributes on a DEFAULT statement.
This statement has the following format:
MESSAGE {' literal' }
        {          } ... + 
        { field-name}
    [      {INFORMATION} ]
    [LEVEL {WARNING    } ]
    [      {ACTION     } ]
{'literal '} or {field-name }
Use 'literal'  to define the text you want displayed in the message. Use field-name  to specify a field whose contents
you want displayed as part of the message. A message can consist of a combination of literals  and field-names .
The maximum length of a message is 130 characters. If the message exceeds the message area for the screen
on which it is displayed, the message is truncated.
[LEVEL {INFORMATION|WARNING|ACTION}]
Use LEVEL to specify the type of message you are defining.
INFORMATION messages typically inform a user that processing is proceeding normally.
WARNING messages tell the user that a potentially undesirable condition could occur or has occurred, even
though the error can be ignored.
ACTION messages are the most severe. They tell a user that an error has occurred and an action is required to
correct the error before continuing. ACTION is the default message level if no level is specified.
Example
MESSAGE 'D epartment  of ' EMP-DEPT ' not 900-999.' LEVEL ACTION
MOVE Statement
The MOVE statement in  Easytrieve  transfers character strings from one storage location to another. .
The MOVE statement is especially useful for moving data without conversion and for moving variable length data strings.
When you specify Format 1 parameters, data moves from left to right as if both areas were alphanumeric. The data
moved is unconverted. Send-file-name  and receive-file-name  can be any file in which data is currently available. For more
information about MOVE statement specification rules, see the Programming  section.
When you process an SQL table as an Easytrieve  file, the product knows which fields are nullable. This information is
obtained automatically from the SQL catalog when used to generate Easytrieve  field definitions.
This statement has two formats.
Format 1
 950 Easytrieve ® Report Generator 11.6
     {send-file-name      }
     {send-record-name   } [send-length-field      ]
MOVE {                   } [                      ] +
     {send-field-name     } [send-length-literal    ]
     {send-literal       }
     {receive-file-name   } [receive-length-field   ]
TO   {receive-record-name } [                      ] [FILL fill-character ]
     {receive-field-name  } [receive-length-literal ]
{send-file-name } or {send-record-name } or {send-field-name } or {send-literal }
The first parameter after the MOVE keyword ( send-file-name , send-record-name , send-field-name , or send-literal )
identifies the sending data area. Send-file-name  or send-record-name  can be any file or database record with
current data availability. When send-file-name  is an IDMS  file, all records in the file are moved.
The default length of send-file-name  is the current value of the system-defined RECORD-LENGTH field.
NOTE
If send-literal  is non-numeric, it must be enclosed within single quotes.
[send-length-field ] or [send-length-literal ]
You can override the length of the sending field with the current value of send-length-field or send-length-literal.
{receive-file-name } or {receive-record-name } or {receive-field-name }
These parameters identify the receiving data area. Receive-file-name  or receive-record-name  can be any file or
database record with current data availability. The default length of receive-file-name  is the current value of the
system-defined RECORD-LENGTH field.
[receive-length-field ] or [receive-length-literal ]
You can override the length of the receiving field with the current value of receive-length-field  or receive-length-
literal .
[FILL fill-character ]
Longer sending fields on the right are truncated. Longer receiving fields are padded on the right with spaces or a
character you specify in fill-character .
Fill-character  must be one or two bytes. Non-numeric characters must be enclosed within single quotes. When fill-
character  contains numeric characters, they are treated as a zoned decimal value.
Example
FILE PERSNL SQL (PERSONNEL)
SQL INCLUDE (EMP#) FROM PERSONNEL LOCATION * NULLABLE
DEFINE CTR1 W 10 N
DEFINE CTR2 W 2 N
DEFINE PLINE W 130 A
. . .
MOVE ZEROS TO CTR1, CTR2
MOVE SPACES TO PLINE
MOVE NULL TO EMP#
Format 2
     {NULL       }
 951 Easytrieve ® Report Generator 11.6
     {SPACE      }
     {SPACES     }
MOVE {           } TO receive-field-name ...
     {ZERO       }
     {ZEROS      }
     {ZEROES     }
     {HIGH-VALUES}
     {LOW-VALUES }
{NULL} or {SPACE} or {SPACES} or {ZERO} or {ZEROS} or {ZEROES} or {HIGH-VALUES} or {LOW-VALUES}
The first parameter after the MOVE keyword (NULL, SPACE, SPACES, ZERO, ZEROS, ZEROES, HIGH-
VALUES, or LOW-VALUES) identifies the sending data area. The default length of the field is the defined length of
receive-field-name. Moving spaces or zeros to a field fills the entire field with the selected character. Moving nulls
sets a nullable field to NULL. Moving spaces or zeros sets a nullable field to NOT NULL.
receive-field-name
Receive-field-name  identifies the receiving data area. You can specify multiple receive-field-names . Receive-field-
names  are set to the appropriate data format, such as packed zero for fields with a type of P.
Example
Statements:
DEFINE ASTERISK-LINE W 10 A VALUE '=========='
DEFINE COUNTER-1 W 10 N VALUE 99
DEFINE COUNTER-2 W 2 N VALUE 66
PROGRAM NAME MYPROG
  DISPLAY COUNTER-1 +2 COUNTER-2
  MOVE ZEROS TO COUNTER-1 COUNTER-2
  DISPLAY COUNTER-1 +2 COUNTER-2
  DISPLAY ASTERISK-LINE
  MOVE '*' TO ASTERISK-LINE FILL '*'
  DISPLAY ASTERISK-LINE
Results:
0000000099 66
0000000000 00
==========
**********
MOVE LIKE Statement
The MOVE LIKE statement in  Easytrieve  moves the contents of fields with identical names from one file, record, or
working storage to another.
Data movement and conversion follow the rules of the assignment statement.
This statement has the following format:
          { send-file-name   }    { receive-file-name   }
MOVE LIKE {                } TO {                   }
          { send-record-name }    {receive-record-name }
 952 Easytrieve ® Report Generator 11.6
{send-file-name } or {send-record-name }
Send-file-name  or send-record-name  identifies the sending data area.
{receive-file-name } or {receive-record-name }
Receive-file-name  or receive-record-name  identifies the receiving data area.
Usage Notes
When you issue a MOVE LIKE statement, the contents of fields in send-file-name  or send-record-name  replace the
contents of fields with identical names in receive-file-name  or receive-record-name . When receive-file-name  or receive-
record-name  contains overlapping fields, the order in which the fields are defined is important. The moves occur starting
with the first identically-named field in receive-file-name  or receive-record-name  and ending with the last identically-named
field in the file.
NOTE
The order in which fields are processed differs from previous versions of the product. In previous versions, the
moves occurred starting with the last identically-named field in receive-file-name  or receive-record-name  and
ended with the first identically-named field in the file.
If you want to move identically-named fields to or from working storage, you can use the keyword WORK as the send-file-
name  or receive-file-name.
IDMS  IDD Processing
In IDMS  IDD processing, the fields of a file defined by an IDD statement are organized into group item structures. A group
item is a field subdivided by smaller fields. The smaller fields can themselves be group items and, therefore, subdivided by
even smaller fields. A group item owns its subdividing fields. A field without subdivision is called an elementary  field.
In IDD processing, MOVE LIKE assigns a new value to the receiving field if all of the following conditions are met:
•The sending and receiving fields have matching names.
•The sending and receiving fields have matching qualifier (group item) names.
•Either the sending or receiving field is an elementary field.
Record name qualifiers do not participate in the process of matching qualifiers between two fields. For example, in a
MOVE LIKE from a record to a file (that owns the record), no matching is done between the record names of the receiving
file and qualifiers of source (record) fields. Therefore, source fields can be matched to a field under one record and
another source field can be matched to a field under a different record.
Differences Between MOVE LIKE and MOVE
The differences between the MOVE LIKE statement and the MOVE statement are as follows:
•The MOVE LIKE statement generates an assignment statement that provides data conversion according to data type.
For assignment statement specification rules, see the Programming  section.
•The MOVE statement moves data without converting it.
Example
FILE PERSNL FB(150 1800)
  REGION  1  1 N
  BRANCH  2  2 N
  NAME   17 16 A
    NAME-LAST  17 8 A
    NAME-FIRST 25 8 A
FILE MYFILE FB(150 1800)
 953 Easytrieve ® Report Generator 11.6
  COPY PERSNL
JOB INPUT PERSONL NAME MYPROG
  MOVE LIKE PERSNL TO MYFILE
  PUT MYFILE
In this example, MOVE LIKE generates the following assignment statements:
MYFILE:NAME-FIRST = PERSNL:NAME-FIRST
MYFILE:NAME-LAST = PERSNL:NAME-LAST
MYFILE:NAME = PERSNL:NAME
MYFILE:BRANCH = PERSNL:BRANCH
MYFILE:REGION = PERSNL:REGION
Whatever values were in the fields of the file PERSNL are now found in the fields of the file MYFILE.
MSTART Statement
The MSTART statement in  Easytrieve  is used to begin an instream macro.
MSTART must be the first statement in the program.
This statement has the following format:
MSTART macro-name 
•macro-name
Specify the name of the macro. Macro-name  must be from one to eight characters in length. The first character must be
alphabetic.
NOTE
For Panvalet  and Endevor  libraries the macro name can be from 1 to 10 characters in length.
NEWPAGE Statement
NEWPAGE in  Easytrieve  is a listing control statement that ejects the printer to the top of the next page before printing
the next line of the source program on the statement listing.
You can code a NEWPAGE statement anywhere in  Easytrieve  source code. NEWPAGE must be on a record by itself.
NEWPAGE does not appear in the printed output.
This statement has the following format:
NEWPAGE
PARM Statement
The PARM statement in  Easytrieve  overrides selected general standards for a program that are set in the Site Options
Table.
Alteration of the environment with the PARM statement lasts for only as long as the program is running.
Specification of the PARM statement is optional. Code the PARM statement only to modify the environment for your
program. If used, the PARM statement must be the first statement in your  Easytrieve  job.
   Environment <============== PARM
     ...
 954 Easytrieve ® Report Generator 11.6
   Library
     ...
   Activities
Code PARM statement parameters and their subparameters in any order. You must code multiple subparameters within
parentheses.
PARM establishes program-level parameters in the following areas:
•SYNTAX, COMPILE, and LINK determine the mode of execution.
•ABEXIT, DEBUG, and LIST establish control over system facilities associated with compiler output and execution error
handling.
•VFM establishes system control parameters.
•SORT controls the interface to your installation's sort program.
•BIND, PLAN, PREPNAME, SQLID, SSID, USERID, PLANOPTS, and SQLSYNTAX establish parameters for SQL
execution.
•TRANSID controls CICS execution.
For more information about controlling  Easytrieve  with the PARM statement, see Compile and Link Your Program.
This statement has the following format:
PARM   +                                                                    
 
[       {SNAP  } ]                                                          
[ABEXIT {NOSNAP} ] +                                                        
[       {NO    } ]                                                          
 
[     {DYNAMIC    } ]                                                       
[BIND {STATIC-ONLY} ] +                                                     
[     {ANY        } ]                                                       
 
[     {STATIC } ]                                                           
[CALL {DYNAMIC} ] +                                                         
[     {AMODE24} ]                                                           
 
[             {EBCDIC        } ]                                            
[CODE PROCESS {ASCII         } ] +                                          
[             { dbcs-code-name} ]                                            
[CMPUSINGALTSEQ  {YES|NO  } ] +
[COMPILE] +                                                                 
 
[      {MMDDYY}]
[DATE {YYMMDD}]    +
[     {DDMMYY}]
[        [CLIST  ] [PMAP  ] [DMAP  ] [FLDCHK  ] [FLOW  ]                    
[DEBUG ( [       ] [      ] [      ] [        ] [      ] +                  
[        [NOCLIST] [NOPMAP] [NODMAP] [NOFLDCHK] [NOFLOW]                    
 
                                          [STATE  ] [XREF   {LONG } ]   ]   
        [FLOWSIZ number-of-table-entries] [       ] [       {     } ] ) ] + 
                                          [NOSTATE] [NOXREF {SHORT} ]   ]   
 
[           {     }]
 955 Easytrieve ® Report Generator 11.6
[ENVIRONMENT{NONE }]      +
[           {COBOL}]
[LINK (program-name [R])] +                                                 
 
[      [FILE  ] [PARM  ] ]                                                            
[LIST ([      ] [      ] ] +                                                          
[      [NOFILE] [NOPARM] ]                                                            
 
[PLAN (planname  [command-program-name])] +                                  
 
[PLANOPTS ' plan-options-module'] +                                          
 
[PREPNAME(SQL- access-module ['access-userid'])] +  
 
[SORT +                                                                     
 
         [        {NO                    } ]                                
         ([ALTSEQ {                      } ] +                              
         [        {(YES [ alt-sort-table])} ]                                
 
        [DEVICE device-type] +                                              
 
        [       { storage-amount           } ]                               
        [MEMORY {                         } ] +                             
        [       {(MAX [- storage-released ])} ]                               
 
        [      {ALL      [CONSOLE] }   ]                                    
        [      {         [PRINTER] }   ]                                    
        [      {                   }   ]                                    
        [MSG ( {CRITICAL [CONSOLE] } ) ] +                                  
        [      {         [PRINTER] }   ]                                    
        [      {DEFAULT            }   ]                                    
        [      {NO                 }   ]                                    
 
        [RELEASE core-storage-amount] +                                     
 
        [WORK number-of-work-data-sets])] +                                 
 
[SQLID ' auth-id'] +                                                         
 
[          {FULL   } ]                                                      
[SQLSYNTAX {PARTIAL} ] +                                                    
[          {NONE   } ]                                                      
 
[SSID 'ssid'] +                                                             
 
[SYNTAX] +                                                                  
 
[TRANSID ' transid'] +                                                       
 
[USERID (' connect-userid' ['password '])] +                                  
 956 Easytrieve ® Report Generator 11.6
 
[                           [       {DISK  } ]   ]                          
[VFM ([buffer-core-storage] [DEVICE {      } ] ) ]  +                       
[                           [       {MEMORY} ]   ]                          
 
[           {YES}             ]                                             
[WORKFILE ( {   } [ number-of-cylinders ] )]                                             
[           {NO }             ]                                            
ABEXIT
[ABEXIT {SNAP|NOSNAP|NO}]
ABEXIT indicates the level of control exercised over program interrupt codes 1 to 11. SNAP prints a formatted dump of 
Easytrieve  storage areas along with an error analysis report. NOSNAP prints only an error analysis report. NO inhibits 
Easytrieve  interception of program interrupts.
It is advisable that the ABEXIT value in the site options table be set to NO, and to use the PARM ABEXIT(SNAP or
NOSNAP) during development as a debugging aid. Before moving the  Easytrieve  program into production, remove the
PARM ABEXIT override. This will reduce overhead for production applications.
AUTO-IDAA
[AUTO-IDAA {NONE|ENABLE|ENABFAIL}]
The AUTO-IDAA parameter can be specified in the PARM statement of programs that use Automatic Cursor Management
to enable automatic generation of SET CURRENT QUERY ACCELERATION commands.
You can specify this parameter for the following purposes:
•If you use an older Options Table that does not include the AUTOIDAA option
•To override the AUTOIDAA setting in a new Options Table that was generated after the APAR was installed
If AUTOIDAA is set to N in the options table, you can specify AUTO-IDAA ENABFAIL in the PARM statement for specific
programs to automatically generate the SET CURRENT QUERY ACCELERATION = ENABLE WITH FAILBACK
commands for only those programs.
NOTE
If the AUTO-IDAA parameter is included in the PARM statement of a program using Native Cursor Management,
it is ignored.
BIND
[BIND {DYNAMIC|STATIC-ONLY|ANY}]
BIND is an SQL-related parameter that identifies the type of SQL bind that you want for the execution of your application
program. BIND is currently used only by the mainframe DB2 SQL interface. It is ignored in other environments.
BIND DYNAMIC results in the dynamic execution of the SQL statements in your program. Dynamic processing
requires SQL statements to be dynamically prepared before they can be executed. The SQL interface controls the SQL
environment and does not prepare SQL statements repeatedly unless a syncpoint has been taken.
BIND STATIC-ONLY indicates that your application program is to execute statically. This option requires the creation of
a static-command-program that is then processed by the DB2 preprocessor. The DB2 preprocessor generates a DBRM
and finally a PLAN. During the execution of your application program, the SQL interface processes the SQL statements
in the static-command-program. If any errors are found in the static-command-program or its PLAN, SQL processing is
terminated.
BIND ANY indicates that a static-command-program is to be generated and a PLAN created, as with an option of STATIC-
ONLY. However, if the SQL interface encounters any errors with the static-command-program or its PLAN during the
execution of your application program, it switches to dynamic processing.
 957 Easytrieve ® Report Generator 11.6
BIND STATIC-ONLY or BIND ANY requires a value for the PLAN and LINK parameters. PLAN specifies the name of the
static-command-program and its DB2 PLAN name. LINK identifies the load module name of your link-edited  Easytrieve 
program. Your  Easytrieve  application program must run as a link-edited program for static SQL processing.
NOTE
Regardless of the option you specify for the BIND parameter, your program is dynamically processed when
being processed by the interpreter, that is, whenever the CHECK or RUN commands are executed.
If no value is specified for the BIND parameter in the program or in the options table, DYNAMIC is the default mode of
execution. Otherwise, the BIND value in the options table becomes the default.
The following table shows the use of the BIND parameter with the value specified in the options table.
BIND Parameter Options Table
ValueOptions Table
ValueOptions Table
ValueOptions Table
Value
Value None A S D
None BIND defaults to
DYNAMICBIND defaults to
ANYBIND defaults to
STATIC-ONLYBIND defaults to
DYNAMIC
ANY ANY is the BIND
parameterANY is the BIND
parameterInvalid -- an error
occursInvalid -- an error
occurs
STATIC-ONLY STATIC-ONLY is the
BIND parameterSTATIC-ONLY is the
BIND parameterSTATIC-ONLY is the
BIND parameterInvalid -- an error
occurs
DYNAMIC DYNAMIC is the
BIND parameterInvalid -- an error
occursInvalid -- an error
occursDYNAMIC is the
BIND parameter
CALL
[CALL {STATIC|DYNAMIC|AMODE24|AMODE31}]
CALL enables you to specify how subprograms referenced in CALL statements are linked to your  Easytrieve  program.
STATIC indicates that you want the subprogram to be linked with your  Easytrieve  program. DYNAMIC indicates that
you want the subprogram to be dynamically loaded. The default is DYNAMIC on the mainframe and in Windows, and the
default is STATIC in Unix environments. Individual subprograms can override this setting using the DECLARE statement.
AMODE24 indicates that this  Easytrieve  program will be calling an AMODE-24 subprogram, (using the CALL statement
or as a FILE EXIT). This will cause the  Easytrieve  runtime to allocate all dynamic storage and record buffers below the
16 MB line. AMODE31 allows all possible memory allocations to be made above the 16MB line. The default AMODE is
the setting of the AMODE31 system installation option.
CODE PROCESS
[CODE PROCESS {EBCDIC|ASCII| dbcs -code -name }]
(Mainframe DBCS) Use CODE  dbcs-code-name  to define the DBCS code system to be used for all K and M fields for this
file. If this parameter is not specified here, the default is taken from the processing code system as defined in the CA PSI
Subsystems DBCS Options Table.
Note:  Using multiple code systems in a program can result in a longer execution time due to code system conversions.
CMPUSINGALTSEQ
[CMPUSINGALTSEQ {YES|NO}]
Identifies whether the collating sequence table is used for the character compare process. YES indicates that the collating
sequence table is used. NO indicates that the collating sequence table is not used. For more information about the
alternate collating sequence table, see Alternate Collating Sequence Table.
COMPILE
 958 Easytrieve ® Report Generator 11.6
[COMPILE]
COMPILE terminates execution after the completion of the syntax check and compile operations. Use COMPILE to review
the code generated in the  Easytrieve  Program Map (PMAP).
DATE
[DATE {MMDDYY|YYMMDD|DDMMYY}]
DATE specifies the format of the date placed at the top of the compiler listing and the date stored in the system-defined
SYSDATE field. Valid values are MMDDYY, YYMMDD, and DDMMYY, where MM is the month, DD is the day, and YY is
the year.
DEBUG
[DEBUG]
DEBUG and its subparameters control generation of certain system outputs.
WARNING
These outputs are very helpful to analyze programming errors that cause abnormal execution termination
(ABENDs).
ENVIRONMENT
ENVIRONMENT (z/OS only)
Specifies to establish the proper execution environment prior to calling COBOL subprograms. The environment is
established prior to each JOB activity that contains a CALL statement and is terminated after the activity for which it was
established.
When used on the PARM statement, it establishes the default (NONE or COBOL) for all JOB activities in the entire
program. When this parameter is absent, the default for ENVIRONMENT depends on the ENVIRON setting within the Site
Options Table being used. Using this parameter overrides that setting.
This parameter does not establish the default for PROGRAM activities. If the environment is desired for the PROGRAM
activity, the ENVIRONMENT parameter must be specified on the PROGRAM statement. The ENVIRONMENT is not
supported in SORT activities, or in REPORT PROCs executed within a SEQUENCEd REPORT. For more information
about this parameter and its functionality of this feature, see the PROGRAM  and JOB statements, and the Code
Programs  section.
LINK
[LINK ( program -name  [R])]
On the mainframe, controls the generation of the link editor NAME command as follows:
•If LINK( program-name ) is specified, 'NAME program-name' is generated as the last line in the object deck.
•If LINK( program-name  R) is specified, 'NAME program-name (R)' is generated as the last line in the object deck. The
subparameter R specifies that the program replaces an existing program with the same name.
•If no LINK parm is specified, no NAME command is generated into the object deck. In this case, the NAME command
must be provided manually in the link edit JCL. For example:
//LINK     EXEC PGM=IEWL,PARM='LET,LIST,MAP'
      ...
      //SYSLIN   DD  DISP=SHR,DSN=&&OBJECT.FROM.COMPILE
      //         DD *
         NAME PROGNAM(R)
      /*
NOTE
On non-mainframe platforms, LINK is ignored
 959 Easytrieve ® Report Generator 11.6
LIST
[LIST [FILE|NOFILE] [PARM|NOPARM]]
LIST controls the printing of certain system outputs.
FILE prints file statistics at the end of each activity. NOFILE inhibits this operation.
PARM prints a compile summary and system parameters at the conclusion of the syntax check operation. NOPARM
inhibits this operation.
[PLAN ( planname  [command-program-name ])]
PLAN is an SQL parameter. Currently, it is used only by the mainframe DB2 SQL interface.
The PLAN parameter enables you to specify values for the static-command-program and its DB2 PLAN. The name
you specify for the static-command-program must be a valid load module name. This name must be different from the
program-name specified for the LINK parameter.
The value specified for planname must be the name of the DB2 PLAN that identifies the DBRM of the given static-
command-program. For information about how to generate the static-command-program, see Program Environment .
If not specified, command-program-name defaults to planname.
Because the link-edit of the static-command-program and the bind of the DB2 PLAN are performed outside the control of 
Easytrieve , you must specify the correct names on the batch JCL to ensure successful execution of your program.
[PLANOPTS ' plan-options-module ']
PLANOPTS is an SQL parameter. Currently, this parameter is used only by the Datacom/DB  SQL interface.
Use PLANOPTS to specify the name of the plan options module that is to override the default  Easytrieve  plan options
module.
[PREPNAME (SQL- access -module  ['access -userid '])]
PREPNAME is an SQL parameter. Currently, it is used by the SQL/DS and Datacom/DB  SQL interfaces.
For the SQL/DS SQL interface, the PREPNAME parameter enables you to specify the name of the access module or
package that is to be associated with the SQL statements for this application program.
For the Datacom/DB  SQL interface, PREPNAME enables you to specify the access plan.
For either database, the PREPNAME parameter also enables you to specify an owner ID ('access-userid') for the access
module or access plan. For information about obtaining an authorization ID, see your specific database documentation.
If PREPNAME is not specified, SQL-access-module defaults to program-name on the LINK parameter. If the LINK
parameter is not specified, SQL-access-module defaults to the value specified in the Site Options Table.
NOTE
You should specify a unique value for the SQL-access-module for each  Easytrieve  program. If you use the
same name for either parameter value, database catalog contention can occur, or an existing access module
could be replaced with another one. For information about establishing naming conventions, see your database
administrator.
PREPNAME can be abbreviated to PREP.
[SORT]
SORT overrides the default parameters used to interface with your installation's sort program. For information about these
SORT parameters, see the installation procedures on your product media.
•–[ALTSEQ {NO|(YES [alt-sort-table ])}]
ALTSEQ identifies the collating sequence table for the sort process. NO indicates usage of the standard table. YES
identifies an alternative table. Alt-sort-table  specifies the name of the table that you provide. When you omit alt-sort-
table , the default name is EZTPAQTT.
–[DEVICE device -type]
DEVICE specifies the device type for dynamically allocated sort work data sets. Device-type  can be any valid unit
name or generic device type.
–[MEMORY {storage-amount |(MAX [- storage-released ])}] 
MEMORY specifies the maximum amount of core storage used by the sort program. Storage-amount  is the amount
of storage made available for the sort and must be a value from 16 to 4096. MAX allows the sort program to obtain
maximum storage available. Storage-released  is the amount of storage released (for system use) after the MAX
 960 Easytrieve ® Report Generator 11.6
amount has been reserved. A minus sign must immediately precede storage-released . Storage-amount  and
storage-released  values represent 1024-byte units of storage.
–[MSG {ALL|CRITICAL [CONSOLE|PRINTER]}|{DEFAULT|NO}]
Specifies the level of messages to be output by the sort program.
ALL outputs all messages. CRITICAL outputs only critical level messages. DEFAULT outputs messages at the level
specified when the sort program was installed. NO outputs no messages.
For ALL or CRITICAL messages, specify the location at which messages are received: PRINTER or CONSOLE.
–[RELEASE core-storage-amount ]
RELEASE determines the amount of core storage reserved from the sort program. The value of core-storage-
amount  should be set large enough to supply all of the core storage needs of any exits used as a part of the sort
process. Core-storage-amount  must be a numeric value from 0 to 1024. The value represents 1024-byte units of
storage.
–[WORK number-of-work-data-sets ])] 
WORK specifies the type and number of work data sets used by the sort.
The value of number-of-work-data-sets controls the allocation of work data sets. When number-of-work-data-sets
is zero, you must supply DD statements for all work data sets (none are dynamically allocated). A number-of-work-
data-sets value from 1 to 31 specifies the number of work data sets dynamically allocated by the sort program.
[SQLID 'auth-id']
SQLID is an SQL parameter. Currently, this parameter is used only by the mainframe DB2 SQL interface.
SQLID enables you to change the authorization ID of your SQL session. If you specify a value for 'auth-id', the DB2 SET
CURRENT SQLID command is executed by the DB2 SQL interface at compile time. For the SET CURRENT SQLID
command to execute successfully, you must have installed the Pan/SQL  Interface for a DB2 release of 2.1 or greater.
You must also have the correct DB2 authorization to execute the SET CURRENT SQLID command. For more information
about the SET CURRENT SQLID command, see your DB2 documentation.
This parameter is in effect only for the compilation of your application program, unless your program is coded using
automatic processing. If your program is coded using automatic processing, the SET CURRENT SQLID command is
executed again at the start of runtime. For native SQL processing, you must code the SET CURRENT SQLID command in
your program if you want to change the value for the current authorization ID.
For more information, see the SQL Database Processing  section.
[SQLSYNTAX {FULL|PARTIAL|NONE}]
Use SQLSYNTAX to specify the level of SQL syntax checking that is to be performed on the SQL statements coded in
your program.
Specify FULL to indicate that detail level syntax checking should be performed. An SQL PREPARE statement is executed
by the Pan/SQL  interface for those SQL statements that can be dynamically prepared. If you specify FULL, your DBMS
catalog must be available to  Easytrieve .
Specify PARTIAL to indicate that SQL statements in your program should be syntax checked for valid commands and
secondary keywords. No connection is made to the DBMS catalog unless you have coded the SQL INCLUDE statement.
If you coded an SQL INCLUDE statement, your DBMS catalog must be available to  Easytrieve . Your program cannot be
executed until it has been fully syntax checked, as described above.
Specify NONE with a BIND STATIC-ONLY parameter if you want syntax checking to be performed by the DB2
preprocessor in a batch environment. NONE causes partial syntax checking, as described above. If no compile errors are
found, your program executes, unless  Easytrieve  errors are found. No connection is made to the DBMS catalog unless
you have coded the SQL INCLUDE statement. If you coded an SQL INCLUDE statement, your DBMS catalog must be
available to  Easytrieve .
If you specify NONE for a non-DB2 environment, partial syntax checking is performed, but the program is not executed
until full syntax checking is performed.
When running under the  Easytrieve  interpreter, dynamic processing is always performed. An option of NONE is effective
only for the batch compilation and execution of your program.
[SSID ' ssid']
SSID is an SQL parameter. Currently, SSID is used only by the DB2, Sybase, and Ingres interfaces.
 961 Easytrieve ® Report Generator 11.6
(For mainframe DB2) You can use SSID to specify the DB2 subsystem ID. If you specify this value, it is used at both
compile and runtime. If you do not specify the DB2 subsystem ID, the subsystem ID from the Site Options Table is used.
If no DB2 subsystem ID is specified in the Site Options Table, the SQL interface uses the ID from the DB2 system default
module DSNHDECP. The value of the subsystem ID is obtained at compile and runtime dynamically; therefore, there is
no need to recompile your program to change the ID. For the default values defined for your DB2 system, see your DB2
systems programmer or administrator.
(For non-mainframe platforms) You can use SSID to specify the name of the database or ODBC data source to which this
session will connect. If you do not specify the subsystem ID, the subsystem ID from the Site Options Table is used. If no
DB2 subsystem ID is specified in the site options table, DB2 uses the ID in the DB2DBDFT environment variable.
SSID is ignored in CICS.
[SYNTAX]
SYNTAX terminates  Easytrieve  processing after the syntax check operation.
[TRANSID ' transid ']
(CICS only) Use TRANSID to specify the transaction identifier of a program to which control is transferred when the
application user presses an attention key after a pseudo-conversational terminal I/O.
[USERID (' connect-userid ' ['password '])]
USERID is an SQL parameter. Currently, USERID is used by the SQL/DS, IDMS , and non-mainframe SQL interfaces.
USERID is used by the SQL interface to establish a connection to the database for compilation of the application program.
(For SQL/DS) You can use USERID to specify a valid userid and password for an explicit CONNECT.
(For IDMS ) You can use 'connect-userid' to specify the IDMS  dictionary name for an explicit CONNECT. If you do not
specify USERID, an implicit connection occurs according to the rules of the given database system.
(For non-mainframe SQL interfaces) You can use 'connect-userid' to specify the user identifier under which this session
will run. If you do not specify USERID, an explicit connection occurs without an 'identified-by' clause. 'Password' is
ignored.
NOTE
USERID can be abbreviated as USER.
[VFM ([ buffer -core-storage ] [DEVICE {DISK|MEMORY}])]
VFM establishes the work area parameters used by the  Easytrieve  Virtual File Manager access method.
Buffer-core-storage specifies the amount of core storage made available for the buffer pool. Valid numeric values for
buffer-core-storage are 6 to 4096. Buffer-core-storage represents 1024-byte units of storage.
DEVICE DISK reverts to disk device usage when the site option default is DEVICE MEMORY. DEVICE MEMORY inhibits
the use of an overflow device.
[WORKFILE ( {YES|NO} [ number-of-cylinders ])]
Use WORKFILE YES instead of VFM if you have multiple large reports in your program. NO is the default. When YES is
specified, sequential temporary disk files will be dynamically allocated for use as Report Workfiles. The space allocated
for each file is indicated by the number-of-cylinders parameter. If DD statements are coded for the Report Workfiles, the
number-of-cylinders parameter is ignored. For more information about print statement processing, see PRINT Statement
(Report Processing) .
Examples
The following examples illustrate typical uses of the PARM statement.
Example: Use of PARM for Production
  PARM LINK(MYPROG) DEBUG(CLIST, DMAP) +   SORT (MSG (ALL, PRINTER)) 
     FILE PERSNL  FB(150 1800)                               
     %PERSNL                                                 
     JOB INPUT PERSNL NAME MYPROG                            
        PRINT REPORT1                                        
 962 Easytrieve ® Report Generator 11.6
     *                                                       
     REPORT REPORT1                                          
     LINE EMPNAME DEPT                                      
Example: Use of PARM for Program Testing
  PARM ABEXIT (SNAP) +   DEBUG (PMAP, DMAP, FLDCHK, FLOW, +   FLOWSIZ (20), STATE) 
     FILE PERSNL  FB(150 1800)                               
     %PERSNL                                                 
     JOB INPUT PERSNL NAME MYPROG                            
        PRINT REPORT1                                        
     *                                                       
     REPORT REPORT1                                          
     LINE EMPNAME DEPT SALARY-COD 
PERFORM Statement
The PERFORM statement in  Easytrieve  transfers control to a procedure and, after the procedure has been executed,
returns control to the next executable statement after the PERFORM statement.
When  Easytrieve  encounters the PERFORM statement, it immediately branches to the named procedure. After exiting
from the procedure, program execution continues with the next executable statement following the just-executed
PERFORM statement.
PERFORM statements in a procedure can invoke other procedures; this is called procedure nesting. However, recursion
is not permitted. That is, procedure A can invoke procedure B, but procedure B cannot then invoke procedure A. If
recursion is attempted, unpredictable results can occur.
This statement has the following format:
PERFORM proc-name 
proc-name
Specify the name of the procedure to be executed.
Example
The following example illustrates the use of the PERFORM statement in executing a user procedure:
FILE PERSNL  FB(150 1800)
 %PERSNL
XMAS-BONUS        W 4 P 2 VALUE 0
*
JOB INPUT PERSNL NAME MYPROG
   IF PAY-GROSS < 300.99      PERFORM SPECIAL-BONUS
   ELSE     PERFORM STANDARD-BONUS
   END-IF
   PRINT MYREPORT
*
SPECIAL-BONUS. PROC
   XMAS-BONUS = PAY-GROSS * 1.20
END-PROC
*
 963 Easytrieve ® Report Generator 11.6
STANDARD-BONUS. PROC
   XMAS-BONUS = PAY-GROSS * 1.05
END-PROC
*
REPORT MYREPORT
LINE NAME-LAST XMAS-BONUS
POINT Statement
The POINT statement in  Easytrieve  enables you to establish the position in an INDEXED or RELATIVE file from which
subsequent data is sequentially retrieved.
Data in the file becomes available only after the next successful sequential retrieval by either automatic file input or a GET
statement.
You cannot use a file presence test (IF file-name ) to test the success of a POINT.
You cannot issue a GET PRIOR statement following a POINT statement, or a GET statement following a POINT PRIOR
statement. For more information, see GET Statement in the "Statements G - M."
GE is not supported for POINT PRIOR when the underlying access method does not support it.
This statement has the following format:
                        {= }                                            
                        {EQ} { field-name}                               
POINT file-name [PRIOR] {GE} {          } [STATUS]                      
                        {GQ} { literal   }                               
                        {>=}                                           
file-name
File-name  must be the same as on a FILE statement that describes an INDEXED or RELATIVE file.
[PRIOR]
Specify PRIOR if you want to use PRIOR on the GET statement. For more information, see GET Statement in
"Statements G - M."
{= } or {EQ} or {GE} or {GQ} or {>=}
Equal operators (= and EQ) initiate a file position search, based on an exact match between the file's keys and
the search value. The greater-than operators (GE, GQ, and >=) initiate a file position search, based on a file's key
being equal to or greater than the search value.
{field-name } or {literal }
The search value can be any valid field-name  or literal . Alphanumeric literals must be enclosed within single
quotes.  Easytrieve  does not change the data format of field-name  or literal . The search value must have the
same length as the file's key. RELATIVE files require field-name  to be a 4-byte binary integer field. Field-name
cannot be nullable. Literal  is not allowed for a RELATIVE file.
[STATUS]
Specify the STATUS parameter whenever the possibility exists for an unsatisfactory completion of the input/output
request.
STATUS checks input/output processing to see if it was performed correctly. STATUS causes the file's FILE-
STATUS field to be set with the appropriate return code. To determine the meaning of the contents of FILE-
STATUS, see the appendix "System-Defined Fields." Normally, a zero or non-zero test is sufficient.
NOTE
FILE-STATUS is not defined if you do not specify a file type parameter on the FILE statement.
 964 Easytrieve ® Report Generator 11.6
If you do not code STATUS and the operating system returns a non-zero status,  Easytrieve  issues an
appropriate diagnostic message.
In addition to FILE-STATUS, IF EOF file-name is true when the search value is greater than the highest key in the
file.
NOTE
CICS does not set EOF.
Example
The following example illustrates the use of POINT:
FILE PERSNL INDEXED                                                     
%PERSNL                                                                 
JOB INPUT NULL NAME MYPROG                                                 POINT PERSNL GE '01963' STATUS     
                                
   IF FILE-STATUS NE 0 OR EOF PERSNL                                    
      DISPLAY 'BAD POINT...FILE STATUS= ' FILE-STATUS                   
      STOP                                                              
   END-IF                                                               
   GET PERSNL STATUS                                                    
   IF FILE-STATUS NE 0                                                  
     DISPLAY 'BAD GET...FILE STATUS= ' FILE-STATUS                      
   ELSE                                                                 
     DISPLAY HEX PERSNL                                                 
   END-IF                                                               
   STOP                                                                
For more detailed examples on the use of POINT in file processing, see the Programming Guide .
POP Statement
The POP statement in  Easytrieve  is a listing control statement that restores previous listing control indicators.
POP is especially useful in macros to control the listing of the macro expansion without affecting listing control indicators
outside the macro. Use the PUSH statement to save the current indicators. You can then set listing control indicators for
use during macro expansion. The POP statement restores the saved indicators.
NOTE
Use the LIST statement to set listing control indicators.
You can place POP statements anywhere in the  Easytrieve  source code. POP must be on a record by itself. POP does
not appear in the printed output.
This statement has the following format:
POP
PRINT Statement
The PRINT statement in  Easytrieve  produces report output. Issue the PRINT statement to initiate a printed line.
In general, report output is not written directly to a report's printer file as with DISPLAY, but is scheduled for deferred
formatting and writing to the report's printer file, perhaps following resequencing of an intermediate file.
 965 Easytrieve ® Report Generator 11.6
For detailed examples of the use of PRINT in report processing, see the Programming Guide .
When you require an intermediate file (referred to as a report work file) for a report, executing PRINT causes fixed format
records (called spool records) to be output to the work file.  Easytrieve  determines the format of these records, which
includes all the fields required to produce the report except those in S type working storage.
This statement has the following format:
PRINT [report-name]
[report-name ]
Report-name  is the name of the report as specified on a REPORT statement. If not given, it is assumed to be the
first report in the JOB activity.
Example
FILE PERSNL  FB(150 1800)
 %PERSNL
JOB INPUT PERSNL NAME PRINT-RPT   PRINT REPORT1
  REPORT REPORT1
    TITLE 'PERSONNEL REPORT'
    LINE EMP# SSN EMPNAME
PROC Statement
The PROC statement is used to begin an  Easytrieve  procedure and consists of a label naming the procedure and the
PROC statement.
A procedure is a group of user-written  Easytrieve  statements designed to accomplish a particular objective. The syntax
of a procedure has two statements:
•A label naming the procedure
•The PROC statement
In most cases, you can code any statement in a procedure. However, you cannot code certain input/output statements
(such as GET, PUT) in procedures invoked during SORT or REPORT processing.
PERFORM statements within a procedure can invoke other procedures; this is called procedure nesting. However,
recursion is not permitted. That is, procedure A can invoke procedure B, but procedure B cannot then invoke procedure A.
If recursion is attempted, unpredictable results can occur.
Screens and reports can contain special-named procedures. Each procedure is explained separately in this manual.
The screen procedures are as follows:
•AFTER-SCREEN
•BEFORE-SCREEN
•INITIATION
•TERMINATION
The report procedures are as follows:
•AFTER-BREAK
•AFTER-LINE
•BEFORE-BREAK
•BEFORE-LINE
•ENDPAGE
•REPORT-INPUT
•TERMINATION
 966 Easytrieve ® Report Generator 11.6
This statement has the following format:
Format 1
 proc-name. PROC                                                         
   statement -1                                                          
   ...                                                                  
   statement -n                                                          
END-PROC                                                               
Format 2
 proc-name                                                               
PROC                                                                    
   statement -1                                                          
   ...                                                                  
   statement -n                                                          
END-PROC                                                               
proc-name
Proc-name  is a label that identifies the procedure. A label:
•Can be up to 128 characters in length
•Can contain any character other than a delimiter
•Can begin with A to Z, 0 to 9, or a national character (#, @, $)
•Must not consist of all numeric characters
Proc-name must be followed by the keyword PROC as a separate statement.
statement-1...n
Statement-1  to statement-n  are the statements that accomplish your procedure's task.
END-PROC
The END-PROC statement delimits the statements contained in the procedure.
PROGRAM Statement
The PROGRAM statement in  Easytrieve  identifies and initiates a processing activity that can optionally initiate JOB,
SORT, and SCREEN activities.
NOTE
Programs that include the PROGRAM statement must be compiled with the NEWFUNC option set to Y. The
following message is displayed when a program that includes the PROGRAM statement is compiled with the
NEWFUNC option set to N (compatibility mode):
*******B014 UNABLE TO RECOGNIZE STATEMENT
For more information about the NEWFUNC option, see Features and Enhancements Since Release 6.4.
A PROGRAM statement is required when:
•A program is the target of a TRANSFER from another program and parameters are passed between programs. See
TRANSFER Statement in "Statements S - Z."
•A program is the child program linked to from a parent program and parameters are passed between programs. See
LINK Statement in "Statements G - M."
•A parameter is passed to a program invoked from the operating system.
•You want to selectively execute other activities or execute a single activity multiple times.
 967 Easytrieve ® Report Generator 11.6
A PROGRAM statement defines an activity in which JOB, SORT, and SCREEN activities can be conditionally invoked.
If there is no PROGRAM statement, any JOB or SORT activities are sequentially executed until a SCREEN activity is
detected. The SCREEN activity is then executed. The sequential execution of activities does not proceed past the first
SCREEN activity. Any remaining activities must be executed by the first SCREEN activity.
A program terminates when:
•The bottom of the activity is reached
•A STOP EXECUTE statement is executed
•A TRANSFER statement is executed
A PROGRAM statement can be used to execute a sequence of statements. You can also use a JOB INPUT NULL
statement; however, you must then execute a STOP statement to terminate the activity.
This statement has the following format:
                            [        [ACTIVITY  ] [TERMINAL  ] ] 
PROGRAM [NAME program-name] [COMMIT ([          ] [          ])] +
                            [        [NOACTIVITY] [NOTERMINAL] ]
        [ENVIRONMENT  {NONE }] +
        [             {COBOL}]
        [USING field-name] [GIVING field-name]
[NAME program-name ]
The NAME parameter names the processing activity. Program-name  identifies the program. Program-name :
•Can be up to 128 characters in length
•Can contain any character other than a delimiter
•Can begin with A to Z, 0 to 9, or a national character (#, @, $)
•Must not consist of all numeric characters
This parameter is used for documentation purposes.
[COMMIT ([ACTIVITY|NOACTIVITY] [TERMINAL|NOTERMINAL])]
Specify the COMMIT parameter to control the logical unit of work. COMMIT indicates when the activity commits
recoverable work. Each commit point posts all updates, additions, and deletions, terminates holds, and closes
SQL cursors.
Specify ACTIVITY to commit all recoverable work during the normal termination of the activity. Specify
NOACTIVITY to tell  Easytrieve  not to commit at the end of the activity. ACTIVITY is the default.
Specify TERMINAL to commit all recoverable work during any terminal I/O operation. In CICS, this results in
terminal I/O being performed in a pseudo-conversational mode. Specify NOTERMINAL to tell  Easytrieve  not to
commit during a terminal I/O. TERMINAL is the default.
If this program is linked to by another  Easytrieve  program, this program performs terminal I/O as if
NOTERMINAL was specified.
NOTE
You can also issue your own COMMIT and ROLLBACK statements to commit or recover work on a
controlled basis.
For more information about commit processing, see the Programming Guide .
ENVIRONMENT (z/OS only)
Specifies to establish the proper execution environment prior to calling any COBOL subprograms. The
environment is established prior to the PROGRAM activity startup and is terminated after the activity has
terminated. ENVIRONMENT(COBOL) is ignored if the PROGRAM activity contains no CALL or EXECUTE
statement, and if no FILE EXITs are specified.
 968 Easytrieve ® Report Generator 11.6
The COBOL ENVIRONMENT started at the PROGRAM activity level stays active during any JOB activities
invoked from that PROGRAM activity. If the PROGRAM activity does not start a COBOL ENVIRONMENT, (or if
there is no PROGRAM activity), the COBOL ENVIRONMENT will be started for the JOB activities as directed by
the PARM ENVIRONMENT or the JOB ENVIRONMENT parameter specification.
When this parameter is absent, the default is ENVIRONMENT(NONE). No PARM statement, or Site Option
default is used. See JOB Statement  for more information about this parameter and the functionality of this feature.
WARNING
For performance considerations, we recommend that you set the ENVIRONMENT option to COBOL if
many  Easytrieve  programs are calling Language Environment subprograms. The option should be set
to NONE if most CALLs are made to non-Language Environment subprograms.
[USING field -name ]
Specify USING to indicate that this program (child program) can accept a parameter from the parent program or
operating system. Field-name  is the name of a field to which the parameter is passed.
NOTE
The data for the field-name  consists of a two-byte length value followed by the data. If the field-name
definition includes the VARYING parameter, the data in the field is alphanumeric and of varying length.
This applies to the standard way that z/OS invokes main programs. For more information about the
VARYING parameter, see DEFINE Statement .
If the program is linked via the LINK option of the PARM statement, the program could be invoked
directly on the JCL EXEC statement. Other programs could also invoke the program, but the
other program must observe the standard type one linkage convention. For more information, see
"Conventions for passing information through a parameter list" in the IBM z/OS MVS Programming:
Assembler Services Guide , available on the IBM website.
[GIVING field -name ]
Code GIVING to return a single parameter to the parent program. Field-name  is the name of a field containing the
parameter you want to return to the parent program.
Example: Equivalent Statements
FILE ...
  ...       PROGRAM NAME EXAMPLE1
  EXECUTE JOB1
  EXECUTE PANEL1
JOB NAME JOB1
  ...
 SCREEN NAME PANEL1
  ... 
is equivalent to:
FILE ...
  ...       
JOB NAME JOB1
  ...
 SCREEN NAME PANEL1
  ...       
Example: PROGRAM Statement with the USING Parameter
This example shows how the USING parameter can be used with the PROGRAM statement. The field that the USING
parameter accesses is named JCL-PARM, which is defined in the code with the VARYING option. The program
 969 Easytrieve ® Report Generator 11.6
TESTPARM receives the value for JCL-PARM from the PARM argument of the EXEC statement for the parent program
EZTPA00.
Program code:
//COMP  EXEC PGM=EZTPA00,PARM='0123456789ABCDEF'
//SYSIN    DD  *
PARM DUMP(PCODE)
DEFINE JCL-PARM S 100 A VARYING
PROGRAM NAME TESTPARM USING(JCL-PARM)
EXECUTE TESTPARM1
JOB INPUT(NULL) NAME TESTPARM1
DISPLAY 'JCL-PARM:        +' JCL-PARM '+'
DISPLAY 'JCL-PARM:LENGTH: +' JCL-PARM:LENGTH '+'
STOP
Program output:
JCL-PARM:        +0123456789ABCDEF +
JCL-PARM:LENGTH: +    16 +
PUSH Statement
The PUSH Statement in  Easytrieve  is a listing control statement that saves the current listing control indicators.
PUSH is useful in macros to control the listing of the macro expansion without affecting the listing control indicators
outside the macro. PUSH saves the current indicators. You can then set the listing control indicators for use during macro
expansion. Use the POP statement to restore the saved indicators.
NOTE
Use the LIST statement to set listing control indicators.
You can code a PUSH statement anywhere in  Easytrieve  source code. PUSH must be on a record by itself. PUSH does
not appear in the printed output.
This statement has the following format:
PUSH
PUT Statement
The PUT statement in  Easytrieve  performs sequential file output. PUT outputs records to SEQUENTIAL files and also
adds consecutive records (mass sequential insertion) to an INDEXED or RELATIVE file.
To take advantage of VSAM's mass-sequential-insertion capabilities, you can use the PUT statement to add many records
to the same place in any established VSAM file.
If you use the PUT statement, you must include the UPDATE parameter on the FILE statement for RELATIVE or
INDEXED files. You must specify CREATE for SEQUENTIAL files. UPDATE informs  Easytrieve  that all input records can
potentially be updated or deleted.
This statement has the following format:
                      [     { input-file-name] }]                         
PUT output-file-name [FROM {                 }][STATUS]                 
                     [     { input-record-name}]                        
 
 970 Easytrieve ® Report Generator 11.6
output-file-name
The output-file-name  parameter identifies the output file.
[FROM {input-file-name|input-record-name }]
FROM identifies the file or record from which the current record is copied.
When input-file-name is specified, the length of the output data is the same as output-file-name: RECORD-
LENGTH. The current value of input-file-name: RECORD-LENGTH is equal to the length of the input data.
However, if the length of the output file is greater than the length of the input file, the excess storage is not
initialized. Also, use of the FROM parameter does not update the data area of the output file.
For more information about RECORD-LENGTH, see the Programming Guide .
[STATUS]
Specify the STATUS parameter whenever the possibility exists for an unsatisfactory completion of the input/output
request.
STATUS checks input/output processing to see if it was performed properly. STATUS causes the file's FILE-
STATUS field to be set with the appropriate return code. To determine the meaning of the contents of FILE-
STATUS, see System-defined Fields. Normally, a zero or non-zero test is sufficient.
NOTE
FILE-STATUS is not defined if you do not specify a file type parameter on the FILE statement.
If you do not code STATUS and the operating system returns a non-zero status,  Easytrieve  issues an
appropriate diagnostic message.
Example
 FILE FILEA INDEXED UPDATE  
%PERSNL
FILE PERSNL
COPY FILEA
JOB INPUT PERSNL NAME MYPROG
   PUT FILEA FROM PERSNL STATUS  
  IF FILE-STATUS NE 0
    DISPLAY 'ADD FAILED'
    DISPLAY HEX PERSNL
    STOP
  END-IF
 
READ Statement
The READ Statement in  Easytrieve  provides random access to INDEXED and RELATIVE files.
The key specified is normally a working storage field or a field in another file. It cannot be the key field of the file unless
WORKAREA is specified to make the field available prior to the READ.
You can use a file presence test (IF file-name) to determine the success of the READ. The test is true when the last GET
or READ was successful.
This statement has the following format:
                    { key-field-name} [HOLD  ]
 READ file-name KEY {              } [      ] [STATUS]
                    {' key-literal' } [NOHOLD]
file-name
Specify the file-name  of the INDEXED or RELATIVE file to be randomly accessed.
 971 Easytrieve ® Report Generator 11.6
KEY {key-field-name|'key-literal' }
You must provide the key to the required record. The contents of key-field-name  or 'key-literal'  are used in a
search for a corresponding record in the file. Alphanumeric literals must be enclosed within single quotes. The
data format of key-field-name  or 'key-literal.'  is not changed. The access method can require that the search value
have the same length as the file's key. Key-field-name  cannot be nullable.
RELATIVE files require key-field-name to be a 4-byte binary integer field. 'Key-literal' is not allowed for a
RELATIVE file.
[HOLD|NOHOLD]
A hold request is automatically issued for records when UPDATE is specified on the FILE statement. Use
NOHOLD to override this process.
Specify HOLD to hold a record for update. This is the default when UPDATE is specified for the file. HOLD is
invalid if UPDATE is not specified on the FILE statement. HOLD does not mean you are required to perform
the update. It holds the position of the file and can also lock the record (CICS only). Records are automatically
released when the update operation completes or a commit point is taken. You can also manually release the hold
on any record with the RELEASE statement.
NOHOLD specifies that a record is not held for update.
[STATUS]
Specify the STATUS parameter whenever the possibility exists for an unsatisfactory completion of the input/output
request.
STATUS checks input/output processing to see if it was performed properly. STATUS causes the file's FILE-
STATUS field to be set with the appropriate return code. To determine the meaning of the contents of FILE-
STATUS, see System-Defined Fields . Normally, a zero or non-zero test is sufficient.
NOTE
FILE-STATUS is not defined if you do not specify a file type parameter on the FILE statement.
If you do not code STATUS and the operating system returns a non-zero status, an appropriate diagnostic
message is issued.
The key specified is normally a working storage field or a field in another file. It cannot be the file's key field unless
WORKAREA is specified to make the field available prior to the READ.
You can use a file presence test (IF file-name ) to determine the success of the READ. The test is true when the
last GET or READ was successful.
Example
FILE PERSNL INDEXED                                                     
%PERSNL                                                                 
FILE INKEYS SEQUENTIAL                                                  
  WHO 1 5 N                                                             
  TOTAL-NET W 5 P 2                                                     
JOB INPUT INKEYS NAME MYPROG FINISH DISPLAY-TOTAL                        READ PERSNL KEY WHO STATUS 
   IF PERSNL:FILE-STATUS NE 0                                           
      DISPLAY 'UNSUCCESSFUL READ +                                      
         PERFORMED ON FILE PERSNL'  +                                   
         +2 'KEY= ' WHO                                                 
   ELSE                                                                 
      TOTAL-NET = TOTAL-NET + PAY-NET                                   
   END-IF                                                               
   DISPLAY-TOTAL. PROC                                                  
     DISPLAY 'TOTAL NET PAY' TOTAL-NET                                  
   END-PROC                 
 972 Easytrieve ® Report Generator 11.6
RECORD Statement ( IDMS  and IMS/DLI)
RECORD statements (Format 1) identify the IDMS  database records available for automatic or controlled processing.
RECORD statements in Format 2 identify the IMS/DLI database segments that are to be available for processing.
NOTE
Code RECORD statements (Format 1) following the FILE statement to identify the IDMS  database records
available for automatic or controlled processing.
IDMS
All fields defined following the RECORD statement are part of this record. The name of each field must be unique within
the record. However, the field does not have to be unique within the file that contains the record being defined. If a field
defined in another record has the same name as a field defined in this record, then all references to either field must be
qualified with the name of the field's containing record .
NOTE
The RECORD statement cannot be used to define logical records. To define a logical record, use the LOGICAL-
RECORD statement. To define an element record within a logical record, use the ELEMENT-RECORD
statement.
IMS/DLI
RECORD allocates a work space that contains the segment data during execution. Field definition statements, coded
immediately following a RECORD statement, relate to data fields within that segment. One RECORD statement must
be coded for each segment of the database to be processed. They must be coded in the same order as in the PSB that
defines the database. Not all segments of a database need to be defined, but the parent segment of each RECORD must
be coded because incomplete paths are not supported.
This statement has the following format:
Format 1 ( IDMS )
RECORD record-name record-length [KEY (field-name ...)]   
Format 2 (IMS/DLI)
RECORD segment-name segment-length [parent-segment-name]  +            
                                                                       
      [KEY ( key-field-name, key-field-location , key-field-length)]   
Format 1 ( IDMS )
record-name
Record-name  is the 1- to 16-character name of the record as defined in the subschema.
record-length
Record-length  is a positive integer that designates the length of the record as defined in the subschema.
[KEY (field-name  ...)]
KEY is an optional parameter that identifies the CALC keys of the record. The KEY parameter is required only for
the root record when using the tickler file. Field-name  is the 1- to 30-character name used to designate one of the
record's CALC keys. Field-name  must correspond to a CALC key field defined with the DDL for the record. You
must code the field-name  parameter for each CALC key defined for the record.
In addition, a DEFINE statement for each field-name must be coded following the RECORD statement. The
DEFINE statement can be intermingled with DEFINE statements for other non-key fields of the record.
Format 2 (IMS/DLI)
 973 Easytrieve ® Report Generator 11.6
segment-name
Segment-name  is the one- to eight-character name of the segment. This name must correspond to the name of a
segment in the DBD.
segment-length
Segment-length  is a positive numeric integer that designates the length of the segment.
[parent-segment-name ]
Parent-segment-name  is an optional parameter that designates the parent of segment-name . This parameter is
not coded for the root segment, but it is required for all other segments.
[KEY]
The optional KEY parameter identifies the sequence field for the segment.
The KEY parameter is not necessary for the RECORD statement that defines the lowest segment in a path. The
KEY parameter is required for the root segment when using the tickler file.
(key-field-name )
Key-field-name  is the one- to eight-character name used to designate the keyfield to the IMS/DLI database. The
name must correspond to the sequence field named in the DBD.
(key-field-location )
Key-field-location  is a positive numeric integer that specifies the location of the key field within the segment.
(key-field-length)
Key-field-length  is a positive numeric integer that specifies the length of the key field.
REFRESH Statement
The REFRESH statement in  Easytrieve  is used in the AFTER-SCREEN procedure to restore the initial screen image by
rebuilding it with the current values of the program fields.
When used as the result of pressing an IMMEDIATE key, REFRESH redisplays the screen image with the original data
displayed on the screen. This is useful when the terminal user enters erroneous data on the screen and wants to restore
the screen with its original data.
When used as the result of a non-IMMEDIATE key, REFRESH can be used to rebuild the screen using current data from
the screen.
REFRESH can also be invoked directly by pressing a particular attention key. For more information, see KEY Statement .
This statement has the following format:
REFRESH
Example
The following example illustrates the REFRESH statement being invoked when F6 is pressed. Because F6 is not an
IMMEDIATE key, the current values of QTY and PRICE are used to compute the extended price. F5 is used to clear
erroneous data from the screen.
DEFINE EXT-PRICE W 4 P 2
DEFINE QTY W 4 P 0
DEFINE PRICE W 4 P 2
SCREEN NAME TEST-REFRESH
  KEY F2 NAME 'Reset to zero'
  KEY F3 EXIT NAME 'Exit'
  KEY F5 IMMEDIATE REFRESH NAME 'Refresh screen'
  KEY F6           NAME 'Compute Ext Price'
 974 Easytrieve ® Report Generator 11.6
  TITLE 'TEST REFRESH'
  ROW 3 'Quantity . .' QTY
  ROW 5 'Price  . . .' PRICE
  ROW 7 'Ext Price  .' EXT-PRICE
  BEFORE SCREEN. PROC
    MOVE ZERO TO QTY, PRICE, EXT-PRICE
  END-PROC
  AFTER-SCREEN. PROC
    IF KEY-PRESSED = F6             
      EXT-PRICE = QTY * PRICE       REFRESH
    END-IF                         
  END-PROC
RELEASE Statement
The RELEASE statement in  Easytrieve  explicitly releases the hold on any record in a file.
Easytrieve  automatically issues a hold request for GETs and READs when UPDATE is specified on the FILE statement.
Records are automatically released when the update operation completes or a commit point is taken. Alternatively, you
can use the RELEASE statement to manually release the hold on a record. If HOLD is not specified, RELEASE is ignored.
This statement has the following format:
RELEASE file-name 
file-name
File-name  is the name of a file.
Example
READ PERSNL KEY '01193' HOLD
...
 IF ...
  WRITE PERSNL UPDATE
ELSE  RELEASE PERSNL
END-IF
REPEAT and END-REPEAT Statements
The REPEAT/END-REPEAT construct in  Easytrieve  is used to display arrays on a screen.
Each array field on a ROW statement can be subscripted by the subscript  specified in the VARYING parameter.
Optionally, array fields on ROW statements can contain a subscript for a second dimension. However,  Easytrieve  does
not automatically increment this second subscript.
This statement has the following format:
                      [                   [     { start-field-name} ] ]
 REPEAT number [TIMES] [VARYING subscript  [FROM {                } ] ]  +
                      [                   [     { start-integer   } ] ]
 
       [ROW row-number]
 975 Easytrieve ® Report Generator 11.6
 
ROW statements
END-REPEAT                                                         
number
Number  is the number of times the group of ROW statements in the REPEAT construct is repeated.
[TIMES]
Optionally, code TIMES for statement readability.
[VARYING subscript ]
VARYING is an optional parameter that causes  Easytrieve  to automatically increment a subscript field
(subscript ).
The subscript is incremented by one, n times, where n is specified by number.
Subscript can be the name of a previously defined field. However, if it is not defined,  Easytrieve  automatically
defines the field as a 2 B 0 field. If you defined the field, you must have defined it as numeric (N, P, U, B, I) with
zero or no decimal places.
[FROM {start-field-name|start-integer }]
FROM is an optional parameter that defines the initial value for the REPEAT subscript . Subscript  is automatically
incremented by one from either start-field-name  or start-integer  for each iteration of the group of ROW
statements. If FROM is omitted, the subscript starts at 1.
[ROW row-number ]
Specify the row-number on which the repeating group of rows starts. If this is not specified, the repeating group of
rows starts on the last screen row specified plus one.
ROW statements
Code one or more ROW statements to be repeated. ROW statements are coded in a REPEAT/END-REPEAT
construct. For more information, see ROW Statement .
NOTE
ROW statements to be repeated cannot specify explicit row-numbers.
END-REPEAT
END-REPEAT terminates the body of the REPEAT statement. END-REPEAT must be specified after each
REPEAT statement and its associated ROW statements.
Example
The following example illustrates how to display an array on a screen. The REPEAT construct displays both a one-
dimensional array (WS-NAME), and a two-dimensional array (WS-STAT). Starting at row 4,  Easytrieve  displays the first
occurrence of the fields. The second dimension of WS-STAT is stated explicitly.  Easytrieve  increments USER-SUB and
displays the next occurrence until 15 occurrences are displayed.
This code:
...                                                                             
WS-EMPLOYEE W 33 A OCCURS 30        . * 2-DIMENSIONAL TABLE OF                  
  WS-NAME     WS-EMPLOYEE      30 A . * 30 EMPLOYEES CONTAINING:                
  WS-STATUSES WS-EMPLOYEE +30   3 A . * EMPLOYEE NAME AND                       
    WS-STAT WS-STATUSES 1 A OCCURS 3. * 3 STATUSES                              
...                                                                             
SCREEN NAME EMPLOYEE-LIST                                                       
  TITLE 'List of Employees'                                                     
 976 Easytrieve ® Report Generator 11.6
  ROW 3 'Name' COL 30 'Statuses'                                                  REPEAT 15 TIMES VARYING
 USER-SUB                                              
     ROW WS-NAME (USER-SUB) +                                                   
         WS-STAT (USER-SUB, 1) WS-STAT (USER-SUB, 2) WS-STAT (USER-SUB, 3)        END-REPEAT                  
                                                  
Produces:
                         List of Employees
 Name                          Statuses
 WIMN, GLORIA                  F G O
 BERG, NANCY                   C 
 CORNING, GEORGE               I T
 ...
REPORT Statement
The REPORT statement in  Easytrieve  defines the type and characteristics of a report.
Although you can specify a large number of REPORT statement parameters, you will probably produce most reports using
default parameter values specified in the Site Options Table.
REPORT statement parameters fall into five basic groups:
•Format determination parameters
•Label parameters
•File directing parameters
•Spacing control parameters
•Testing aid parameters
The data window for fields with VARYING specified on the DEFINE statement is based on the maximum length of the
field. The window is padded to the right with blanks for VARYING fields less than the maximum.
You need not code the SUMMARY parameter to use SUMFILE.
For a complete explanation of reporting facilities, see Programming .
This statement has the following format:
REPORT [ report-name]+
[XML]+                     } 
[SUMMARY]+                    } 
[SUMFILE summary-  file- name]+        } 
[SUMSPACE sumfield -addition ]+     } 
[TALLYSIZE tally- print- size]+     }
                        } 
[ {EVERY}]                 } 
[DTLCTL{FIRST}]+               } Format 
[ {NONE}]                 } Determination  
                       } Parameters  
[ { [ALL]   }]           }
 
[SUMCTL {([HIAR] [DTLCOPY])}]+       } 
[ { [NONE] [DTLCOPYALL] }]         } 
 977 Easytrieve ® Report Generator 11.6
[ { [TAG ] }]              } 
                         }
 
[ [ACROSS number- of- labels] ]         } 
[LABELS ([DOWN number- of- lines ])]+      } Label 
[ [SIZE label-length ] ]       } Parameters  
[ [NEWPAGE           ] ]        } 
 
                          }
[FILE work- file- name]+                   } File Directing  
[PRINTER receive-  file- name]+                } Parameters
 
[PAGESIZE ( line- page- size [display-  page- size])]+       } 
[LINESIZE line-length]+                 } 
[SKIP number- of- lines]+                    } 
[SPACE number- of- spaces]+                      } 
[TITLESKIP number- of- lines]+                  } 
[CONTROLSKIP number- of- lines]+                   } 
                             }
[SPREAD ]+                         } 
 
[NOSPREAD]                          } Spacing Control  
                              } Parameters  
[NOADJUST]+                          } 
                              } 
[NODATE ]                          } 
 
[LONGDATE ]+                       } 
[SHORTDATE]                        } 
                              } 
[NOPAGE]+                          } 
[NOHEADING]+                         } 
                           } 
[LIMIT number- of- records]+               } Testing Aid  
[EVERY n- number- of-lines]                } Parameters  
Format Determination [ report-name ]
Report-name  identifies the report. It is optional when there is only one report in a JOB activity. If you code multiple
reports, the first report can be unnamed but all others must be named. Each report-name  must be unique in the
JOB activity. At least one report-name  must be coded on a PRINT report-name  statement. For unnamed reports,
code the PRINT statement without a report-name  parameter.
Report-name :
•–Can be up to 128 characters in length
–Can contain any character other than a delimiter
–Can begin with A to Z, 0 to 9, or a national character (#, @, $)
–Must not consist of all numeric characters
•[XML]
Optionally use XML to produce a file formatted using Extensible Markup Language (XML). This hierarchically-
structured file is built according to the field relationships defined by REPORT, CONTROL, and LINE statements.
 978 Easytrieve ® Report Generator 11.6
Any spacing or positioning parameters (such as NOADJUST, COL, and SKIP) are ignored because the XML file
contains only field name (or HEADING) values and data values. XML also changes the default setting of the DTLCTL
parameter to EVERY. This causes every line-statement field to be written to the XML output file for each execution of a
PRINT statement. This behavior can be overridden using the DTLCTL parameter described later in this section.
For an XML-formatted report, no printed output is generated. There are no control totals or summary data lines printed
or written to any file. For information about the XML report feature, see Programming .
•[SUMMARY]On control reports, SUMMARY inhibits printing of detail data. Only control totals are printed.
•[SUMFILE summary-file-name] Optionally, use SUMFILE to generate a summary file that contains the control and
summary field values. Summary-file-name  identifies the file to contain the summary data.
•[SUMSPACE sumfield-addition]Use SUMSPACE to define the print size for total fields on a control report. Sumfield-
addition  is added to the length (in digits) of the field to define its print size. This expansion is necessary to prevent the
loss of significant data due to overflow conditions. The resulting print length is limited to a maximum of 18 digits. Valid
values for sumfield-addition  are 0 to 9. No additional numeric edit characters are included in the resulting edit mask.
For example, totals such as 55555,555.55 can appear.
•[TALLYSIZE tally-    print-size   ]Use TALLYSIZE to set the print size for the field TALLY. Valid values for tally-print-
size are 1 to 18. The number of digits used for TALLY on a summary line is the sum of the values of TALLYSIZE and
SUMSPACE.
•[DTLCTL {EVERY|FIRST|NONE}]DTLCTL optionally defines detail line printing characteristics.
Specify EVERY to print the value of all control fields on every detail line.
Specify FIRST to print the value of all control fields on the first detail line of a page and on the first detail line after each
control break. Control field values are not printed on all other detail lines. Specify NONE to inhibit the printing of control
field values on detail lines.
•[SUMCTL {[ALL|HIAR|NONE|TAG] [DTLCOPY|DTLCOPYALL]}]
SUMCTL optionally defines total line printing characteristics. Specify ALL to print control field values on every total line.
Specify HIAR to print control field values in a hierarchical fashion on total lines. Only values for control fields on the
same hierarchical level, or higher than the breaking control field, are printed on the associated total line.
Specify NONE to inhibit printing of control field values on total lines.
Specify TAG to print control-field-name TOTAL as an annotation to the left of the associated total line where control-
field-name is the field-name for the breaking control field. There must be sufficient unused space on the left side of the
total line for this annotation.
Specify DTLCOPY to print detail information on total lines. Normally, only control field values and associated totals are
printed on total lines. Coding DTLCOPY prints the detail field contents, prior to the break, on the total line. These fields
are printed only when LEVEL is one (1).
Specify DTLCOPYALL to print detail fields for all control breaks.
•Label [LABELS [ACROSS   number-of-labels   ][DOWN   number-of-lines   ][SIZE label -length ][NEWPAGE]]
Specify LABELS to indicate that the report is a label report.
NOTE
The NOHEADING and NOADJUST options are automatically activated when you specify LABELS; therefore,
you cannot specify TITLE and HEADING statements. You cannot use LABELS with SUMMARY.
Specify ACROSS number-of-labels to define the number of labels printed across the print line.
Specify DOWN to define the number of lines in a label. The value of number-of-lines is the number of lines reserved for
each label. The value range for number-of-lines is 1 to nnn, where nnn is at least as large as the largest corresponding
LINE nnn value.
Specify SIZE to set the length of each label. The value of label-length is the number of print positions on a label. Label-
length has a value range from 1 to nnn, where nnn is the length of the label.
NOTE
LABELS cannot be specified for extended reporting printers.
NEWPAGE controls the printing of the first line (LINE 01) of each label. When coded, NEWPAGE associates a printer
top-of-form request with the first line of each label.
The following algorithm confines the overall size of labels:
 979 Easytrieve ® Report Generator 11.6
LINESIZE >= (ACROSS - 1) * SIZE + ( number of print positions  on an individual  label) 
•File Directing [FILE work-file-name ]
Optionally, specify FILE to identify the work file used for very large reports. Code this parameter when the default VFM
work file is too small to contain the report data. Work-file-name identifies the FILE that receives the work file data
NOTE
You should not use the FILE parameter in CICS. An execution error occurs when work-file-name is not a
virtual file.
NOTE
Instead of coding the FILE parameter for each report in your program, you can use the WORKFILE YES
parameter on the PARM statement. For more information, see PARM Statement.
•[PRINTER receive-file-name]
Optionally, specify PRINTER to direct the report's printed output. Receive-file-name  identifies the FILE that receives
the report. This file must have the PRINTER or EXTENDED attribute specified. The default is the  Easytrieve  standard
print output file: SYSPRINT. The actual destination of SYSPRINT is determined by a site option. For more information
about the actual destination of SYSPRINT, see your system administrator. For more information about PRINTER files,
see Programming .
If the system print output file or receive-file-name has been associated with an extended reporting printer, then 
Easytrieve  automatically formats the report to satisfy the requirements defined for that extended reporting printer. 
Easytrieve  restricts the support of extended reporting facilities to those reports that are output to printer files that have
been associated with an extended reporting printer.
Spacing Control-each of the following parameters modifies the default spacing of a report page. You normally do not
use these parameters; however, they are available to support unique report spacing requirements.
•[PAGESIZE (line-page-size [display-page-size])]Specify PAGESIZE to define the logical print length of a printed
page. Line-page-size  must be an unsigned integer from 1 to 32767, and must be at least as large as the sum of:
•–Title-number of the last TITLE statement
–Number-of-lines of TITLESKIP
–Number of HEADING lines plus one
–Line-number  of the last LINE statement
–Number-of-lines of SKIP
In other words, at least one line group must fit on a report page.
Specify an asterisk (*) for line-page-size if you want to change display-page-size without changing the default line-
page-size.
Display-page-size must be zero or greater than or equal to the line-page-size.
When  Easytrieve  processes a LINE statement, it compares the line count to line-page-size. If the line count is less
than line-page-size, the LINE statement performs the BEFORE-LINE procedure and then prints the line. If the line
count is greater than or equal to line-page-size, the LINE statement performs the ENDPAGE procedure, processes
TITLEs, performs the BEFORE-LINE procedure, and finally prints the line. The line count is not compared again to
line-page-size after the LINE statement performs the BEFORE-LINE procedure.
Specify a value greater than zero for display-page-size to allow the DISPLAY statement to generate page breaks.
When display-page-size is greater than zero, the line count is compared to display-page-size. If the line count is
greater than display-page-size, then the DISPLAY statement performs the ENDPAGE procedure and generates a
page break with TITLEs.
Specify zero for display-page-size to inhibit DISPLAY statement generated page breaks. When display-page-size is
zero, the DISPLAY statement does not compare line count to display-page-size, and a page break is not generated.
The DISPLAY statement always increases line count, regardless of the display-page-size value.
When the report is directed to an extended reporting printer that does not support a Forms Control Block (FCB),
then  Easytrieve  multiplies line-page-size by the default height of the assigned extended reporting printer. This
enables  Easytrieve  to compare PAGESIZE with the heights of fonts used on the report, because they are both
 980 Easytrieve ® Report Generator 11.6
in the same base unit (the H-unit). The value of line-page-size multiplied by the default height of the assigned
extended reporting printer cannot exceed the maximum page length of that extended reporting printer.
•[LINESIZE line-length ]
Code the LINESIZE parameter to specify the maximum number of data characters that can be printed on a line. Line-
length  must be an unsigned integer from 1 to 32767.
Line-length must be at least one less than the length of the data portion of the file's logical record. If the FILE definition
does not provide the file's format and logical record length, then no compile time verification of the line-length is done.
The default value of LINESIZE is calculated as one less than the data portion of the logical record if the file format and
record length are known at compile time. Otherwise, the default is taken from the LINESIZE site option.
There are additional control characters (forms control information) that also must be stored in a logical record. If one of
the record format parameters is specified, it must be large enough to hold both the forms control information and the
data characters. The value of line-length must be less than or equal to the maximum record length minus the size of
the forms control information.
The first character in a PRINTER file contains the ASA carriage control information.
When the report is assigned to an extended reporting printer that is not a standard line printer, the maximum value of
line-length is not dependent upon the record size of the print data set. The insertion of overprint and function codes
into print records and the support of different fonts on the same print line all impact the relationship between LINESIZE
and print data set record size.  Easytrieve  supports any LINESIZE, provided line-length multiplied by the value of
the assigned extended reporting printers default width does not exceed the maximum page width of that extended
reporting printer.
Line-length overrides the value defined in the Site Options Table. If the report is directed to an extended reporting
printer,  Easytrieve  multiplies line-length by the default width of the assigned extended reporting printer. This value
defines the width of the print line in terms of the extended reporting printer's W-unit.
•[SKIP number-of-lines] Specify SKIP to define the number of blank lines to be inserted between line groups (between
the last LINE nnn and the next LINE 01). Number-of-lines  has a valid range of 0 to nnn, where nnn allows for the
printing of at least one line group on each page. When you specify a value of 0, a line group containing multiple
lines can be spanned across a page break. A non-zero value inhibits this spanning. When the report is directed to
an extended reporting printer that does not support a Forms Control Block (FCB), the default height of the assigned
extended reporting printer defines the height of each line.
•[SPACE number-of-spaces]Specify SPACE to adjust the default number of blanks (space characters) inserted
between fields on TITLE and LINE statement items. The value of number-of-spaces  has a valid range of 0 to nnn
(default is 3), where nnn does not cause line overflow. When the report is directed to an extended reporting printer, 
Easytrieve  multiplies number-of-spaces by the default width of the assigned extended reporting printer. This operation
expresses number-of-lines in terms of the printer's W-unit. 
NOTE
The SPREAD parameter overrides this parameter.
•[TITLESKIP number-   of-lines  ]
Specify TITLESKIP to insert blank lines between the last title line and the first heading line (or LINE 01) of a report.
The value of number-of-lines  has a valid range of 0 to nnn, where nnn allows for the printing of at least one line group
on each page.
When the report is directed to an extended reporting printer that does not support a Forms Control Block (FCB), the
height of each line is defined by the default height of the assigned extended reporting printer. This operation converts
number-of-lines into the H-units applicable to the printer.
•[CONTROLSKIP   number-   of-lines  ]Specify CONTROLSKIP to define the number of blank lines to be inserted
following CONTROL total lines and the next detail line. Number-of-lines  must be between 0 and 32767. If
CONTROLSKIP is not specified, one blank line plus the SKIP value is inserted after the CONTROL total line.
•[SPREAD|NOSPREAD] Specify SPREAD to insert the maximum number of spaces between each column of a report.
NOSPREAD deactivates SPREAD when it is the default specified in the Site Options Table. SPREAD and NOADJUST
are mutually exclusive. For more information about this parameter, and examples, see Programming .
 981 Easytrieve ® Report Generator 11.6
NOTE
SPREAD overrides the SPACE parameter.
•[NOADJUST]  Specify NOADJUST to left-justify the title lines and report on the page. The default is centered on the
page. SPREAD and NOADJUST are mutually exclusive.
•[NODATE|LONGDATE|SHORTDATE]Specify NODATE to inhibit the printing of the date value on the first title line
(TITLE 01).
LONGDATE specifies that SYSDATE-LONG is to appear on the first title line.
SHORTDATE specifies that SYSDATE is to appear on the first title line.
•[NOPAGE]Specify NOPAGE to inhibit the printing of the value of PAGEWRD (in the Site Options Table) and the
current page number in the report title.
•[NOHEADING] Specify NOHEADING to inhibit the printing of column headings. The default is that each field's
HEADING value is printed as a column heading.
Testing Aid LIMIT and EVERY are used as testing aids for report development. These parameters control the amount
of data output on a report.
•[LIMIT number-of-records] Specify LIMIT to limit the number of records processed by the report. The value of
number-of-records  has a valid range of 1 to 32,767.
•[EVERY n-number-of-lines]Specify EVERY to indicate that only every n line is printed in the report. The value of n-
number-of-lines  has a valid range of 1 to 32,767.
REPORT-INPUT Report Procedure
A REPORT-INPUT procedure in  Easytrieve  selects or modifies report input data.
This procedure is performed for each PRINT statement (report input). To cause the data to continue into report
processing, you must execute a SELECT statement for the associated input data. In other words, input that does not get
selected is bypassed for continued processing.
Although you can code the logic to select records in the JOB activity itself, you can occasionally place the logic in a
REPORT-INPUT procedure.
When the report data has been spooled (because the report had been sequenced or the printer file was in use), the
REPORT-INPUT procedure is invoked as each spooled record is read to produce this report. This means that all records
printed are spooled and sorted (if SEQUENCE is specified). The REPORT-INPUT procedure is then invoked. For
performance reasons, you should select the records in a JOB activity, if possible.
A REPORT-INPUT procedure must be delimited by an END-PROC statement. See PROC Statement  for more
information.
This statement has the following format:
REPORT-INPUT. PROC
Example
The following example illustrates use of the REPORT-INPUT procedure in final report input selection. Only the first record
in each ZIP code is selected.
Statements:
FILE FILE1                                                              
LAST-NAME  1  5 A                                                       
STATE      6  2 A                                                       
ZIP        8  5 N                                                       
PAY-NET    13 5 N 2                                                     
 982 Easytrieve ® Report Generator 11.6
HOLD-ZIP    S 5 N VALUE 00000                                           
JOB INPUT FILE1 NAME MYPROG                                             
  PRINT REPORT1                                                         
*                                                                       
REPORT REPORT1 LINESIZE 65 +                                            
  SUMMARY  SUMCTL DTLCOPY                                               
  SEQUENCE STATE ZIP                                                    
  CONTROL  STATE NEWPAGE ZIP                                            
  TITLE 'REPORT FOR THE STATE OF' STATE                                 
  LINE 01  LAST-NAME STATE ZIP PAY-NET                                  
*                                                                       
 REPORT-INPUT. PROC                                                      
  IF ZIP NE HOLD-ZIP                                                    
    HOLD-ZIP = ZIP                                                      
    SELECT                                                              
  END-IF                                                                
END-PROC                                                                
*                                                                      
 Data:
BROWNIL6007612345                                                       
BROWNIL6007667890                                                       
JONESIL6007709876                                                       
JONESIL6007754321                                                       
SMITHTX7521811111                                                       
SMITHTX7521866666                                                      
Results:
11/23/09           REPORT FOR THE STATE OF   IL      PAGE      1       
                                                                       
             LAST-NAME   STATE    ZIP     PAY-NET                      
               BROWN      IL     60076      123.45                     
               JONES      IL     60077       98.76                     
                          IL                222.21                     
                                                                       
11/23/09           REPORT FOR THE STATE OF   TX      PAGE      2       
                                                                       
             LAST-NAME   STATE    ZIP     PAY-NET                      
               SMITH      TX     75218      111.11                     
                          TX                111.11                     
                                                                       
                                            333.43                    
RESHOW Statement
The RESHOW statement in  Easytrieve  is used in an AFTER-SCREEN procedure to redisplay the screen image with
user-entered data intact.
In contrast to the REFRESH statement, the screen image is not rebuilt using the current values of program fields.
 983 Easytrieve ® Report Generator 11.6
Upon receiving the screen,  Easytrieve  saves a copy of the screen image. The RESHOW statement restores the saved
image.
This statement has the following format:
RESHOW
Example
As shown in the following example, RESHOW can be used to redisplay a screen following a request for help. The data
that the user entered on the screen before they requested help is redisplayed intact. When RESHOW is used with an
IMMEDIATE KEY, original screen data is retained, but not edited or saved into program fields.
...
 SCREEN NAME MENU UPPERCASE
  KEY ENTER
  KEY F1 NAME 'Help' IMMEDIATE
  KEY F3 NAME 'Exit' EXIT
  TITLE...
  ROW...
  AFTER-SCREEN. PROC
    IF KEY-PRESSED = F1
      EXECUTE MENU-HELP       RESHOW
    END-IF
    CASE OPTION
    ...
  END-PROC
SCREEN NAME MENU-HELP
  KEY F3 NAME 'Exit' EXIT
  TITLE...
  ROW...
RETRIEVE Statement ( IDMS  and IMS/DLI)
The RETRIEVE statement in  Easytrieve  identifies the database records that are automatically input to the JOB activity.
Code the RETRIEVE statement immediately following a JOB statement to specify automatic input. You can code only one
RETRIEVE statement in each JOB activity.  Easytrieve  processes the automatic input the same way as non-database
input.
For RETRIEVE statement examples, see the Programming Guide .
This statement has the following format:
Format 1 ( IDMS )
RETRIEVE  file-name  +                                                  
                                                                        
 [             { program-name     }]                                     
 [PROGRAM-NAME {                 }]  +                                  
 [             {' program-literal'}]                                     
                                                                        
 [       { db-name-table-name     }]                                     
 984 Easytrieve ® Report Generator 11.6
 [DBNAME {                       }]  +                                  
 [       {' db-name-table-literal'}]                                     
                                                                        
 [     { node-name     }]                                                
 [NODE {              }]  +                                             
 [     {' node-literal'}]                                                
 [         { dictionary -name     }]                                     
 [DICTNAME {                    }]  +                                   
 [         {' dictionary -literal'}]                                      
                                                                        
 [         { dictionary -node-name     }]                                 
 [DICTNODE {                         }]  +                              
 [         {' dictionary -node-literal'}]                                 
                                                                        
 [KEYFILE tickler-file-name +                                 ]   ]   
 [KEYVALUE ( calc-key-field-name EQ calc-value-field-name ...) ] + ]   
 [                                                                ] + 
 [DUPS                                                            ]   
 [NODUPS                                                          ]   
                                                                        
 SELECT ( record-name  +                                                 
                                                                        
        [AREA  ' area-literal'  +                                    ]   
        [SET   ' set-literal'  +                                     ] + 
        [INDEX ' index-set-literal' [USING (' index-key-literal' ...)]]    
        [ID ' path-literal']  +                                          
                                                                        
        [LIMIT number-of-records] +                                      
                                                                        
        [WHILE ( condition )]  +                                          
                                                                        
        ...)                                                           
Format 2 (IMS/DLI)
RETRIEVE  file-name  +                                                  
                                                                        
  [KEYFILE tickler-file-name  KEYVALUE key-field-name]  +               
                                                                        
  SELECT ( record-name  +                                                
                                                                        
         [ID  ' path-literal']  +                                        
                                                                        
         [LIMIT number-of-records]  +                                   
                                                                        
         [SSA ' segment-literal']  +                                     
                                                                        
         [WHILE ( condition )]  +                                         
                                                                        
         ...)                                                          
 985 Easytrieve ® Report Generator 11.6
Format 1 ( IDMS )
file-name
File-name  is the same as the name coded in the FILE  file-name IDMS and JOB  INPUT  (file-name)  statements.
[PROGRAM-NAME { program-name |'program-literal '}]
Program-name  or 'program-literal'  specifies the name used to identify the program to IDMS  during execution.
Program-name  must be an eight-byte alphanumeric field. 'Program-literal'  must be alphanumeric and is padded to
the right (if necessary) to create an eight-byte value.
[DBNAME { db-name-table-name |'db-name-table-literal '}]
Db-name-table-name  or 'db-name-table-literal'  specifies a DB name table. Data retrieved during execution of the
user's program is from the named IDMS  database. Db-name-table-name  must be an eight-byte alphanumeric
field. 'Db-name-table-literal'  must be alphanumeric and is padded to the right (if necessary) to create an eight-byte
value.
[NODE {node-name |'node-literal '}]
Node-name  or 'node-literal'  specifies the central version node that hosts the IDMS  activity generated by the
user's program. Node-name  must be an eight-byte alphanumeric field. 'Node-literal'  must be alphanumeric and is
padded to the right (if necessary) to create an eight-byte value.
[DICTNAME { dictionary-name |'dictionary-literal '}]
Dictionary-name  or 'dictionary-literal'  specifies the dictionary name of a secondary load area. Dictionary-name
must be an eight-byte alphanumeric field. 'Dictionary-literal'  must be alphanumeric and is padded to the right (if
necessary) to create an eight-byte value.
[DICTNODE { dictionary-node-name |'dictionary-node-literal '}]
Dictionary-node-name  or 'dictionary-node-literal'  specifies the dictionary node of a secondary load area.
Dictionary-node-name  must be an eight-byte alphanumeric field. 'Dictionary-node-literal'  must be alphanumeric
and is padded to the right (if necessary) to create an eight-byte value.
[KEYFILE tickler -file -name][KEYVALUE (calc -key-field -name  EQ calc -value -field -name  ...)][DUPS|
NODUPS]
The optional tickler file is designated by coding the KEYFILE and KEYVALUE parameters. Tickler-file-name is the
name of a file that is sequentially processed to obtain the keys of the root records to be retrieved. The DBCS code
system of tickler-file-name  must equal the DBCS code system of file-name .
Calc-value-field-name is a data field from tickler-file-name that contains a value for one of the CALC keys of the
root record. Calc-key-field-name is a CALC key field defined in the RECORD statement for the root record that is
to receive the value of calc-value-field-name. For information about coding how calc-value-field-name is assigned
to calc-key-field-name, see the Programming Guide .
You must code one calc-value-field-name for each key field defined in the KEY parameter of the RECORD
statement for the root record.
The key values are used in the CALC retrieval of root records. Therefore, only CALC records can be root records
when the tickler file is used. The optional keywords, DUPS and NODUPS, are used to specify whether CALC
records with duplicate keys are also retrieved. The OPTIONS table parameter CALCDUP has the default value.
The JOB activity is terminated at end-of-file for tickler-file-name.
The KEY parameter for the root record retrieved by the tickler file option must be specified on the RECORD
statement.
[SELECT ( record -name  ...)]
The SELECT parameter identifies which paths are retrieved. Record-name  must be the same as coded on a
RECORD statement. Any number of records and paths can be coded under control of the following rules of
network structure:
•The first record-name  coded is the root. It is retrieved by an area sweep, tickler file, or integrated index.
•A repeated record-name  denotes a node in the network. A node is a record-type that is common in multiple
paths. The optional subparameters are not allowed when a record-name  is repeated as a node.
•Paths are retrieved in the order in which they are identified.
 986 Easytrieve ® Report Generator 11.6
[AREA 'area -literal ']
The optional AREA subparameter is coded to supply the sweep area. This subparameter can be specified only
if record-name  is a root record. AREA is not allowed if INDEX has already been specified for this record. The 1-
to 16-character IDMS  area name ( 'area-literal' ) controls retrieval within area of root records. 'Area-literal'  must be
alphanumeric (non-DBCS), and is padded to the right (if necessary) to create a 16-byte value.
If the AREA subparameter is coded,  Easytrieve  uses OBTAIN NEXT record-name WITHIN AREA calls to
retrieve occurrences of this record. If this subparameter is omitted,  Easytrieve  uses OBTAIN NEXT record-name
calls instead.
[SET 'set-literal ']
The SET subparameter specifies the name of the set used for retrieving the named record ( record-name ). This
subparameter is not allowed if record-name  is the root record or if record-name  is a node. SET is required for all
other records. 'Set-literal'  must be alphanumeric (non-DBCS), and is padded to the right (if necessary) to create a
16-byte value.
If this record is a member of the specified set,  Easytrieve  uses OBTAIN NEXT record-name WITHIN SET calls
to retrieve occurrence of this record. If this record is the owner of the specified set,  Easytrieve  uses OBTAIN
OWNER calls instead.
[INDEX 'index -set-literal '[USING ('index -key-literal ' ...)]]
Code the optional INDEX subparameter to designate the index set ( 'index-set-literal' ) that controls root retrieval
by integrated indexing. This subparameter can be specified only if record-name  is a root record. INDEX is not
allowed if AREA has already been specified for this record. 'Index-key-literal'  must be a alphanumeric (non-
DBCS), and is padded to the right (if necessary) to create a 16-byte value.
Note : The INDEX subparameter cannot be used with the tickler file.
The optional USING subparameter ('index-key-literal') designates the alphanumeric literals used to constrain the
index. You can code as many occurrences of 'index-key-literal' as are required to fully specify the index key value.
The values are concatenated in the order specified and form the index key value that is passed to IDMS . The
cumulative length of all literals specified must match the length of the index known to integrated indexing. The
code system of the data must also match.
When the INDEX subparameter is coded,  Easytrieve  uses OBTAIN NEXT WITHIN SET calls to retrieve all
occurrences of the root record except for the first occurrence. The retrieval of the first occurrence is determined
by the optional USING subparameter. If the USING subparameter is coded,  Easytrieve  retrieves the first root
record occurrence using an OBTAIN WITHIN SET USING SORT KEY call. If the USING subparameter is omitted,
an OBTAIN FIRST WITHIN SET call is used.  Easytrieve  uses the USING subparameter to establish the initial
position within the index set. Once this initial position has been established, retrieval of the root record proceeds
until the end of the index set is reached.
[ID 'path-literal ']
Code the optional ID subparameter to establish the identity of retrieved paths. The system-defined field file-
name: PATH-ID is set to the value of 'path-literal'  for the lowest record retrieved in the current path. 'Path-literal'
can be an alphanumeric value of one or two characters. It cannot contain any DBCS data. The default is spaces.
Whenever a key of the tickler file does not correspond to a root record in the database, file-name: PATH-ID is set
to NF (Not Found).
[LIMIT 'number-of-records ']
The optional LIMIT subparameter controls the number of record occurrences to be retrieved. The limit applies
to the specific record in the path. 'Number-of-records'  must be a positive integer. When this subparameter is not
coded, all occurrences of the record are retrieved.
[WHILE (condition )]
Code the optional WHILE subparameter to pre-screen input records. The syntax of the condition is exactly
the same as the conditional expressions described in the Programming Guide . When the associated record is
retrieved from IDMS , the condition is evaluated. Records are accepted for input only if the condition is true.
Format 2 (IMS/DLI)
 987 Easytrieve ® Report Generator 11.6
file-name
File-name  identifies the database being accessed. File-name  is the same as the name coded in JOB INPUT  file-
name  and FILE  file-name  statements.
[KEYFILE tickler-file-name  KEYVALUE key-field-name ]
You can designate the tickler file option by coding both the KEYFILE and the KEYVALUE parameters. Tickler-file-
name  is the name of the file that is sequentially processed to get the keys of the root segments to be retrieved.
Key-field-name  is a data field from tickler-file-name  that contains the keys. The key values are used in the
segment search argument for the root segment.  Easytrieve  issues GU (get unique) calls at the root level for each
key found in tickler-file-name . Automatic input is terminated at end-of-file for tickler-file-name .
The DBCS code system assigned to tickler-file-name must match the DBCS code system of file-name.
[SELECT ( record -name  ...)]
The SELECT parameter identifies which segments ( record-name )  Easytrieve  is to retrieve. Record-name  must
be the same as the segment-name  coded on a RECORD statement. You can identify any number of record-
name s for input; however, the parent of all selected segments must also be selected.
[ID 'path-literal ']
Code the optional ID subparameter to establish the identity of retrieved paths. The system-defined field PATH-
ID is set to the value of 'path-literal'  for the lowest segment retrieved in the current path. PATH-ID is a two-byte
alphabetic field. 'Path-literal'  can be an alphabetic value of one or two bytes. It cannot contain any DBCS data.
The default value for PATH-ID is spaces. When a key of the tickler file does not correspond to a root record in the
database, PATH-ID is set to NF (Not Found).
[LIMIT 'number-of-records ']
The optional LIMIT subparameter controls the number of segment occurrences to be retrieved. The limit applies to
each path. 'Number-of-records'  must be a positive integer. When this subparameter is not coded, all occurrences
of the segment are retrieved.
[SSA 'segment-literal ']
You can code the optional Segment Search Argument (SSA) parameter for the root segment. 'Segment-literal'
is used in the creation of the SSA to qualify segment retrieval. This parameter is not valid when you use a tickler
file. The value supplied with SSA is enclosed within parentheses and concatenated with the segment-name  to
produce the root segment's SSA. 'Segment-literal'  cannot contain any DBCS data.
[WHILE (condition )]
Code the optional WHILE subparameter to pre-screen input segments. The syntax of the condition is exactly
the same as the conditional expressions described in the Programming Guide . When the associated record is
returned by IMS/DLI, the condition is evaluated. Segments are accepted for input only if the condition is true.
ROLLBACK Statement
The ROLLBACK statement in  Easytrieve  causes all uncommitted updates in the current logical unit of work to be rolled
back.
For more information about types of work that are recoverable, see the Programming Guide . Use the COMMIT statement
to commit any pending changes.
This statement has the following format:
ROLLBACK
Example
WRITE PERSNL ADD
...
 988 Easytrieve ® Report Generator 11.6
 IF ...
  ROLLBACK
ELSE
  COMMIT
END-IF
ROW Statement
The ROW statement in  Easytrieve  specifies items (fields or literals) to be displayed or received on a row of a screen.
Multiple items can be coded on each ROW statement. Attributes can be specified for each literal coded on the ROW
statement. Attributes and editing criteria can be specified for each field-name  coded on the ROW statement.
For more information, see the Programming Guide .
This statement has the following format:
 ROW [row-number] +                                                      
 
[+offset-value    ] {field-name   }                                    
[                 ] {             } +                                  
[COL column-number] {'row-literal'}                                    
 
[     {attribute -name  } ]                                              
[ATTR {                } ] +                                            
[     {( attribute -list)} ]                                              
 
 [        {RIGHT} ]                                                      
[JUSTIFY {     } ] +                                                    
[        {LEFT } ]                                                      
 
[FILL {' fill-character '|NULL}] +                                        
 
 [MASK ({[ mask-identifier ] [BWZ] [' mask-literal']|HEX})] +               
[NOMASK                                               ]                 
 
 [        { pattern-name} ]                                               
[PATTERN {            } ] +                                             
[        {' pattern'   } ]                                               
 
[UPPERCASE] +                                                           
 
 [VALUE ( literal [THRU literal] [...])] +                                
 
[        [     { attribute -name  }]     ] ]                             
[ERROR ( [ATTR {                }] +   ] ]                             
[        [     {( attribute -list)}]     ] ]                             
[                                      ] ] ...                         
[        [  {' literal'  [   ] }  ]     ] ]                             
[        [  {           [...] }  ] )   ] ]                             
[        [  { field-name [   ] }  ]     ] ]                            
 
 989 Easytrieve ® Report Generator 11.6
[row-number ]
Row-number  specifies the line on which the item on the screen is displayed. A ROW without a row-number  is
assigned the next row number on the screen. Next is defined as the previous row-number  plus one, not the
highest number used as yet.
A ROW without any fields or literals displays a blank line on the screen at the corresponding row-number.
Row-number cannot exceed the default ROWCOUNT value set in the site options or the value of the
ROWCOUNT parameter specified on the SCREEN statement, if coded.
[+offset-value |COL column-number ] {field-name |'row-literal '}
The +offset-value  or the COL  column-number  parameter allows you to control positioning of an item on the row.
+Offset-value is the number of columns (spaces) preceding a screen item. The default +offset-value is +1
because the space preceding each screen item is reserved for screen attributes. +Offset-value must be a signed
positive integer and can only be used for items other than the first in the row.
Use column-number to explicitly specify the column at which the screen item is displayed.
If you do not code a +offset-value or column-number, the next field-name or 'row-literal' is displayed one column
after the end of the previous field-name or 'row-literal.' If no previous item exists in the row, the item is displayed in
column one.
Field-name can be any defined field in your program.
'Row-literal' can be any text you want to display on the screen.
The sum of the length of all screen items (fields and literals) plus offset-values and column-numbers (if used)
cannot exceed the value of the default LINESIZE set in the site options, or the value of the LINESIZE parameter
on the SCREEN statement, if coded.
[ATTR {attribute-name |attribute-list )}]
ATTR specifies either a declared screen attribute name or one or more attribute keywords. For a list of attributes,
see ATTR Parameter. For more information about declared screen attributes, see DECLARE Statement .
The following attributes are invalid for literals and system-defined read-only fields:
•CURSOR
•NUMERIC
•INVISIBLE
•MUSTFILL
•MUSTENTER
•TRIGGER
•ALARM
They are ignored if used, but  Easytrieve  issues a warning message during compilation.
SENDONLY and ASKIP are assumed for literals and system-defined read-only fields.
[JUSTIFY {RIGHT|LEFT}]
Use the JUSTIFY parameter to specify whether the data in the field is left or right justified when displayed at the
terminal.
[FILL {'fill -character '|NULL}]
Specify FILL to translate trailing blanks into either 'fill-character'  or NULL. 'Fill-character'  must be a one-byte
alphanumeric literal.
Upon receiving data from the screen,  Easytrieve  translates all remaining fill characters to spaces.
You can use the FILL parameter to fill a field with underscores to illustrate the total length of the field. You can fill a
field with NULL on a 3270 display to allow insertion of characters.
Varying length fields with FILL NULL do not have trailing nulls translated to spaces. The first trailing null
terminates the varying length field, and then sets its length.
[MASK ({[mask -identifier ] [BWZ] ['mask -literal ']|HEX})]|[NOMASK]
The optional MASK parameter is used to format the field for display.
If MASK is not coded, the MASK coded on the field's definition is used. Use NOMASK to specify that the field's
default MASK is to be used instead of the field's definition MASK.
 990 Easytrieve ® Report Generator 11.6
Any letter from A to Y can be used as an optional mask-identifier. You can use the letter to identify a new mask
or to retrieve a mask that was previously defined either in the Site Options Table or by a mask parameter on a
previous field definition or ROW usage. If the new mask that you identify does not already exist,  Easytrieve 
retains the mask for future reference. Do not use the same identifier to establish more than one mask.
The BWZ (blank when zero) option suppresses the display of field-name when it contains all zeros. BWZ can be
used by itself or with other options on the MASK parameter.
'Mask-literal' defines an edit mask and must be enclosed within single quotes.
Specify HEX to display the field in double-digit hexadecimal format. You can display fields of up to 50 bytes with
the HEX mask.
When fields are received from the terminal, the mask is used as an editing template also. Special characters in
the MASK are stripped from the data before it is moved into the field data area. For more information, see the
Programming Guide .
NOTE
HEX edit masks are not allowed for VARYING fields.
[PATTERN {pattern-name |'pattern '}]
PATTERN allows you to specify a pattern against which each input character is edited. The pattern can be
specified as a literal or as the name of a declared pattern. See DECLARE Statement  for more information.
The valid pattern characters and their meanings are as follows:
A
Represents a lower-case or an upper-case letter.
B
Represents a single blank.
D
Represents a digit.
E
Represents an empty string.
L
Represents a lower-case letter.
N
Represents an upper-case letter or a national character.
U
Represents an upper-case letter.
X
Represents any character.
"x"
Double quotes surrounding a character or a sequence of characters literally represent the character or
sequence of characters contained within. The x represents any character. To literally represent single or
double quotes, use two sets of quotes within the surrounding set of double quotes ('""""' or '"x""x"', '"''"', or
'"x''x"').
blank
Blanks (unless contained in double quotes) serve as delimiters but are otherwise ignored. They can be
inserted into the pattern to increase readability.
( )
Represents grouping to control the precedence of operators.
or | or ,
Represents a choice (or alternation operator).
 991 Easytrieve ® Report Generator 11.6
(m) or (m..n) or (m..*) or (*) or *
Represents the repetition of the preceding pattern expression. The m and n represent numbers and m
must be less than n. A single number with parentheses indicates the exact number of repetitions. (m..n)
represents a range of repetitions, minimum to maximum. An asterisk in a range, (m..*), represents an
infinite maximum. An asterisk by itself, (*) or *, represents a range from 0 to infinity.
# or /-/
Represents the remove (or toss) operation. This operation applies only to a single character set at a time
and must immediately follow that character set in the pattern. This operation removes the character that
matched the character set from the data.
+
Represents character set addition to form another character set.
-
Represents character set difference to form another character set.
concatenation
Concatenation is implied by proximity. For example, DDDU means 3 digits followed by an upper-case
letter.
The precedence of operators from highest to lowest is:
Grouping:               () " "  
 Set construction:       + - 
Actions:                #   
Repetition:         (n) (m..n) (m..*) (*)   
Concatenation:      proximity   
Choice:             |
The edit pattern is evaluated from left to right (the data from the screen is processed from left to right). Patterns
examine only one character at a time. They do not look ahead and they do not back track. For more information,
see the Programming Guide .
[UPPERCASE]
Specify UPPERCASE to translate the field coming from the terminal to upper case before placing it in the field
data area.
[VALUE (literal  [THRU literal ] [...])]
Use VALUE to specify a value, a series of values, or a range of values (or a combination) that constrain the
values accepted in the field. Values must be specified as literals of the correct type for the field. See Conditional
Expressions  for more information.
[ERROR [ATTR {attribute-name |(attribute-list )}][{'literal '[ ]}|{field-name [ ]}]
ERROR specifies one or more fields or alphanumeric literals to be used as the error message issued by 
Easytrieve  in case of an automatically-detected error condition. The total length of the message text cannot
exceed the current screen size less two or the compiler issues an error message. Optionally, you can specify the
screen attribute to be used for the field in error.
Example
 ROW 5 'N umber'  COL 20 EMP-NUMBER  ATTR PROTECT  MASK 'ZZ9'             
ROW   'N ame'      COL 20 EMP-NAME    UPPERCASE                            
ROW   'D ept'       COL 20  EMP-DEPT    VALUE (900 THRU 999) +               
                                       ERROR 'I nvalid Department '          
 
SCREEN Statement
The SCREEN statement in  Easytrieve  defines and initiates a SCREEN activity.
 992 Easytrieve ® Report Generator 11.6
A SCREEN activity defines a transaction-oriented processing activity under the control of keys pressed by the terminal
operator. Statements can also be inserted in screen procedures to retrieve and maintain files and databases.
NOTE
Screen processing is only available in  Easytrieve  Online.
The structure of a SCREEN activity is as follows:
SCREEN statement
  Screen declaration statements:
    DEFAULTs (first in declaration section)
    KEYs, TITLEs, ROWs (in any order)
  Screen procedures (both special-named and user-defined, in any order)
SCREEN activities can be executed by PROGRAM or other SCREEN activities. If a PROGRAM activity is not present, the
first SCREEN activity detected is automatically executed. A SCREEN activity continues processing until an EXIT, STOP,
or TRANSFER statement is executed.  Easytrieve  issues an error message when compiling a screen activity that does
not contain one of these statements.
If the LINESIZE and ROWCOUNT for a screen are less than the line size and number of rows on the terminal, the screen
is displayed as a pop-up window. Any fields from previous screens that are still displayed are given the ASKIP attribute to
prevent data entry on those screens.
When executing in TSO and CMS, if the terminal supports two presentation sizes,  Easytrieve  selects the presentation
size based on the size of the screen. When a pop-up window is displayed, the presentation space is based on the larger
of the previous display size or the size of the pop-up window.
This statement has the following format:
                           [        [ACTIVITY  ] [TERMINAL  ] ]
 SCREEN [NAME screen-name] [COMMIT ([          ] [          ])] + 
                           [        [NOACTIVITY] [NOTERMINAL] ]
            
       [UPPERCASE] [ROWCOUNT rows] [LINESIZE columns] +
       [ROW screen-start-row] [COL screen-start-column] +
       [                { attribute -name  } ]
       [BACKGROUND ATTR {                } ]  +
       [                {( attribute -list)} ]
 
       [        {SINGLE          }                            ]
       [        {DOUBLE          } [     { attribute -name  } ] ]
       [BORDER ({                } [ATTR {                } ] ] +
       [        {WIDE            } [     {( attribute -list)} ] ]  
       [        {' border literal'}                            ]
 
       [SHADOW]
[NAME screen-name ]
Optionally, specify a name for the SCREEN activity. Screen-name :
 993 Easytrieve ® Report Generator 11.6
•Can be up to 128 characters in length
•Can contain any character other than a delimiter
•Can begin with A to Z, 0 to 9, or a national character (#, @, $)
•Must not consist of all numeric characters
The screen-name can be used to identify the screen in an EXECUTE statement.
[COMMIT [ACTIVITY|NOACTIVITY] [TERMINAL|NOTERMINAL]]
Specify the COMMIT parameter to control the logical unit of work. COMMIT indicates when the activity commits
recoverable work. Each commit point posts all updates, additions and deletions, terminates holds, and closes
SQL cursors.
Specify ACTIVITY to commit all recoverable work during the normal termination of the activity. Specify
NOACTIVITY to tell  Easytrieve  not to commit at the end of the activity. NOACTIVITY is the default.
Specify TERMINAL to commit all recoverable work during any terminal I/O operation. In CICS, this results in
terminal I/O being performed in a pseudo-conversational mode. Specify NOTERMINAL to tell  Easytrieve  not to
commit during a terminal I/O. TERMINAL is the default.
If this activity is executed by an activity that has NOTERMINAL specified, this activity performs terminal I/O as if
NOTERMINAL was specified.
NOTE
You can also issue your own COMMIT and ROLLBACK statements to commit or recover on a controlled
basis.
[UPPERCASE]
Specify UPPERCASE to translate the data received from the terminal to upper case before it is processed. If
UPPERCASE is not specified, the data is processed as the user enters it.
[ROWCOUNT rows ]
ROWCOUNT  rows  lets you override the default number of terminal rows for the screen display. The default is set
in the Site Options Table. For valid ROWCOUNT-LINESIZE combinations, see the next parameter, LINESIZE
columns .
[LINESIZE columns ]
LINESIZE  columns  lets you override the default number of columns for the screen display. The default is set in the
Site Options Table.
On the mainframe, ROWCOUNT can be any value from 1 to 255. LINESIZE can be any value from 1 to 255. If the
dimensions of the screen exceed the screen size available on the display terminal, only a portion of the screen is
displayed.
[ROW screen-start-row ] [COL screen-start-column ]
Screen-start-row  specifies the starting row of the screen. The default is 1.
Screen-start-column specifies the starting column of the screen. The default is 1.
[BORDER {SINGLE|DOUBLE|WIDE|' border  literal'} [ATTR {attribute -name |(attribute -list )} ] ]
Use BORDER to specify that the screen has a border.
SINGLE, DOUBLE, or WIDE specifies that the border is built from a predefined line-drawing character set.
Borders on the mainframe are:
 994 Easytrieve ® Report Generator 11.6
'Border literal' specifies the character to be used for the screen border. This value must be a single character enclosed in
single quotes.
Optionally, specify a declared screen attribute name or a list of attribute keywords for the screen border. The following
attributes are ignored for BORDER:
•CURSOR
•NUMERIC
•INVISIBLE
•MUSTFILL
•MUSTENTER
•TRIGGER
•ALARM
For a list of attribute keywords, see ATTR Parameter . For more information about declared screen attributes, see the
DECLARE Statement  .
Example
 DEFINE WS-REPLY  W 1 A
 SCREEN NAME MAIN-MENU
   TITLE 'Employee File Main Menu'
   ROW  6 COL 10 'Type an option, then press Enter.'
   ROW  8 COL 10 'Option ===>' WS-REPLY VALUE ('V' 'E' 'D' 'X') +
                     ERROR 'Please type V, E, D, or X'
   ROW 10 COL 22 'V View employee'
   ROW    COL 22 'E Edit employee'
   ROW    COL 22 'D Delete employee'
   ROW    COL 22 'X Exit'
   KEY F1  NAME 'Help' IMMEDIATE
   KEY F3  NAME 'Exit' EXIT
   KEY F12 NAME 'Cancel' EXIT IMMEDIATE
SEARCH Statement
The SEARCH statement in  Easytrieve  provides access to table information.
Special conditions of the IF statement can be used to validate the results of SEARCH operations.
After each SEARCH statement, you can code an IF  file-name  test to determine the success of the table search. When
the search is successful (IF  file-name  is true), result-field  contains the table's descriptive data corresponding to the
search argument of search-field . When the search is unsuccessful (IF  file-name  is false), the contents of result-field  are
unchanged.
You can code SEARCH statements any place in a PROGRAM, SCREEN, or JOB activity, and issue any number of
searches against any number of tables.
The file must be in ARG sequence and cannot contain any duplicates. The compare between the WITH field and the ARG
field in the table is a logical compare, that is, the compare ignores the data type and treats both fields as if they have a
data type of A.
When the table file is also an INDEXED file and the ARG field is the key,  Easytrieve  performs a keyed read of the file.
Otherwise, the entire file is read into memory and a binary search is performed. For more information on table processing,
see the Programming Guide .
 995 Easytrieve ® Report Generator 11.6
This statement has the following format:
SEARCH file-name  WITH search-field  GIVING result-field 
file-name
File-name  is the name of the file that describes the table and its source. The file must have the TABLE parameter
on its FILE statement and must be a fixed length.
WITH search-field
Search-field  identifies the field containing the search argument for the binary search. This parameter is defined in
any file, except for files with the TABLE parameter, or it can be defined in working storage.
The length and field type of search-field must match the length and field type of the ARG field defined for file-
name. Search-field cannot be a varying length field or a nullable field.
GIVING result-field
Result-field  identifies the receiving field for the results of the table search. This parameter is defined in any file,
except for files with the TABLE parameter or it can be defined in working storage.
The length and field type of result-field must match the length and field type of the DESC field defined for file-
name. Result-field cannot be a varying length field or a nullable field.
Example
The following example illustrates the retrieval of high school class descriptions based upon class identification codes.
Statements:
DEFINE CODE          W   4 A                                            
DEFINE DESCRIPTION   W  40 A                                            
FILE CLASSES TABLE INSTREAM                                             
ARG   1  4 A                                                            
DESC 10 40 A                                                            
1011     ENGLISH I                                                      
1012     ENGLISH II                                                     
1013     ENGLISH III                                                    
1014     ENGLISH IV                                                     
ENDTABLE                                                                
PROGRAM NAME MYPROG                                                     
  MOVE '1012' TO CODE                                                     SEARCH CLASSES WITH CODE, GIVING
 DESCRIPTION                        
  IF CLASSES                                                            
    DISPLAY DESCRIPTION                                                 
  ELSE                                                                  
    DISPLAY 'CLASS NOT FOUND'                                           
  END-IF                                                               
Results:
 ENGLISH II                                                            
SELECT Statement (File-based SQL)
The SELECT statement issued for an SQL file causes a cursor to be automatically declared and opened as an  Easytrieve
file.
 996 Easytrieve ® Report Generator 11.6
The resulting cursor can then be fetched and updated by subsequent commands for the file. The cursor can also be the
subject of automatic input using the JOB statement.
NOTE
•If no SELECT statement is issued for an SQL file, a default SELECT is used (SELECT all defined columns
FROM file-name).
•If SELECT is the first statement in a JOB activity, the following happens:
–If the SELECT is for an automatic input file, the SELECT overrides the default SELECT.
–If the SELECT is for a file not used for automatic input, a DEFER should be coded on the SQL FILE
statement. If DEFER is not coded, the default SELECT is opened during the initialization processing, then
closed, and the coded SELECT processed. This causes unnecessary processing to occur.
•If a SELECT is specified for a file that has already been opened, either by the default SELECT or another
coded SELECT, then the existing SELECT for the file is closed and the new SELECT is used to open the file
again.
SELECT can be coded in a JOB's START procedure. However, since a file is normally opened before invoking the START
procedure, you should specify DEFER on the FILE statement. Otherwise, the default SELECT is opened before the
START procedure, and then the SELECT in the START procedure closes the default SELECT before it opens. This
causes extra processing that is not needed.
This statement has the following format:
SELECT [DISTINCT] [FROM] file-name +                                    
                                                                        
 [WHERE search-condition ] +                                             
                                                                        
 [GROUP BY column-name        + ] +                                     
 [         [, column-name ...]  ]                                       
                                                                        
 [HAVING search-condition ] +                                            
                                                                        
[         { column-name} [ASC ]         ]                               
[ORDER BY {           } [    ] +       ]                               
[         { integer    } [DESC]         ]                               
[                                      ]                               
[         [  { column-name} [ASC ]    ] ]                               
[         [, {           } [    ] ...] ] +                             
 [         [  { integer    } [DESC]    ] ]                               
                                                                        
 [FOR UPDATE]                                                          
[DISTINCT]
DISTINCT eliminates duplicate rows. If DISTINCT is not specified, all rows are retrieved.
[FROM] file -name
Optionally, code FROM for statement readability.
file-name  must be the name of an  Easytrieve  SQL file.
[WHERE search-condition ]
Search-condition  is used to specify conditions for the retrieval of data. The search-condition  is applied to create
the result set for the file. For information about the search-condition , see your SQL vendor manuals.
[GROUP BY column -name ]
GROUP BY is used to group data that is fetched into the file. For column-name  syntax, see your SQL vendor
manuals.
 997 Easytrieve ® Report Generator 11.6
[HAVING search-condition ]
Search-condition  is used to specify the data to be provided to the user. HAVING can be used to compare the
results of all the returned data with a specific value in the data provided (such as the minimum or maximum
value). For information about the search-condition , see your SQL vendor manuals.
[ORDER BY { column -name |integer } [ASC|DESC]]
ORDER BY returns the rows of the result table in the order of the values of the specified column-names . Integer
references a column by its position in the result table rather than by a column-name . ASC returns the rows in
ascending order and is the default. DESC returns the rows in descending order.
[FOR UPDATE]
Specify FOR UPDATE to allow updates of the updatable fields defined in file-name . If used, FOR UPDATE must
be the last parameter specified on the SELECT statement. If FOR UPDATE is not coded and you attempt to
update file-name , you receive an error at execution.
Examples
The following code block is a file-based SQL SELECT statement example:
FILE PERSNL SQL (PERSONNEL)
 EMPNAME       *   20  A
WORKDEPT      *   2   P    0
JOB NAME RETRIEVE-PERSONNEL INPUT PERSNL   SELECT FROM PERSNL WHERE WORKDEPT = 921
  DISPLAY EMPNAME +2 WORKDEPT
The next example shows a file-based SQL SELECT statement with DEFER:
FILE PERSNL SQL (PERSONNEL) DEFER
EMPNAME       *   20  A
WORKDEPT      *   2   P    0
JOB NAME RETRIEVE-PERSONNEL INPUT PERSNL START START-PROC
  DISPLAY EMPNAME +2 WORKDEPT
START-PROC. PROC   SELECT FROM PERSNL WHERE WORKDEPT = 921
END-PROC
SELECT Statement (Non-file SQL)
The non-file SQL SELECT statement allows  Easytrieve  to retrieve rows without a file.
This read-only method is retained from previous versions of  Easytrieve .
The SELECT statement identifies the rows and columns that are to be input to the JOB activity. Only one SELECT
statement can be coded in each JOB activity, and it must be coded as the first statement in the JOB activity.
Code the SELECT statement immediately following the JOB INPUT SQL statement.
If this execution is for an SQL/DS system, a CONNECT statement is generated and executed by  Easytrieve . This means
that the user does not need to include an SQL CONNECT statement when using  Easytrieve  automatic processing. The
user ID and password parameters are those that were specified in the USERID parameter of the PARM statement.
Easytrieve  checks the SQLCODE field following each execution of the select-clause. If the SQLCODE indicates an error, 
Easytrieve  issues an error message based on the SQL error and terminates execution. An SQLCODE value indicating
end of data causes  Easytrieve  to initiate end of input processing: the FINISH PROC (if any) executes, spooled reports
are printed, and the current JOB activity ends. For a description of SQL codes, see your SQL vendor manuals.
The SQL cursor that is automatically defined by a SELECT statement is closed following the JOB activity referencing it.
 998 Easytrieve ® Report Generator 11.6
This statement has the following format:
                   { {*                 }                               
        [DISTINCT] { { expression         }                               
SELECT  [        ] { {                  } +                             
        [ALL     ] { { table-name.*      }                               
                   { { correlation -name.*}                               
                                                                        
                                                 }                       
                   [  { expression         }     ] }                       
                   [, { table-name.*      } . ..] } +                     
                   [  { correlation -name.*}     ] }                       
                                                 }                       
                                                                        
 FROM table-name [correlation -name] +                                   
      [, table-name [correlation -name] ...] +                            
                                                                        
  [WHERE search-condition ] +                                            
                                                                        
  [GROUP BY column-name        + ] +                                    
  [         [, column-name ...]  ]                                      
                                                                        
  [HAVING search-condition ] +                                           
                                                                        
                                                                        
   [                          { {*                 }          ]          
   [             [DISTINCT]   { { expression         }          ]          
   [UNION SELECT [        ]   { {                  } +        ]          
   [             [ALL     ]   { { table-name.*      }          ]        
   [                          { { correlation -name.*}          ]          
   [                                                          ]          
   [                                                      }   ]          
   [                        [  { expression         }    ]  }   ]          
   [                        [, { table-name.*      } ...]  } + ]          
   [                        [  { correlation -name.*}    ]  }   ]          
   [                                                      }   ]          
   [                                                          ]          
   [ FROM table-name [correlation -name] +                     ]          
   [      [, table-name [correlation -name] ...] +              ] +        
   [                                                          ]          
   [  [WHERE search-condition ] +                              ]          
   [                                                          ]          
   [  [GROUP BY column-name        + ] +                      ]          
   [  [         [, column-name ...]  ]                        ]          
   [                                                          ]          
   [  [HAVING search-condition ]                               ] 
                                                                                
   [         { column-name} [ASC ]          ]                            
   [ORDER BY {           } [    ] +        ]                             
   [         { integer    } [DESC]          ]                             
   [                                       ]                             
   [         [  { column-name} [ASC ]    ]  ]                             
 999 Easytrieve ® Report Generator 11.6
   [         [, {           } [    ] ...]  ] +                           
   [         [  { integer    } [DESC]    ]  ]                             
                                                                        
  INTO : host-variable  [, :host-variable ...]                            
[DISTINCT|ALL]
Specify DISTINCT to eliminate duplicate rows. ALL specifies that duplicate rows are not to be eliminated. ALL is
the default.
{*|expression |table-name .*|correlation-name. *}
These parameters are used to identify the columns to be retrieved from the specified table.
FROM table-name  [correlation-name ]
Table-name specifies the table from which data is to be retrieved. Correlation-name  can be used to specify an
alternate qualifier for the table-name  that immediately precedes it.
[WHERE search-condition]
Search-condition  is used to specify conditions for the retrieval of data. The search-condition  is applied to the result
of the FROM clause. For information about the search-condition , see your SQL vendor manuals.
[GROUP BY column -name ]
GROUP BY is used to group data that is fetched into the file. Column-name  must name a column in the file-name .
[HAVING search-condition ]
Search-condition  is used to specify the data to be provided to the user. HAVING can be used to compare the
results of all the returned data with a specific value in the data provided (such as the minimum or maximum
value). For information about the search-condition , see your SQL vendor manuals.
[UNION...]
The UNION clause is used to include rows from another table.
[ORDER BY { column -name |integer } [ASC|DESC]]
ORDER BY returns the rows of the result table in the order of the values of the specified column-names . Integer
references a column by its position in the result table rather than by a column-name . ASC returns the rows in
ascending order and is the default. DESC returns the rows in descending order.
INTO :host-variable [, :host-variable...]
INTO identifies where the column values are to be placed. The INTO clause must be the last clause coded on the
SELECT statement.
Example
The pseudo-code generated for automatic SQL processing is:
* IF SQL/DS                                                             
     SQL CONNECT : user-id IDENTIFIED BY : password                        
* END-IF                                                                
  SQL DECLARE cursor CURSOR FOR select clause                           
  SQL OPEN cursor                                                       
  DO WHILE SQLCODE NE 100                                               
     SQL FETCH cursor INTO :host-variable -1  +                          
                        [, : host-variable -2...]                              process <easy> code             
           
  END-DO                                                                
  SQL CLOSE cursor 
 1000 Easytrieve ® Report Generator 11.6
SELECT Statement (Report Selection)
A SELECT statement in  Easytrieve  can be executed in a REPORT-INPUT procedure to select report input data.
If the REPORT-INPUT procedure is not coded, all records selected with a PRINT statement are used in the report.
SELECT only sets a switch to cause record selection at a later time. If you SELECT a record twice, it appears only once
on the printed report.
If coded, a REPORT-INPUT procedure is performed for each PRINT statement (report input). To cause the data to
continue into report processing, you must execute a SELECT statement for the associated input data. In other words,
input that does not get selected is bypassed for continued processing. See REPORT-INPUT Report Procedure for more
information.
This statement has the following format:
SELECT
Example
REPORT-INPUT. PROC
    IF ZIP NE HOLD-ZIP  
      HOLD-ZIP = ZIP          SELECT
    END-IF  
END-PROC
SELECT Statement (Sort Selection)
Easytrieve  supplies input records to your optional sort procedure one at a time. If a BEFORE procedure is used, a
SELECT statement must be executed for each record that you want to sort.
SELECT only sets a switch to cause record selection at a later time. If you SELECT a record twice, it appears only once
on the sorted file. If you SELECT a record and then issue a STOP, the record is not selected.
This statement has the following format:
SELECT
Example
The following example of a SORT activity shows an output file that contains only a reordered subset of the input file. The
output file contains only those records for which the SELECT statement is executed.
FILE PERSNL FB(150 1800)                                                
%PERSNL                                                                 
FILE SORTWRK FB(150 1800) VIRTUAL                                       
COPY PERSNL                                                             
SORT PERSNL TO SORTWRK USING  +                                         
    (REGION, BRANCH, DEPT,    +                                         
    NAME-LAST, NAME-FIRST)    +                                         
    NAME MYSORT BEFORE SCREENER                                         
*                                                                       
SCREENER. PROC                                                          
 1001 Easytrieve ® Report Generator 11.6
   IF MARITAL-STAT = 'S' AND SEX = 1                                          SELECT                          
                                
   END-IF                                                               
END-PROC                                                               
SEQUENCE Statement
The SEQUENCE statement in  Easytrieve  optionally specifies the order of a report. You can order any report based on
the content of one or more fields.
The fields used to SEQUENCE a report do not have to be part of the printed report.
This statement has the following format:
SEQUENCE field-name [D] ...  
field-name
field-name  identifies a field on which a report is ordered. You can specify multiple field-names  for a report.
field-name  must be in an active file or W-type working storage. Each field must be less than 256 bytes. The fields
specified are used as sort keys processed in major to minor order.
NOTE
Varying length, K, and M fields cannot be specified on a SEQUENCE statement.
[D]
An optional D following a field-name  indicates that the field is sequenced into descending order. If you do not code
D after a field-name , by default the field is sorted in ascending order.
Examples
The following example illustrates using the SEQUENCE statement in a report declaration.
REPORT PERSNL-REPORT   SEQUENCE REGION BRANCH PAY-NET D
  CONTROL REGION BRANCH
  TITLE 'PERSONNEL REPORT'
  LINE REGION BRANCH EMPNAME PAY-NET
SET Statement
The SET statement in  Easytrieve  allows you to dynamically change screen attributes and to control the display of screen
errors.
You can code the SET statement in a screen procedure or in any procedure performed from a screen procedure, except
for SCREEN TERMINATION. If coded in a SCREEN TERMINATION procedure or if coded in a procedure called from a
SCREEN TERMINATION procedure, the SET statement is ignored at execution time.
The SET statement can be executed any number of times before displaying the screen. The last SET statement for field-
name  determines the attributes or messages for that field.
The attributes or error message established by a SET statement remain for only one iteration of the SCREEN activity.
After the SCREEN is displayed, the attribute returns to its default as coded on the ROW statement. For changing field
attributes until they are modified further, use a declared attribute. For an example using dynamic screen attributes, see the
Programming Guide .
 1002 Easytrieve ® Report Generator 11.6
When multiple SET statements are coded for multiple field-name s before the next display of a screen, the field-name  that
is physically displayed first on the screen has its message displayed on the screen. All other field-name s have only their
attributes displayed.
The SET statement overrides any ACTION messages defined in the MESSAGE statement, even if the MESSAGE
statement is executed after all SET statements.
The attributes and messages specified on the SET statement are evaluated when the statement is executed. If the
attributes or messages are variable, the value is saved and bound to the field-name  when the SET statement is executed.
If the variables are later modified, the attributes or messages are not changed when the screen is redisplayed.
If you code SET  field-name ERROR without any other parameters, the attributes and messages for field-name  are
determined by the ROW statement. If the attributes and messages on the ROW statement are variable, the values
displayed for the SET statement are the same as the values determined when the ROW statement is evaluated.
When you execute a RESHOW, REFRESH, or GOTO SCREEN statement after a SET statement, the attributes or
messages specified in the SET statement are not affected.
This statement has the following format:
Format 1
SET field-name ERROR  +                                                 
                                                                        
  [ [     { attribute -name  } ] [ {' literal'  [   ] } ] ]                
  [ [ATTR {                } ] [ {           [...] } ] ]                
  [ [     {( attribute -list)} ] [ { field-name [   ] } ] ]               
Format 2
                    { attribute -name  }                                  
SET field-name ATTR {                }                                  
                    {( attribute -list)}                                 
field-name
Field-name  specifies a field on a ROW statement in your screen declaration. Field-name  can be indexed or
subscripted. If the index or subscript of field-name  is evaluated and is not on the screen, the SET statement is
ignored.
ERROR
Use ERROR to indicate that you want to flag field-name  as being in error and to specify attributes or messages
for field-name .
When you specify ERROR, the attributes or messages for field-name are determined by the hierarchy in the
following table. The priority is from highest to lowest.
Statement/ Area Attributes Message
1. SET statement ATTR parameter literal  or field-name  parameter(s)
2. ROW statement ERROR ATTR parameter ERROR  'literal'  or field-name  parameter(s)
3. DEFAULT statement FIELD ERROR ATTR parameter Default system message:
Value entered is not allowed. Type an
acceptable value.
4. Site Options Table FIELD ERROR ATTR parameter Default system message: Value entered is
not allowed. Type an acceptable value.
 1003 Easytrieve ® Report Generator 11.6
NOTE
If you code SET ERROR without the ATTR, 'literal' or field-name parameters, the attributes and messages are
determined by the next statement or area in the above hierarchy.
[ATTR {attribute-name |(attribute-list )}]
ATTR specifies either a declared screen attribute name or one or more attribute keywords. For a list of attributes,
see ATTR Parameter. For more information about declared screen attributes, see DECLARE Statement .
The following attributes are invalid for literals and system-defined read-only fields:
•ALARM
•CURSOR
•INVISIBLE
•MUSTENTER
•MUSTFILL
•NUMERIC
•TRIGGER
If you use these attributes, they are ignored, but  Easytrieve  Online issues a warning message during
compilation.
SENDONLY and ASKIP are assumed for literals and system-defined read-only fields.
{'literal '|field-name }
Use 'literal' to define the text you want displayed in the message. Use field-name to specify a field whose contents
you want displayed as part of the message. A message can consist of a combination of literals and field-names.
The maximum length of a message is 130 characters. If the message exceeds the message area for the screen
on which it is displayed, the message is truncated.
Examples
In the following example, when the department number is not found in the table, the field is flagged in error:
ROW DEPT ERROR 'Department in error'
...
 AFTER-SCREEN. PROC
  SEARCH DEPTBL WITH DEPT GIVING DEPT-DESC
  IF NOT DEPTBL     SET DEPT ERROR
  END-IF
END-PROC
In the next example, when a user types a value greater than 50,000 into PAY-GROSS, PAY-GROSS is displayed in
yellow; otherwise PAY-GROSS is displayed in turquoise.
ROW PAY-GROSS
...
 AFTER-SCREEN. PROC
  IF PAY-GROSS > 50,000     SET PAY-GROSS ATTR (YELLOW)
  ELSE                      SET PAY-GROSS ATTR (TURQ)
  END-IF
END-PROC
In this example, five rows are displayed when the screen is displayed. Row 1 is displayed in blue and the cursor is
positioned in AFIELD. Rows 2 to 5 are displayed in yellow.
 1004 Easytrieve ® Report Generator 11.6
REPEAT 5 TIMES VARYING SUB1 FROM 1
  ROW AFIELD(SUB1) ATTR (YELLOW)
 END-REPEAT
...
 BEFORE-SCREEN. PROC   SET AFIELD(1) ATTR (BLUE CURSOR)
 END-PROC
SKIP Statement
The SKIP Statement in  Easytrieve  is a listing control statement that spaces the printer a designated number of lines
before printing the next line of the statement listing.
You can code a SKIP statement anywhere in  Easytrieve  source code. SKIP must be on a record by itself. SKIP does not
appear in the printed output. However, the requested blank line appears.
This statement has the following format:
SKIP skip-amount 
skip-amount
Skip-amount  must be an unsigned integer.
SORT Statement
The SORT statement in  Easytrieve  defines and initiates an activity that sorts a file that can be processed sequentially.
SORT sequences an input file in alphabetical or numerical order based on fields specified as keys.
SORT sequences an input file in alphabetical or numerical order based on fields specified as keys.
Easytrieve  supplies input records to your sort procedure one at a time. If a BEFORE  proc-name  procedure is used:
•You must execute a SELECT  statement for each record that you want returned to the output file.
•A selected record is written only once, even if selected more than once in the procedure.
•Any record not selected does not get written to the sorted file.
•If the file being sorted is a variable length record file, the output file is generated with a record length equal to the
maximum record length that is specified in the FILE statement.
SORT activities can be executed by PROGRAM and SCREEN activities. If a PROGRAM activity is not coded, JOB and
SORT activities are automatically executed sequentially until a SCREEN activity is encountered.
For more information about sorting files, see the Programming Guide .
This statement has the following format:
SORT input-file-name TO sorted-file-name +                              
 
  USING ( sort-key-field-name [D] ...) +                                 
 
  [        [ACTIVITY  ] [TERMINAL  ] ]                                  
  [COMMIT ([          ] [          ])]  +                               
  [        [NOACTIVITY] [NOTERMINAL] ]                                  
 
  [SIZE record-count] +                                                 
 
 1005 Easytrieve ® Report Generator 11.6
  [WORK number-of-work-data-sets] +                                     
 
  [BEFORE proc-name] +                                                  
 
  [NAME sort-name]                                                     
input-file-name
input-file-name  is the name of the input file for the SORT activity.
input-file-name  must reference a FILE statement that defines a SEQUENTIAL, INDEXED, RELATIVE, or VFM
file. The record length of input-file-name controls the length of records to be sorted, except when both files are
fixed length. When this occurs, the length of the records is equal to that of input-file-name or sorted-file-name,
whichever is shorter.
TO sorted-file-name
sorted-file-name  designates the name of the output file of the sort activity. Sorted-file-name  must reference a FILE
statement that defines a SEQUENTIAL, INDEXED, RELATIVE, or VFM file.
If sorted-file-name  is the same file name as input-file-name, the sorted output is written over the input file.
USING (sort -key-field -name  [D] ...)
USING  (sort-key-field-name)  specifies key fields for sorting input-file-name .
You can code any number of fields up to the input limit of your installation's sort program. sort-key-field-name  can
be any field less than 256 bytes long in the sort input file. (The only exceptions are variable length fields, which
cannot be used as keys.) sort-key-field-name  cannot be a nullable field.
Code D to sort output in descending order. The default is ascending order.
NOTE
Varying length, K, and M fields cannot be specified as sort keys.
[COMMIT [ACTIVITY|NOACTIVITY] [TERMINAL|NOTERMINAL]]
Specify the COMMIT parameter to control the logical unit of work. COMMIT indicates when the activity commits
recoverable work. Each commit point posts all updates, additions, and deletions, and terminates holds. SQL
cursors may or may not be closed, depending on the underlying database and the cursor definition.
Specify ACTIVITY to commit all recoverable work during the normal termination of the activity. Specify
NOACTIVITY to tell  Easytrieve  not to commit at the end of the activity. NOACTIVITY is the default.
Specify TERMINAL to commit all recoverable work during any terminal I/O operation. In CICS, this results in
terminal I/O being performed in a pseudo-conversational mode. Specify NOTERMINAL to tell  Easytrieve  not to
commit during a terminal I/O. TERMINAL is the default.
If this activity is executed by an activity that has NOTERMINAL specified, this activity performs terminal I/O as if
NOTERMINAL was specified.
For more information, see the Programming Guide .
[SIZE record-count ]
Because  Easytrieve  knows the number of records in files created by previous activities, it automatically supplies
that information to the sort program. If the file was not created by a previous activity, you can enhance sort
efficiency by supplying the approximate number of records as record-count  on the optional SIZE parameter.
Record-count  must be an unsigned integer.
[WORK number-of-work-data-sets ]
Specifies the number of work data sets used by the sort program. Number-of-work-data-sets  must be one of the
following:
•A zero -- to indicate that DD statements are supplied
•A value from 1 to 31 -- to indicate the number of work data sets that the sort program dynamically allocates
This parameter overrides the number of work data sets set in the Site Options Table.
 1006 Easytrieve ® Report Generator 11.6
[BEFORE proc -name ]
Optionally, specify proc-name  to identify your procedure that pre-screens, modifies, and selects input records for
the sort. See SELECT Statement (Sort Selection)  for more information.
If you do not specify BEFORE proc-name,  Easytrieve  sorts all records in input-file-name and writes them to
sorted-file-name.
[NAME sort -name ]
Optionally, specify sort-name  to identify the SORT activity. Sort-name :
•Can be up to 128 characters in length
•Can contain any character other than a delimiter
•Can begin with A to Z, 0 to 9, or a national character (#, @, $)
•Must not consist of all numeric characters
The sort-name can be used to identify the sort in an EXECUTE statement.
Example
In the following example, the output file contains all of the records of the input file sorted into ascending sequence by the
values of fields REGION and BRANCH:
FILE PERSNL FB(150 1800)
 %PERSNL
FILE SORTWRK FB(150 1800) VIRTUAL
COPY PERSNL SORT PERSNL TO SORTWRK USING +      (REGION, BRANCH) NAME MYSORT  
SQL Statement
The SQL statement in  Easytrieve  supports the SQL statements of various database management systems. Review the
SQL statements according you your database management system.
The SQL statement supports the SQL statements of the following database management systems:
•DB2
•SQL/DS
•Datacom/DB  SQL
•IDMS  SQL
•Ingres
•Oracle
•Sybase
•ODBC
This statement has the following format:
SQL native-sql-statement
Usage Notes
For information about the syntax for native database statements, see the specific database management system manual.
Listed below are the SQL statements currently supported by the SQL interface. For more information about coding native
SQL statements, see the Programming section.
DB2 SQL Statements:
 1007 Easytrieve ® Report Generator 11.6
•ALTER
•CLOSE cursor-name
•COMMENT ON
•COMMIT {work}
•CONNECT
•CREATE
•DECLARE cursor-name {with hold}
•DELETE {where current of cursor-name}
•DROP
•EXPLAIN
•FETCH cursor-name
•GRANT
•INSERT
•LABEL
•LOCK
•OPEN cursor-name
•RELEASE
•REVOKE
•ROLLBACK {work}
•SELECT INTO *(for static-only processing)
•SET CONNECTION
•SET CURRENT DEGREE
•SET CURRENT PACKAGESET
•SET CURRENT QUERY ACCELERATION
•SET CURRENT SQLID
•SET host-variable
•UPDATE {where current of cursor-name}
Note: See SQLSYNTAX in PARM Statement for more information.
SQL/DS SQL Statements:
 1008 Easytrieve ® Report Generator 11.6
•ACQUIRE
•ALTER
•CLOSE cursor-name
•COMMENT
•COMMIT {work}
•CONNECT userid
•CONNECT TO database
•CREATE
•DECLARE CURSOR-NAME
•DELETE {where current of cursor-name}
•DROP
•EXPLAIN
•FETCH cursor-name
•GRANT
•INSERT
•LABEL
•LOCK
•OPEN cursor-name
•PUT
•REVOKE
•ROLLBACK {work}
•UPDATE {where current of cursor-name}
Datacom/DB  SQL Statements:
•ALTER
•CLOSE cursor-name
•COMMENT
•COMMIT {work}
•CREATE
•DECLARE cursor-name
•DELETE {where current of cursor-name}
•DROP
•FETCH cursor-name
•GRANT
•INSERT
•LOCK
•OPEN cursor-name
•REVOKE
•ROLLBACK {work}
•SELECT INTO
•UPDATE {where current of cursor-name}
IDMS  SQL Statements:
 1009 Easytrieve ® Report Generator 11.6
•ALTER
•CLOSE cursor-name
•COMMIT {work} {continue} {release}
•CONNECT TO dictionary-name
•CREATE
•DECLARE cursor-name
•DELETE*
•DROP
•EXPLAIN
•FETCH cursor-name
•GRANT
•INSERT
•OPEN cursor-name
•RELEASE
•RESUME
•REVOKE
•ROLLBACK {work}
•SET SESSION CURSOR STABILITY (**)
•SET SESSION READ ONLY (**)
•SET SESSION READ WRITE (**)
•SET SESSION TRANSIENT READ (**)
•SET TRANSACTION CURSOR STABILITY (**)
•SET TRANSACTION READ ONLY (**)
•SET TRANSACTION READ WRITE (**)
•SET TRANSACTION TRANSIENT READ **
•SUSPEND
•UPDATE*
These SET management statements (**) establish SQL characteristics at the SESSION or TRANSACTION level. They
are available with Easytrieve  11.6 New Function mode and Pan/SQL  2.6.
NOTE
WHERE CURRENT OF cursor cannot be dynamically processed by the SQL interface for IDMS . To perform
SQL updates, you must code native SQL statements using a search WHERE clause.
Ingres SQL Statements:
•CLOSE cursor-name
•COMMIT {work}
•CONNECT
•CREATE
•DECLARE cursor-name
•DELETE
•DISCONNECT
•DROP
•FETCH cursor-name
•INSERT
•OPEN cursor-name
•ROLLBACK {work}
•UPDATE
 1010 Easytrieve ® Report Generator 11.6
Oracle SQL Statements:
•CLOSE cursor-name
•COMMIT {work}
•CONNECT
•CREATE
•DECLARE cursor-name
•DELETE
•DISCONNECT
•DROP
•FETCH cursor-name
•INSERT
•OPEN cursor-name
•ROLLBACK {work}
•UPDATE
Sybase SQL Statements:
•CLOSE cursor-name
•COMMIT {work}
•CONNECT
•CREATE
•DECLARE cursor-name
•DELETE
•DISCONNECT
•DROP
•FETCH cursor-name
•INSERT
•OPEN cursor-name
•ROLLBACK {work}
•UPDATE
•USE
ODBC SQL Statements:
•CLOSE cursor-name
•COMMIT {work}
•CONNECT
•CREATE
•DECLARE cursor-name
•DELETE
•DISCONNECT
•DROP
•FETCH cursor-name
•INSERT
•OPEN cursor-name
•ROLLBACK {work}
•UPDATE
•USE
 1011 Easytrieve ® Report Generator 11.6
SQL INCLUDE Statement
The SQL INCLUDE statement in  Easytrieve  indicates that SQL table information is to be used to generate field
definitions.
This statement names the table and gives the location where the field definitions are generated.
This statement has the following format:
SQL INCLUDE +                                                           
 
 [(column ...)] +                                                       
 
 [         { starting -position } ]                                        
 [         {* [+ offset]      } ]                                        
 [LOCATION {                 } ] +                                      
 [         {W                } ]                                        
 [         {S                } ]                                        
 
 [HEADING] +                                                            
 
 [UPDATE] +                                                             
 
 [NULLABLE] +                                                           
 
 FROM [owner.] table 
[(column  ...)]
Specify a list of one or more column names for which field definitions are to be generated. The column name(s)
must be enclosed within parentheses. If no column names are specified, all columns from the table are used.
[LOCATION {starting -position |* [+offset ]|W|S}]
Use this optional parameter to specify the location at which the field definitions are to be generated. This
parameter functions as the starting-location parameter of the DEFINE statement.
Starting-position specifies the starting position relative to position one of the record or file.
The * (asterisk) indicates that the field begins in the next available starting position (highest position assigned so
far, plus 1) within a file. The optional +offset is an offset you want added to the * value. There must be at least one
blank between the * and the optional +offset. Use * when this SQL INCLUDE is used to generate fields within a
FILE.
Coding W or S establishes a working storage field. W fields are spooled to report (work) files; S fields are not. W
is the default location if the LOCATION parameter is not coded.
[HEADING]
Optionally, code HEADING to cause remarks in the DBMS system catalog entry for a column to be copied into a
HEADING parameter on the generated DEFINE statement for the column. This parameter is ignored for Ingres.
[UPDATE]
Code UPDATE to designate a modifiable column.
When an  Easytrieve  SQL file does not contain the UPDATE parameter, only the specific columns defined with
UPDATE can be modified with an UPDATE statement. If UPDATE is coded on the FILE statement, all columns in
the file can be modified.
NOTE
You can use UPDATE only when the field definitions are generated for an  Easytrieve  file.
 1012 Easytrieve ® Report Generator 11.6
[NULLABLE]
Optionally, code NULLABLE to cause default indicator fields to be defined for columns that contain NULL. The
indicator field is defined as a 2 B 0 field preceding the field being defined.  Easytrieve  automatically uses the
default null indicator whenever the associated column is referenced. You can override the use of the default null
indicator by explicitly coding and referencing another indicator variable.
The indicator variable precedes the data portion of the field in storage. This field cannot be directly referenced. To
check this indicator variable, you must use the IF NULL statement.
FROM [owner .] table
FROM identifies the table definition to be defined to  Easytrieve . Owner  is the optional 1- to 18-character
alphanumeric qualifier, and table  is the 1-  to 32-character alphanumeric name. The period must be used as the
qualification separator for owner-qualified tables.
NOTE
If the owner is not specified, the current authorization ID is used.
Usage Notes
When used, the SQL INCLUDE statements must precede any other SQL or SELECT statements and must be coded in
the library definition section of your  Easytrieve  program.
The generated  Easytrieve  field names are the same as the SQL column names. If a name matches a reserved word, the
field definition is allowed, but all references to it must be qualified, using any applicable qualification.
Mask information is not retrieved from the DBMS system catalog.
Group qualification structures of owner.table are defined prior to the first included definition. The fields are defined under
the table entity, which is in turn under the owner level entity. This ensures that multiple tables with duplicate column
names do not produce duplicate field names.
Fields with SQL data types that do not have equivalent  Easytrieve  data types are defined as shown in the following
table. Fields of DATE, TIME, TIMESTAMP, and BINARY cannot be used in arithmetic operations. Fields of FLOAT,
DOUBLEPRECISION, REAL, and LONGINTEGER are defined as packed decimal fields. Non-zero FILE-STATUS and
SQLCODE values are returned if the data is truncated.
SQL Data Type Easytrieve  Data Type Length Decimals
DATE Alphanumeric 10
TIME Alphanumeric 8
TIMESTAMP Alphanumeric 26
BINARY Alphanumeric Length of SQL field
FLOAT Packed Numeric 10 3
DOUBLEPRECISION Packed Numeric 10 3
REAL Packed Numeric 10 3
LONGINTEGER Packed Numeric 10 0
The DBMS system catalog must be referenced each time the program is compiled or interpreted. Therefore, to reduce
catalog contention and to improve performance, you should always create link-edited programs.
Field Reference
One of the advantages of using the SQL INCLUDE interface is the ability to reference host-variables (  Easytrieve  fields)
using the group level TABLE definition.
When specifying the INTO clause on a native SQL FETCH or non-file SQL SELECT statement or the VALUES clause
of the native SQL INSERT statement, you can substitute the host variable TABLE definition in place of coding all host-
variables in the table.
 1013 Easytrieve ® Report Generator 11.6
If you require access to an indicator variable other than its use for NULL checking, you must define your own variable and
reference it with its host-variable. For some DBMSs, the indicator variable is examined to detect truncation.
When the host-variable is an  Easytrieve  group level definition of a table name, an array of type 2 B 0 should be specified
immediately following the host-table-name-variable. The number of array elements should match the number of fields in
the  Easytrieve  table name definition. Array elements are matched one-to-one with the fields defined in the table name.
STOP Statement
The STOP statement in  Easytrieve  terminates activities. Review examples of STOP and STOP EXECUTE.
In  Easytrieve , activities with automatic file input automatically terminate when all input records have been processed.
You can terminate activities prematurely, however, with a STOP statement. You must use STOP to terminate JOB
activities without automatic file input (for example, JOB INPUT NULL).
NOTE
Use the EXIT statement to normally terminate SCREEN activities.
When used in a JOB activity, STOP completes all reports and executes a FINISH procedure, if coded. If you code STOP
EXECUTE, all  Easytrieve  activity procedures are immediately terminated. If STOP is coded in the START or FINISH
procedure, the procedure is terminated.
When used in a SORT activity procedure, a STOP terminates the record selection process and executes the sort
program. If you selected a record, the record is not accepted.
When COMMIT ACTIVITY is specified for the activity, a STOP statement causes a COMMIT of all recoverable work. A
STOP EXECUTE causes a ROLLBACK.
This statement has the following format:
STOP [EXECUTE] 
[EXECUTE]
EXECUTE immediately terminates all  Easytrieve  execution and is considered an abnormal termination and
causes recoverable resources to be rolled back, etc.. STOP without EXECUTE terminates the current activity
only. Subsequent activities (if any) are executed normally.
Examples
The following example illustrates STOP in a SORT activity to limit the number of records being sorted. In this example,
only the first 50 records from PERSNL are sorted, because the STOP statement simulates end-of-file on PERSNL.
FILE PERSNL  FB(150 1800)                                               
%PERSNL                                                                 
FILE SORTOUT FB(150 1800) VIRTUAL                                       
COPY PERSNL                                                             
*                                                                       
SORT PERSNL TO SORTOUT  +                                               
    USING (PAY-GROSS D) +                                               
    NAME MYSORT BEFORE SORT1-PROC                                       
*                                                                       
SORT1-PROC. PROC                                                        
    IF PERSNL:RECORD-COUNT GT 50                                        
       STOP                                                           
    ELSE                                                                
 1014 Easytrieve ® Report Generator 11.6
       SELECT                                                           
    END-IF                                                              
END-PROC                                                               
Under certain circumstances, you might want to completely terminate all activities using a STOP EXECUTE statement, as
in the next example:
FILE INVENT  FB(200 3200)                                               
%INVMSTR                                                                
FILE SORTWRK F(200) VIRTUAL                                             
COPY INVENT                                                             
*                                                                       
JOB INPUT INVENT NAME MYPROG1 FINISH FINISH-PROC                        
   PRINT MYREPORT                                                       
*                                                                       
FINISH-PROC. PROC                                                       
   IF RECORD-COUNT = 0                                                  
     DISPLAY 'INPUT FILE NOT AVAILABLE'                                 
     DISPLAY 'HALTING EXECUTION...'                                     
             STOP EXECUTE                                                     
   END-IF                                                               
END-PROC                                                                
*                                                                       
REPORT MYREPORT                                                         
LINE PART-NUMBER PART-DESCRIPTION                                       
*                                                                       
SORT INVENT TO SORTWRK USING +                                          
    (LOCATION-STATE,  +                                                 
     LOCATION-CITY) NAME MYSORT                                         
*                                                                       
JOB INPUT SORTWRK NAME MYPROG2                                          
   PRINT MYREPORT                                                       
*                                                                       
REPORT MYREPORT                                                         
LINE PART-NUMBER LOCATION-CITY LOCATION-STATE                          
NOTE
In 6.4, the STOP statement could be used with EXECUTE parm in the following format:
STOP (EXECUTE)
In 11.6 Easytrieve version, it is necessary that the STOP statement use the EXECUTE parm in the following
format:
STOP EXECUTE
Use to a different format for this statement results in an error message.
SUM Statement
The SUM statement in  Easytrieve  is a report definition statement that specifies the quantitative fields that are totaled for
a control report.
 1015 Easytrieve ® Report Generator 11.6
Normally,  Easytrieve  automatically totals all quantitative fields specified on LINE statements. The SUM statement
overrides this process; only the fields specified on the SUM statement are totaled. The fields specified on a SUM
statement do not have to be specified on a LINE statement. The SUM statement is valid only in a Control Report.
This statement has the following format:
SUM field-name ...
field-name
Field-name  is any quantitative field contained in an active file or W storage. You can specify multiple fields.
TERMINATION Report Procedure
A TERMINATION procedure in  Easytrieve  is invoked at the end of the report. This procedure can be used to print report
footing information, including control totals and distribution information.
You must use an END-PROC statement to delimit a TERMINATION procedure. See PROC Statement  for more
information.
This statement has the following format:
TERMINATION. PROC
Example
The following is an example of report footing:
FILE FILE1                                                              
LAST-NAME  1  5 A                                                       
STATE      6  2 A                                                       
ZIP        8  5 N                                                       
PAY-NET    13 5 N 2                                                     
TOTAL-NET   S 8 N 2                                                     
JOB INPUT FILE1 NAME MYPROG                                             
  TOTAL-NET = TOTAL-NET + PAY-NET                                       
  PRINT REPORT1                                                         
*                                                                       
REPORT REPORT1 LINESIZE 65 +                                            
  SUMMARY  SUMCTL DTLCOPY                                               
  SEQUENCE STATE ZIP LAST-NAME                                          
  CONTROL  STATE NEWPAGE ZIP                                            
  TITLE 'REPORT FOR THE STATE OF' STATE                                 
  LINE 01  LAST-NAME STATE ZIP PAY-NET                                  
*                                                                       
        TERMINATION. PROC                                                     
  DISPLAY TITLE                                                         
  DISPLAY SKIP 5 TOTAL-NET 'IS THE Y-T-D COMPANY NET PAY'               
  DISPLAY SKIP 5 'PLEASE ROUTE THIS REPORT TO CORPORATE OFFICERS'       
END-PROC                                                               
TERMINATION Screen Procedure
A TERMINATION procedure in  Easytrieve  is invoked once during the end of the screen activity.
 1016 Easytrieve ® Report Generator 11.6
The TERMINATION procedure is performed when an EXIT action has been executed either by being assigned to a key or
by being executed in another screen procedure. It is used to perform actions that are to be executed only at the end of the
activity.
If GOTO SCREEN or EXIT is executed in a TERMINATION procedure, the activity is stopped at that point. REFRESH and
RESHOW are invalid in a TERMINATION activity.
You must use an END-PROC statement to delimit a TERMINATION procedure. See PROC Statement  for more
information.
This statement has the following format:
TERMINATION. PROC
TITLE Statement (Reports)
One or more TITLE statements in  Easytrieve  define an optional report title. The TITLE statement defines the title items
and their position on the title line.
Easytrieve  automatically positions the system date and current page count on title line one. This can be overridden by
options on the REPORT statement (NODATE and NOPAGE).
This statement has the following format:
                     {[            ] field-name}                         
                     {[# font-number]           }                         
TITLE [title-number] {[            ] ' literal' } ...                     
                     {+ offset                  }                         
                     {- offset                  }                         
                     {COL column-number        }                        
[title-number ]
Title-number specifies the position of the title line in the title area. Title-number must be from 1 to 99 (default is 1).
You must specify title numbers in ascending order with no duplicates. The title-number  of the first TITLE statement
must be 1 or unspecified.
[#font-number ]
#Font-number  defines a font index. The value of #font-number  identifies a font whose specifications are to be
used for the next display item. You can only specify this option if the report has been associated with an extended
reporting printer. #Font-number  identifies the font number of a font defined for the associated extended reporting
printer. If you do not code the font number, then the next display item uses the default font for the assigned
extended reporting printer.
{field-name }
Field-name  specifies a field in any active file, working storage field, or system-defined field.
{'literal '}
'Literal'  specifies a character string for a title item. It must be either a numeric literal, a hexadecimal literal, or an
alphanumeric literal. Alphanumeric literals must be enclosed in single quotes.
By default, each title line is formatted as a list of title items that are separated by the number of spaces defined by
the SPACE parameter of the REPORT statement. The +, -, and COL parameters modify this positioning.
NOTE
You must code at least one title item, specified by field-name or 'literal', on each TITLE statement.
 1017 Easytrieve ® Report Generator 11.6
{+offset |-offset }
The space adjustment parameters, +offset  and -offset , modify the normal spacing between title items. Offset  is
added to or subtracted from the SPACE parameter on the REPORT statement to get the absolute space between
title items. The absolute space value can range from zero to any amount that still allows the title line to fit within
the current LINESIZE value on the REPORT statement.
{COL column-number }
The COL parameter specifies the print column number where the next title item is placed. The value of column-
number  has a valid range of 1 to nnn, where nnn cannot force the following title item beyond the end of the title
line LINESIZE.
Each title line is centered within the title area of the report unless you specify NOADJUST.
When the report is associated with an extended reporting printer, an error results if two or more fields or literals
overlap.
TITLE Statement (Screens)
The TITLE statement in  Easytrieve  is used to automatically center items on a screen.
TITLE items that are not located at a specific column (COL) are centered in the row based on the LINESIZE parameter of
the SCREEN statement.
This statement has the following format:
                   [[COL column-number] {field-name}      
TITLE [row-number] [[                 ] {          }  +   
                   [[+ offset          ] {' literal' }      
                   [     { attribute -name  } ] ]
                   [ATTR {                } ] ]  ...  
                   [     {( attribute -list)} ] ]
[row-number ]
Specify the row-number  on which you want the TITLE to be displayed. If row-number  is not specified, the next
screen row is used for the title. The next screen row is not the highest row used, but the previously-specified row
plus one. If no rows are previously specified, row one is used.
[COL column-number ][+offset ]
Use COL to display a title item at a specific column (column-number) on the screen.
Titles are separated by one space on a screen. Use +offset to add additional spaces between titles.
NOTE
A syntax error occurs when a TITLE overlays another screen item.
{field-name |'literal '}
Specify a field-name  or a 'literal'  for the title. Field-name  is the name of a field to be displayed as a title on the
screen. 'Literal'  is an alphanumeric string to be displayed as a title on the screen.
[ATTR {attribute-name |(attribute-list )}]
Specify a declared screen attribute name or a list of attribute keywords. For a list of attributes, see ATTR
Parameter . For procedures to DECLARE screen attributes, see DECLARE Statement .
NOTE
The following attributes are invalid for TITLEs:
If you use these attributes, they are ignored, but  Easytrieve  issues a warning message during compilation.
SENDONLY and ASKIP are assumed for TITLE items.
Example
 1018 Easytrieve ® Report Generator 11.6
The following TITLE statement:
TITLE 1 COL  1 'D ate:' COL 7 SYSDATE 'E mployee Master'   + 
        COL 67 'T ime:' COL 73 SYSTIME
produces:
Date: 12/31/09                  Employee Master               Time: 12:00:00
SYSDATE and SYSTIME are displayed starting in specific columns by using the COL parameter. 'Employee Master' is
automatically centered.
TRANSFER Statement
The TRANSFER statement in  Easytrieve  is used to transfer execution to a target program without returning to the
invoking program.
The TRANSFER statement completely terminates the current Easytrieve  program and invokes the program specified by
program-name or the program field-name  using the linkage conventions of the operating system in which the program
is executing. Issuing a TRANSFER statement is similar to issuing a STOP statement: reports are completed and a JOB
FINISH procedure is executed (if coded).
The screen is automatically cleared when the current program terminates. In CICS, you can request that the screen
remains displayed on the terminal by using the NOCLEAR parameter. In other environments, NOCLEAR is ignored and
the screen is cleared and left in a ready mode.
NOTE
The target program inherits the execution environment of the program issuing the TRANSFER statement.
TRANSFER can be used to invoke any program written in any language that is supported by the operating system in
which the program is executing; similarly, the program can issue any command supported by the operating system.
When the target program is another Easytrieve  program and you want to pass a parameter, you must specify the USING
parameter on the target program's PROGRAM statement.
When transferring to another Easytrieve  program in a CICS pseudo-conversational environment, you must specify the
TRANSID parameter on the PARM statement of the target program.
NOTE
Using the TRANSFER statement in interpretive execution causes the program execution to terminate. For more
information, see the Programming  section.
This statement has the following format:
         { field-name     } [      { field-name } ]
TRANSFER {              } [USING {          } ] [NOCLEAR]
         {' program-name '} [      {' literal' } ]
{field-name |'program-name '}
Specify the field-name that contains the name of the target program, or specify the name of the target program as
a 'literal ' within single quotes. Field-name  cannot be nullable.
[USING {field-name |'literal '}]
Optionally, specify USING to pass a single parameter to the target program.
Specify the name of a field that contains the value to pass to the target program, or specify a ' literal ' to pass to the
target program. Field-name  cannot be nullable.
 1019 Easytrieve ® Report Generator 11.6
[NOCLEAR]
Use NOCLEAR to specify that you do not want to clear the terminal screen when exiting an Easytrieve  program in
CICS.
Example
CASE OPTION
  WHEN 'V'
    NEXT-PGM = 'VIEWCUST'
  WHEN 'E'
    NEXT-PGM = 'EDIT-CUST
  WHEN 'D'
    NEXT-PGM - 'DEL-CUST'
  WHEN 'A'
    NEXT-PGM = 'ADD-CUST'
END-CASE
TRANSFER NEXT-PGM USING EMP#
UPDATE Statement
The UPDATE statement in  Easytrieve  updates a row from an SQL file.
UPDATE issues an UPDATE WHERE CURRENT OF cursor.
When the file is defined with the UPDATE parameter, all defined columns are updated. Otherwise, only the columns that
contain the UPDATE parameter are updated. See SQL INCLUDE Statement>or DEFINE Statement for more information.
NOTE
UPDATE WHERE CURRENT OF cursor cannot be dynamically processed by the SQL interface for IDMS . To
perform SQL updates, you must code native SQL statements using a searched update statement.
This statement has the following format:
 UPDATE file-name 
file-name
File-name  is the name of an  Easytrieve  SQL file.
Example
The following example changes all employees in department 901 to department 921:
 FILE PERSNL SQL PERSONNEL UPDATE
EMPNAME       *   20  A
WORKDEPT      *   2   P   0
EMPPHONE      *   3   P   0
JOB NAME RETRIEVE-PERSONNEL INPUT PERSNL
  SELECT FROM PERSNL WHERE WORKDEPT = 901 FOR UPDATE
  WORKDEPT = 921
   UPDATE PERSNL  
WRITE Statement
WRITE statements in  Easytrieve  are used in the maintenance of SEQUENTIAL, INDEXED, and RELATIVE files (when
allowed by the underlying access method).
 1020 Easytrieve ® Report Generator 11.6
During random processing of these files, WRITE updates and deletes existing records and adds new records. The syntax
of this staement has two formats:
Format 1
                       [UPDATE] [     { input-file-name  }]              
WRITE output-file-name [      ] [FROM {                 }][STATUS]      
                       [ADD   ] [     { input-record-name}]             
Format 2
WRITE output-file-name DELETE [STATUS]                                 
output-file-name
Specify the name of the SEQUENTIAL, INDEXED or RELATIVE file to be updated, added, or deleted. You must
also code UPDATE on the FILE statement for output-file-name .
[UPDATE|ADD|DELETE]
Specify UPDATE, ADD, or DELETE to designate the type of file maintenance activity to be performed. UPDATE is
the default.
For SEQUENTIAL files, only UPDATE is allowed. For RELATIVE files, only UPDATE and DELETE are allowed.
[FROM {input-file-name |input-record-name }]
Specify input-file-name  or input-record-name  to identify an alternative data source for file UPDATE and ADD
operations. FROM is similar to coding a MOVE statement prior to a WRITE statement.
When input-file-name is specified, the current value of output-file-name:RECORD-LENGTH is the length of the
output data. However, if the output file length is greater than the input file or record length, the excess storage is
not initialized. Also, using the FROM parameter does not update the data area of the output file.
[STATUS]
Specify the STATUS parameter whenever the possibility exists for an unsatisfactory completion of the input/output
request.
STATUS checks input/output processing to see if it was performed properly. STATUS causes the file's FILE-
STATUS field to be set with the appropriate return code. Normally, a zero or non-zero test is sufficient.
NOTE
FILE-STATUS is not defined if you do not specify a file type parameter on the FILE statement.
If you do not code STATUS and the operating system returns a non-zero status,  Easytrieve  issues an
appropriate diagnostic message.
Usage Notes
Format 1
Format 1 of the WRITE statement updates an existing record or adds a new record to the file. When updating, which is the
default, the updated record is the current active record for the file.
Format 2
Format 2 of the WRITE statement deletes the current active record for the file.
Example
The following example illustrates the use of WRITE:
FILE PERSNL INDEXED UPDATE                                              
%PERSNL                                                                 
PROGRAM NAME MYPROG                                                     
 1021 Easytrieve ® Report Generator 11.6
   READ PERSNL KEY '05807' STATUS                                       
   IF PERSNL:FILE-STATUS NE 0                                           
     DISPLAY 'FILE-STATUS= ' PERSNL:FILE-STATUS                         
     DISPLAY 'UNSUCCESSFUL READ ON PERSNL FILE'                         
   ELSE                                                                 
     DISPLAY HEX PERSNL                                                 
     MOVE '3125059599' TO TELEPHONE                                     
           WRITE PERSNL UPDATE                                              
     IF PERSNL:FILE-STATUS NE 0                                         
       DISPLAY 'FILE-STATUS= ' PERSNL:FILE-STATUS                       
       DISPLAY 'UNSUCCESSFUL UPDATE ON PERSNL FILE'                     
     END-IF                                                             
           END-IF  
Symbols and Reserved Words
Review a list of symbols and reserved words used with  Easytrieve  Report Generator.
The reserved words are listed in alphabetical order. Associated with each symbol is one or more references. The
references describe the various ways you can use the symbol. An R in the column after the symbol indicates it is
reserved.
Symbol References
Special Symbol Reserved Reference
. Syntax delimiter (period)
Macro parameter concatenation (period)
< Conditional expression
<= Conditional expression
( Syntax delimiter (left parenthesis)
: Syntax delimiter (colon)
+ Assignment
Continuation of statements and words
DISPLAY
LINE
TITLE
& Macro variable prefix
* Assignment
Comment statement
DEFINE
) Syntax delimiter (right parenthesis)
Ø< Conditional expression POINT
Ø> Conditional expression
Ø= Conditional expression
 1022