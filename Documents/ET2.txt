Easytrieve® Report Generator 11.6
Language Reference
Review information in this section about Easytrieve character sets, statements, symbols and reserved words, and
converting from older versions to the current version of Easytrieve .
Documentation Conventions
The following conventions are used throughout this section for illustrative purposes:
Notation Meaning
{braces} Mandatory choice of one of these entries.
[brackets] Optional entry or choice of one of these entries.
| (OR bar) Choice of one of these entries.
(parentheses) Multiple parameters must be enclosed in parentheses.
... Ellipses indicate that you can code the immediately preceding
parameters multiple times.
BOLD Bold text in program code is used to highlight an example of the
use of a statement.
CAPS All capital letters indicate an Easytrieve keyword, or within text
descriptions, indicate a name or field used in a program example.
lowercase italics Lowercase italics represent variable information in statement
syntax.
Syntax Rules
The free form English language structure of Easytrieve makes it easy for you to develop an efficient, flexible
programming style. To avoid programming errors, follow the simple syntax rules that are described for each statement in
this section.
Character Sets
Review details about how Easytrieve supports both single-byte character sets (SBCS) and double byte character sets
(DBCS) or a mix (MIXED format).
MIXED format is data that contains both SBCS and DBCS formatted data. SBCS data is limited to either EBCDIC or
ASCII depending on the platform. DBCS data is supported only in z/OS.
NOTE
Report processing is limited to EBCDIC and ASCII data format for standard reports and to any data format for
extended reports. Identifiers (for example, field names or labels) can contain DBCS and MIXED data as part of
the name. MIXED data format is supported only when such data is allowed. The product provides no additional
formatting based on the alignment of the DBCS portion of the data. DBCS data is not supported in the UNIX or
Windows environments.
EBCDIC and DBCS
Both EBCDIC and DBCS data processing are applicable to China (Hanzi characters), Japan (Kanji, Hiragana, and
Katakana characters), and Korea (Haja and Hangual characters). Easytrieve supports both character sets, based on the
following assumptions and rules:
829
Easytrieve® Report Generator 11.6
• All the syntax rules that are described in the Statement Overview section apply to EBCDIC data only. DBCS data in the
program statement area is not processed for such things as continuation characters, delimiters, words, and identifiers.
• Unless otherwise noted, source statements are expected to contain character data. Hexadecimal codes that are
embedded into statements are not supported as they may cause problems reading and printing the source program.
• A DBCS character occupies 2 bytes in storage. If not identified as DBCS characters, these same 2 bytes would be
processed as a pair of single-byte EBCDIC characters. To distinguish EBCDIC data from DBCS data, Easytrieve
uses a shift code system. This system, called the wrapping shift code system, takes the form of two codes -- one code
preceding and the second following the DBCS data. These codes wrap or enclose the DBCS data, thereby identifying
the beginning and end of DBCS data. The term that is associated with the code that precedes the DBCS data is a shift-
out code (shift-out of EBCDIC). The code that delimits (separates) the DBCS data is called a shift-in code (shift-in to
EBCDIC). These codes can be one or two bytes in length.
The following diagram illustrates the use of the wrapping shift code system:
• A shift code is a special one or two-byte character that is contained in the program statement area. Shift code values
are defined in the DBCS Options module. For more information about the Options module, see the Using section. Each
shift code value uniquely identifies the DBCS code system of the data. If the system cannot be uniquely identified, a
default is assumed. You can alter this default at compile time by using the PARM statement. For more information, see
the PARM Statement.
• In the statement area, shift codes are required to distinguish DBCS data from EBCDIC data. When an Easytrieve word
has been identified, the word is known to be of EBCDIC, DBCS, or MIXED data format. Shift codes are maintained
for MIXED words only. The compiler identifies the statement containing the word and, when necessary, performs the
required processing to remove the shift codes and convert EBCDIC data.
• Once a shift-out code is found in a word, the data that follows is processed as DBCS data if any one of the following
actions occurs:
– The end statement area is reached before the related shift-in code is found.
– The shift-in code is found but it is not on a double byte boundary.
– The shift-out code is found as part of the identified DBCS data.
Statements
Review Easytrieve statements and a summary of the statements categorized by function.
Alphabetical Summary of Statements
The following table describes the statements that you can use in Easytrieve programs.
Statement Description
% (percent) Invoke a macro
* (asterisk) Document comments in a program.
ACCESS Access a macro secured against unauthorized access in Panvalet
or VSAM.
AFTER-BREAK A REPORT procedure invoked following the printing of summary
lines for a control break.
AFTER-LINE A REPORT procedure invoked after printing a detail line on a
report.
AFTER-SCREEN A SCREEN procedure performed after a SCREEN activity
receives data from the terminal.
Assignment Establish a value in a field.
ATTR Use the ATTR parameter to assign screen attributes to a field or
literal.
830
Easytrieve® Report Generator 11.6
BEFORE-BREAK A REPORT procedure invoked before printing the summary lines
for a control break.
BEFORE-LINE A REPORT procedure invoked before printing a detail line on a
report.
BEFORE-SCREEN A SCREEN procedure invoked before a SCREEN activity sends
data to the terminal.
CALL Invoke subprograms written in other programming languages.
CASE Conditionally execute one of several alternative groups of
statements based on the value of a specific field.
CLOSE Close a file.
COMMIT Commit a logical unit of recoverable work.
CONTROL Identify control fields used in a control report.
COPY Duplicate field definitions of a named file.
CURSOR Set the initial position of the screen cursor.
DECLARE Name a set of screen attributes or an input edit pattern, or whether
a program is statically or dynamically linked.
DEFAULT Override system-defined screen attributes and message locations.
DEFINE Specify a data field within a file or within working storage.
DELETE Delete a row from an SQL file.
DISPLAY Format and transfer data to the system output device or to a
named file.
DLI Perform IMS/DLI functions against an IMS/DLI database.
DO UNTIL Control repetitive program logic by evaluating the condition at the
bottom of a group of statements.
DO WHILE Control repetitive program logic by evaluating the condition at the
top of a group of statements.
ELEMENT RECORD Identify the element records that comprise the logical record.
ELSE Identify statements to be executed when IF conditions are false.
See IF.
ELSE-IF Identify a conditional expression to be tested when the previous IF
or ELSE-IF conditional expression is false. See IF.
END-CASE Terminate the body of a CASE statement. See CASE.
END-DO Terminate the body of a loop associated with a DO UNTIL or DO
WHILE statement. See DO UNTIL and DO WHILE.
END-IF Terminate the logic associated with the previous IF statement. See
IF.
ENDPAGE A REPORT procedure used to produce page footing information.
END-PROC Delimit the statements in a procedure. See PROC Statement.
END-REPEAT Terminate the body of a REPEAT statement. See REPEAT.
ENDTABLE Delimit instream data used to create small tables.
EXECUTE Invoke a JOB, SORT, or SCREEN activity from a PROGRAM or
SCREEN activity.
EXIT Terminate a SCREEN activity.
FETCH Retrieve a row from an SQL file.
FILE Describe a file and database references.
831
Easytrieve® Report Generator 11.6
GET Place the next sequential record of the named file into the file's
record buffer.
GOTO Modify the top-to-bottom logic flow of statement execution.
GOTO JOB Branch to the top of the current JOB activity.
GOTO SCREEN Branch to the top of the current SCREEN activity.
HEADING Define an alternative heading for a field on a report.
IDD FILE Identify a non IDMS file in the IDD and build the file and field
definition.
IDD NAME Establish the dictionary entity retrieval environment.
IDD RECORD Identify and define IDMS and non IDMS records.
IDD SUBSCHEMA Identify the subschema and build the file, record, logical record,
element record, and field definitions.
IDD VERSION Set a global override of the Options Table VERFILE, VERREC,
and VERSCHM defaults.
IDMS ACCEPT DBKEY Transfer database keys to program storage.
IDMS ACCEPT PROCEDURE Return information from the Application Program Information Block
(APIB) associated with a database procedure to the program.
IDMS ACCEPT STATISTICS Retrieve the system statistics.
IDMS BIND Sign on the activity with the database management system.
IDMS BIND FILE Give the database management system access to the record in
program storage.
IDMS BIND PROCEDURE Establish communications between a program and a DBA-written
database procedure.
IDMS COMMIT Request the creation of a checkpoint.
IDMS CONNECT Establish a record as a member of a set occurrence.
IDMS DISCONNECT Cancel the relationship between a record and a set occurrence.
IDMS ERASE Make a record or logical record unavailable for further processing
and remove it from all set occurrences in which it participates as a
member.
IDMS FIND Locate a record.
IDMS FINISH Sign off the database management system.
IDMS GET Retrieve current data records.
IDMS IF Test the status of a set.
IDMS KEEP Place a shared or exclusive lock on a record.
IDMS MODIFY Update a record or logical record within the database.
IDMS OBTAIN Locate and then retrieve a record. For database records, see
IDMS FIND and IDMB OBTAIN Statements. For logical records,
see IDMS OBTAIN.
IDMS READY Establish area availability with the database manager.
IDMS RETURN Retrieve the database key for an indexed record without retrieving
the record.
IDMS ROLLBACK Request recovery.
IDMS STORE Place a new record or logical record occurrence into a database.
IF Control the execution of associated statements by testing
conditional expressions.
832
Easytrieve® Report Generator 11.6
INITIATION A SCREEN procedure invoked during the start of a SCREEN
activity.
INSERT Insert a row into an SQL file.
JOB Define and initiate processing activities.
JOB INPUT Identify automatic input to the activity.
JOB INPUT NULL Inhibit automatic input.
JOB INPUT SQL Allow to automatically manage the SQL cursor without a file.
KEY Define valid terminal keys for a screen, specify descriptive text,
and assign functions to terminal keys.
LINE Define the content of a report line.
LINK Transfer control from current program to another named program
and return to current program.
LIST Regulate the printing or suppression of all statements in the
printed output of a program.
LOGICAL-RECORD Identify the logical records available for automatic or controlled
processing of IDMS databases.
MACRO Define the parameters of a macro.
MEND Terminate a macro.
MESSAGE Define message type and text for messages in a SCREEN activity.
MOVE Transfer character strings from one storage location to another.
MOVE LIKE Move contents of fields with identical names from one file or
record to another.
MSTART Begin an instream macro.
NEWPAGE Eject the printer to the top of the next page before printing the next
line of source program on a statement listing.
PARM Override selected general standards for a program that are set in
the Site Options Table.
PERFORM Transfer control to a procedure and return control to next
executable statement in current program.
POINT Establish a position within an INDEXED or RELATIVE file from
which subsequent data is sequentially retrieved.
POP Restore the previous listing control indicators.
PRINT Produce report output.
PROC Initiate an Easytrieve procedure.
PROGRAM Identify and initiate a processing activity that can optionally initiate
JOB, SORT, and SCREEN activities.
PUSH Save the current listing control indicators.
PUT Perform sequential file output.
READ Provide random access to INDEXED and RELATIVE files.
RECORD Identify the IDMS database records available for automatic or
controlled processing.
REFRESH Restore the initial screen image by rebuilding it with the current
values of program fields.
RELEASE Manually release the hold on any record in an INDEXED or
RELATIVE file.
833
Easytrieve® Report Generator 11.6
REPEAT Display arrays on a screen.
REPORT Define the type and characteristics of a report.
REPORT-INPUT A REPORT procedure that selects or modifies report input data.
RESHOW Redisplay a screen image without rebuilding the screen using the
current values of program fields.
RETRIEVE Identify the IDMS or IMS/DLI database records that are input to
the JOB activity.
ROLLBACK Roll back all recoverable work since the last commit-point.
ROW Specify items to be displayed and received on a row of a screen.
SCREEN Define and initiate a SCREEN activity.
SEARCH Provide access to table data.
SELECT (File-based SQL) Cause a cursor to be declared and opened for a SQL file.
SELECT (IDMS) Specify automatic input of logical records from IDMS databases.
SELECT (Non-file SQL) Identify the rows and columns to be input to a JOB activity when
an Easytrieve file is not used.
SELECT (Report Selection) Select report input data.
SELECT (Sort Selection) Select sort input data.
SEQUENCE Specify the order of a report based on the content of one or more
fields.
SET Dynamically change screen attributes and control the display of
screen errors.
SKIP Space the printer a designated number of lines before printing the
next line of a statement listing.
SORT Sequence an input file in alphabetical or numerical order based on
fields specified as keys.
SQL Indicate a valid SQL statement for any of the supported SQL
database management systems.
SQL INCLUDE Indicate SQL table information is used to generate Easytrieve field
definitions.
STOP Terminate activities.
SUM Specify the quantitative fields that are to be totaled for a control
report.
TERMINATION (Reports) A REPORT procedure invoked at the end of a report, commonly
used to print report footing information.
TERMINATION (Screens) A SCREEN procedure invoked once during the end of a SCREEN
activity, used to perform actions that are executed once at the end
of the activity.
TITLE (Reports) Define an optional report title and its position on a title line.
TITLE (Screens) Define and center title items on a screen.
TRANSFER Transfer execution to a program without returning to the invoking
program.
UPDATE Update a row from an SQL file.
WRITE Update and delete existing records or add new records to
INDEXED and RELATIVE files.
834
Easytrieve® Report Generator 11.6
Statements Categorized by Function
The following Easytrieve statements are categorized by function:
Library Definition
• COPY
• DECLARE
• DEFINE
• FILE
• SQL INCLUDE
File Management
• CLOSE
• COMMIT
• DELETE
• DISPLAY
• ENDTABLE
• FETCH
• GET
• INSERT
• JOB
• JOB INPUT NULL
• JOB INPUT SQL
• POINT
• PUT
• READ
• RELEASE
• ROLLBACK
• SELECT (File-based SQL)
• SELECT (Non-file SQL)
• SELECT (Sort selection)
• SORT
• UPDATE
• WRITE
Screen Processing
NOTE
Screen processing commands are supported only with Online versions of the product.
835
Easytrieve® Report Generator 11.6
• AFTER-SCREEN
• BEFORE-SCREEN
• CURSOR
• DEFAULT
• EXIT
• INITIATION
• KEY
• MESSAGE
• REFRESH
• REPEAT
• RESHOW
• ROW
• SCREEN
• SET
• TERMINATION
• TITLE
Report Processing
• AFTER-BREAK
• AFTER-LINE
• BEFORE-BREAK
• BEFORE-LINE
• CONTROL
• ENDPAGE
• HEADING
• LINE
• PRINT
• REPORT
• REPORT-INPUT
• SELECT
• SEQUENCE
• SUM
• TERMINATION
• TITLE
Generalized Programming
• PARM
• PROGRAM
Inter-Program Execution
• CALL
• LINK
• TRANSFER
836
Easytrieve® Report Generator 11.6
Decision and Branching Logic
• CASE
• DO UNTIL
• DO WHILE
• ELSE
• ELSE-IF
• END-DO
• END-IF
• EXECUTE
• GOTO
• GOTO JOB
• GOTO SCREEN
• IF
• PERFORM
• STOP
Listing Control
• * (asterisk)
• LIST
• NEWPAGE
• POP
• PUSH
• SKIP
Assignment and Moves
• Assignment
• MOVE
• MOVE LIKE
Macro Processing
• % (percent)
• ACCESS
• MACRO
• MEND
• MSTART
Native SQL
• SQL
837
Easytrieve® Report Generator 11.6
IDMS Database Processing
• ELEMENT-RECORD
• IDD FILE
• IDD NAME
• IDD RECORD
• IDD SUBSCHEMA
• IDD VERSION
• IDMS ACCEPT DBKEY
• IDMS ACCEPT PROCEDURE
• IDMS ACCEPT STATISTICS
• IDMS BIND
• IDMS BIND FILE
• IDMS BIND PROCEDURE
• IDMS COMMIT
• IDMS CONNECT
• IDMS DISCONNECT
• IDMS ERASE
• IDMS FIND
• IDMS FINISH
• IDMS GET
• IDMS IF
• IDMS KEEP
• IDMS MODIFY
• IDMS OBTAIN
• IDMS READY
• IDMS ROLLBACK
• IDMS STORE
• LOGICAL-RECORD
• RECORD
• RETRIEVE
• SELECT (IDMS)
IMS/DLI Database Processing
• DLI
Statement Overview
Review an overview of Easytrieve statements: Statement Area, Multiple Statements, Comments, Continuations, Words
and Delimiters, Keywords, Multiple Parameters, Field Names, Labels, Identifiers, Arithmetic Operators, Numeric Literals,
Alphanumeric Literals, and Font Numbers.
Statement Area
All source statements are records of 80 characters each. A system installation option establishes a statement area within
the 80 available positions. The default statement area is in columns 1 to 72.
838
Easytrieve® Report Generator 11.6
For example, although positions 1 to 80 are available, ‘SCANCOLS 7, SCANCOLE 72’ establishes the statement area as
positions 7 to 72. This allows for optional data (for example, sequence numbers and program identifiers) to be entered on
the record, but still be ignored by Easytrieve. The complete record is always printed on the statement listing.
7 7 8
1....6 7......................................2 3......0
001000 PRGMNAME
ignored statement area ignored
Multiple Statements
The statement area normally contains a single statement. However, you can enter multiple statements on a single record.
The character string '. ' (period followed by a space) indicates the end of a statement. Another Easytrieve statement
begins at the next available position of the statement area (after the space). For example, the following two statements
are on one record:
COST = FIXED + VARIABLE. PRICE = COST + PROFIT
Comments
When the first non-blank character of a statement is an asterisk (*), the remainder of that record is a comment statement
that is ignored by the Easytrieve compiler. You can use comment statements at any place within a program, except
within a continued statement. A statement containing all blanks is treated as a comment.
To place a comment on the same line as a statement, code a period (.), one or more spaces, an asterisk (*), and then the
comment:
FIELD-NAME W 5 A . * This is a comment
Continuations
The last non-blank character of a statement terminates the statement, unless that character is a - (minus) or a + (plus).
The - indicates that the statement continues at the start of the next statement area. The + indicates that the statement
continues with the first non-blank character in the next statement area. The difference between - and + is important only
when continuing words. Continuation between words is the same for both. The following continued statements produce
identical results:
FIELD-NAME W 6 A +
VALUE 'ABC-
DEF'
----------------------------
FIELD-NAME W 6 A -
VALUE 'ABC+
DEF'
DBCS Data
To continue a statement defining DBCS data, you must delimit the DBCS data. This means a shift-in code must precede
the continuation character and a shift-out code must precede the continuing DBCS data on the next record. The following
example illustrates continuing a DBCS literal:
839
Easytrieve® Report Generator 11.6
FIELD-NAME W 10 K +
VALUE '[DBDBDB] +
[DBDB]'
The [ and ] indicate shift-out and shift-in codes.
Words and Delimiters
One or more words make up each Easytrieve statement. A word can be a keyword, field name, literal, or symbol. All
words begin with a non-blank character. A delimiter or the end of the statement area terminates these words. Delimiters
make statements readable but are not considered part of the attached word. Easytrieve word delimiters are:
Delimiter Description
space The basic delimiter within each statement.
' single quote Encloses literals that are alphanumeric.
. period followed Terminates a statement.
by a space
, comma Used optionally for readability.
() parentheses Encloses multiple parameters and portions of arithmetic
expressions (the left parenthesis acts as a basic delimiter).
: colon Used as a delimiter for file, record, and field qualifications.
= equal sign Used as a delimiter for assignment and comparison statements.
NOTE
At least one space must follow all delimiters except for the '(' (left parenthesis), and the ':' (colon). Additionally,
the equal sign '=' can be coded with or without surrounding spaces.
Examples of the words RECORD-COUNT and NUM with various delimiters:
RECORD-COUNT
FILEONE:RECORD-COUNT
(RECORD-COUNT)
'RECORD-COUNT'
RECORD-COUNT,
RECORD-COUNT.
RECORD-COUNT=10
IF RECORD-COUNT=10
NUM = 20
IF NUM = 20
Keywords
Keywords are words that have specific meaning to Easytrieve . Some keywords are reserved words. You can use non-
reserved keywords in the appropriate context as field names, whereas reserved words cannot be used as field names. For
more information about keywords and reserved words, see Symbols and Reserved Words.
840
Easytrieve® Report Generator 11.6
Multiple Parameters
You must enclose multiple parameters within parentheses to indicate group relationships. If parentheses are not used,
only one parameter is assumed. The following example is an Easytrieve statement with multiple parameters:
CALL PGMNAME USING(FIELDA, FIELDB, FIELDC)
Field Names
Field names are composed of a combination of not more than 128 characters as follows:
• Alphabetic characters, A to Z, lowercase, and uppercase
• Decimal digits 0 through 9
• All special characters, except delimiters
The first character of a field name must be an alphabetic character, a decimal digit, or a national character (#, @, $).
In addition, a field name must contain at least one alphabetic or special character to distinguish the field name from a
number.
All working storage field names must be unique, and so must all field names within a single file. If you use the same field
name in more than one file, or in a file and in working storage, you must qualify the field name with the file name or the
word WORK. A qualified field name consists of the qualifying word followed by a colon and the field name. You can use
any number of spaces, or no spaces, to separate the colon from either the qualifying word or the field name. Field names
can contain DBCS characters.
Assume FLD1 occurs in both working storage and the file FILEA. FLD1 can be qualified in the following ways:
FILEA: FLD1
FILEA:FLD1
FILEA : FLD1
WORK:FLD1
Labels
Labels identify specific PROGRAMs, JOBs, PROCedures, REPORTs, SCREENs, and statements. Labels can be 128
characters long, can contain any character other than a delimiter, and can begin with A to Z, 0 through 9, or a national
character (#, @, $); they cannot consist of all numeric characters. Labels can contain DBCS characters.
Identifiers
Identifiers are words that name things (for example, field names or statement labels) in Easytrieve . Identifiers cannot
contain these delimiters:
• comma {,}
• single quote {'}
• left parenthesis {(}
• right parenthesis {)}
• colon {:}
Arithmetic Operators
Easytrieve arithmetic expressions use the following arithmetic operators:
841
Easytrieve® Report Generator 11.6
• multiplication (*)
• division (/)
• addition (+)
• subtraction (-)
The arithmetic operator must lie between two spaces.
Numeric Literals
Numeric literals can contain 18-numeric digits (characters 0 through 9). You can indicate the algebraic sign of a numeric
literal by attaching a + (plus) or a - (minus) prefix to the numeral. Also, you can use a single decimal point to indicate a
maximum precision of up to 18 decimal positions. The following examples are valid numeric literals:
123
+123
-123.4321
Alphanumeric Literals
Alphanumeric literals are words that are enclosed within single quotes, and can be 254 characters long. For more
information, see Literal and Data Formatting Rules.
Font Numbers
Font numbers are used by extended report processing to identify which font is used to display the field name or literal.
A font number must begin with a pound sign (#) and contain only numeric digits. Font numbers can be specified on the
following statements:
• DEFINE
• DISPLAY
• HEADING
• LINE
• TITLE
% (Macro Invocation) Statement
The macro invocation statement in Easytrieve enables you to invoke a macro. The statement consists of a macro name
preceded by a percent (%) sign. Review the syntax of the macro invocation statement.
NOTE
For more information about defining substitutable parameters in the macro, see MACRO Statement. For more
information about using macros, see the Programming section.
This statement has the following format:
macro-name positional-parameters keyword-parameters
% ...
%macro-name
Specifies a previously stored macro that you want to invoke. Macro names are limited to eight characters.
NOTE
For Panvalet and Endevor libraries the macro name can be from 1 to 10 characters in length.
842
Easytrieve® Report Generator 11.6
positional-parameters
Specifies values of positional parameters in the macro. You must supply positional parameters before any
keyword parameters.
keyword-parameters
Specifies both the keyword and values of keyword parameters in the macro.
* (Comment) Statement
The * (comment) statement in Easytrieve lets you document comments in a program. Review the syntax of a asterisk
(*) comment statement.
When the first non-blank character of a statement is an asterisk (*), the remainder of that record is a comment statement.
You can use comment statements any place within a program, except within a continued statement. A statement
containing all blanks is treated as a comment.
If you code comment statements within a SCREEN declaration and maintain the screen with the Easytrieve Online
Report Generator Screen Painter, all comment statements are moved to the top of the declaration.
This statement has the following format:
comment-text
*
comment-text
Specifies the text that you want to enter as comment in the program.
ACCESS Statement
The ACCESS statement in Easytrieve makes it possible to access a macro secured against unauthorized access in
Panvalet or VSAM.
For both Panvalet and VSAM macro storage access methods, the ACCESS record can appear anywhere in the
Easytrieve program prior to the retrieval of the macro, and remains in effect until the next ACCESS record is
encountered. The ACCESS record must be on a record by itself. Easytrieve does not print the ACCESS record.
This statement has the following format:
Panvalet:
eight byte code
ACCESS ' - '
VSAM:
eight byte password
ACCESS ' - '
'eight-byte code'
Specifies a security access code that applies to an individual Panvalet library member. You must supply the
security access code on an ACCESS record before Easytrieve can retrieve a secured member.
'eight-byte password'
Specifies a VSAM password. VSAM provides the capability of protecting the macro library by using this password.
Before Easytrieve can retrieve a macro from a secured library, you must supply the library password on an
ACCESS record prior to the first macro call.
843
Easytrieve® Report Generator 11.6
AFTER-BREAK Report Procedure
The AFTER-BREAK. PROC produces special annotation on control reports. An AFTER-BREAK procedure in Easytrieve
is invoked following the printing of summary lines for a control break.
The AFTER-BREAK procedure is invoked once for each level of break. For example, assume two control fields are
specified. When the minor field causes a control break, the AFTER-BREAK procedure is invoked only once. When the
major field causes a control break, AFTER-BREAK is invoked twice.
The value of LEVEL (a system-defined field) can be used to determine which control break is being processed. The value
of BREAK-LEVEL (a system-defined field) contains the number of the field causing the control break. TALLY (a system-
defined field) contains the number of records in a particular control group. For examples of LEVEL and BREAK-LEVEL,
see Programming.
NOTE
If NOPRINT is specified on a CONTROL statement, the AFTER-BREAK procedure is still executed.
An AFTER-BREAK procedure must be delimited by an END-PROC statement. For more information, see PROC
Statement.
This procedure has the following format:
AFTER-BREAK. PROC
AFTER-BREAK. PROC
Specifies a REPORT procedure that is invoked following the printing of summary lines for a control break.
Example:
In the following example, the total line for the control field STATE receives special annotation:
Statements:
FILE FILE1
LAST-NAME 1 5 A
STATE 6 2 A
ZIP 8 5 N
PAY-NET 13 5 N 2
JOB INPUT FILE1 NAME MYPROG
PRINT REPORT1
*
REPORT REPORT1 LINESIZE 65 +
SUMMARY SUMCTL DTLCOPY
SEQUENCE STATE ZIP LAST-NAME
CONTROL STATE ZIP
LINE 01 LAST-NAME STATE ZIP PAY-NET
*
AFTER-BREAK. PROC
IF LEVEL EQ 2
DISPLAY 'TOTALS FOR THE STATE OF ' STATE
END-IF
END-PROC
Data:
BROWNIL6007612345
844
Easytrieve® Report Generator 11.6
BROWNIL6007667890
JONESIL6007709876
JONESIL6007754321
SMITHTX7521811111
SMITHTX7521866666
Results:
LAST-NAME STATE ZIP PAY-NET
BROWN IL 60076 802.35
JONES IL 60077 641.97
IL 1444.32
TOTALS FOR THE STATE OF IL
SMITH TX 75218 777.77
TX 777.77
TOTALS FOR THE STATE OF TX
2222.09
AFTER-LINE Report Procedure
The AFTER-LINE. PROC to print a literal string after a detail line on the report. The AFTER-LINE procedure in Easytrieve
should be invoked immediately following the printing of each detail line on a report.
The AFTER-LINE procedure is invoked after each individual line in a line group. The system-defined field LINE-NUMBER
contains the number of the line in the group being processed.
NOTE
When the AFTER-LINE procedure is invoked, the detail line for the report has already been built. You cannot
modify the contents of the detail line with an AFTER-LINE procedure. (To modify the contents of a detail line on
a report, use a REPORT-INPUT or BEFORE-LINE procedure.)
An AFTER-LINE procedure must be delimited by an END-PROC statement. For more information, see PROC Statement.
This statement has the following format:
AFTER-LINE. PROC
Example
The following example shows how an AFTER-LINE procedure can cause information to be printed following a detail line of
a report:
Statements:
FILE FILE1
LAST-NAME 1 5 A
STATE 6 2 A
ZIP 8 5 N
PAY-NET 13 5 N 2
JOB INPUT FILE1 NAME MYPROG
PRINT REPORT1
845
Easytrieve® Report Generator 11.6
*
REPORT REPORT1 LINESIZE 65 +
DTLCTL EVERY
SEQUENCE STATE ZIP LAST-NAME
CONTROL STATE ZIP
LINE 01 LAST-NAME STATE ZIP PAY-NET
*
AFTER-LINE. PROC
IF PAY-NET GE 500
DISPLAY '* EMPLOYEE ' LAST-NAME ' +
EXCEEDED WEEKLY SALARY GOAL *'
END-IF
END-PROC
Data:
BROWNIL6007612345
BROWNIL6007667890
JONESIL6007709876
JONESIL6007754321
SMITHTX7521811111
SMITHTX7521866666
Results:
LAST-NAME STATE ZIP PAY-NET
BROWN IL 60076 678.90
* EMPLOYEE BROWN EXCEEDED WEEKLY SALARY GOAL *
BROWN IL 60076 123.45
IL 60076 802.35
JONES IL 60077 543.21
* EMPLOYEE JONES EXCEEDED WEEKLY SALARY GOAL *
JONES IL 60077 98.76
IL 60077 641.97
IL 1444.32
SMITH TX 75218 666.66
* EMPLOYEE SMITH EXCEEDED WEEKLY SALARY GOAL *
SMITH TX 75218 111.11
TX 75218 777.77
TX 777.77
846
Easytrieve® Report Generator 11.6
2222.09
AFTER-SCREEN Screen Procedure
The AFTER-SCREEN procedure in Easytrieve enables you to perform complex editing and perform I/O after data
entry. Review an example of AFTER-SCREEN. PROC.
An AFTER-SCREEN procedure in Easytrieve is invoked after the screen activity receives data from the terminal. All
branch actions (REFRESH, RESHOW, EXIT, GOTO SCREEN) are valid in the AFTER-SCREEN procedure and in any
procedure performed by the AFTER-SCREEN procedure. The AFTER-SCREEN procedure is not executed if the key
pressed is assigned to execute a branch action with a KEY statement.
An AFTER-SCREEN procedure must be delimited by an END-PROC statement. For more information, see PROC
Statement.
This statement has the following format:
AFTER-SCREEN. PROC
Example
SCREEN NAME SCRN1
KEY F3 NAME 'Exit' EXIT
KEY F8 NAME 'Forward'
. . .
AFTER-SCREEN. PROC
GET PERSNL
IF EOF PERSNL
EXIT
END-IF
END-PROC
Assignment Statement
The assignment statement in Easytrieve establishes a value in a field either from data in another field or literal, or from
an arithmetic or logical expression evaluation.
The assignment statement has a normal assignment format and a logical expression format.
The normal assignment format sets the value of receive-field-name equal to the value of send-field-name, send-literal,
or the arithmetic expression. For complete rules of the assignment statement and rules for converting from EBCDIC to
DBCS, see the Programming section.
The logical expression format sets the value of receive-field-name equal to the result of evaluating a logical expression.
The value of send-field-name is logically acted upon by the value of bit-mask-field-name or bit-mask-literal. The lengths of
all values must be the same and bit-mask-literal must be hexadecimal.
847
Easytrieve® Report Generator 11.6
NOTE
If receive-field-name is nullable, then its indicator is set to zero, indicating NOT NULL. If any operands on the
right-hand side contain nulls, a runtime error occurs.
The normal assignment format is as follows:
send-field-name
[ROUNDED ] {= } { }
receive-field-name send-literal
[INTEGER] [ ] { } { }
arithmetic-expression
[TRUNCATED] {EQ} { }
receive-field-name
Specify the field name to which a value is to be assigned.
INTEGER
Specify INTEGER to ignore the fractional portion of the value being assigned. INTEGER causes only the
numerics to the left of the decimal point to be transferred during the assignment.
ROUNDED or TRUNCATED
Specify ROUNDED or TRUNCATED when the receiving field (receive-field-name) is too small to handle the
fractional result of the assignment. TRUNCATED is the default.
Specify ROUNDED to round off the fractional result of the assignment statement. The least significant digit of the
result (receiving field) has its value increased by one when the most significant digit of the excess decimal digits is
greater than or equal to five. For example, if 10.75 is the value of the sending field and the receiving field has one
decimal place, ROUNDED causes the receiving field to be 10.8.
Specify TRUNCATED to truncate the result of the assignment statement. Low order digits are truncated on the
right as necessary when the result is moved to the receiving field. If INTEGER is used with ROUNDED, the
result is rounded to the nearest integer before the INTEGER function is performed. If INTEGER is used with
TRUNCATED (the default), then only the INTEGER function is performed.
NOTE
INTEGER, ROUNDED, and TRUNCATED are valid only with numeric fields.
"= " or EQ
Use EQ or = to indicate equivalency.
send-field-name or send-literal or arithmetic-expression
Send-field-name names the field that is copied to receive-field-name.
Send-literal contains the literal that is copied to receive-field-name.
Arithmetic-expression contains numeric values separated by arithmetic operators (+, -, *, /). The result of the
arithmetic-expression is placed in receive-field-name.
The logical expression format is as follows:
bit-mask-field-name
{= } {AND} { }
receive-field-name send-field-name
{ } {OR } { }
bit-mask-literal
{EQ} {XOR} { }
receive-field-name
Specifies the field name to which a value is to be assigned.
"= " or EQ
Use EQ or = to indicate equivalency.
send-field-name
send-field-name names the field that is copied to receive-field-name.
848
Easytrieve® Report Generator 11.6
AND or OR or XOR
Specify AND, OR, or XOR:
• AND—Zero bits in bit-mask-field-name or bit-mask-literal are carried forward to send-field-name and the result
is placed in receive-field-name.
• OR—One bits in bit-mask-field-name or bit-mask-literal are carried forward to send-field-name and the result is
placed in receive-field-name.
• XOR—Corresponding bits of bit-mask-field-name or bit-mask-literal, and send-field-name must be opposite
(zero and one) to result in a one bit in receive-field-name.
bit-mask-field-name or bit-mask-literal
Bit-mask-field-name is the name of a field that is logically combined with send-field-name, the result of which is
carried forward to receive-field-name.
Bit-mask-literal is a literal bit mask that is logically combined with send-field-name, the result of which is carried
forward to receive-field-name.
Examples
The following examples of the assignment statement illustrate its various rules. Example 1: The first example
shows assignment format 1 when the receive-field-name is alphanumeric: Format 1 (Normal Assignment)
DEFINE F1A W 4 A
DEFINE F2A1 W 1 A VALUE 'A'
DEFINE F2A2 W 6 A VALUE 'ABCDEF'
DEFINE F2N1 W 2 N VALUE 12
DEFINE F2N2 W 3 P 1 VALUE 1234.5
...
Resulting Value
F1A = F2A1 'A '
F1A = F2A2 'ABCD'
F1A = F2N1 '0012'
F1A = F2N2 '2345'
F1A = X'FF' X'FF404040'
NOTE
For an example using varying length alphanumeric fields, see Programming.
Example 2: This example shows assignment format 1 when the receive-field-name is numeric: Format 1
(Normal Assignment)
DEFINE F1N W 4 N 1
DEFINE F2N1 W 4 N 1 VALUE 1
DEFINE F2N2 W 4 N 1 VALUE 2
DEFINE F2N3 W 4 N 1 VALUE 3
JOB INPUT NULL NAME MYPROG
F1N = F2N1 + F2N2 + F2N3
DISPLAY SKIP 2 +
'F1N = F2N1 + F2N2 + F2N3 = ' F1N
F1N = F2N1 + F2N2 / F2N3
DISPLAY SKIP 2 +
'F1N = F2N1 + F2N2 / F2N3 = ' F1N
F1N = (F2N1 + F2N2) / F2N3
849
Easytrieve® Report Generator 11.6
DISPLAY SKIP 2 +
'F1N = (F2N1 + F2N2) / F2N3 = ' F1N
F1N = ((F2N1 / F2N2) * 100) + .5
DISPLAY SKIP 2 +
'F1N = ((F2N1 / F2N2) * 100) + .5 = ' F1N
STOP
Results:
Resulting
Value
F1N = F2N1 + F2N2 + F2N3 = 6.0
(1 + 2 + 3)
F1N = F2N1 + F2N2 / F2N3 = 1.6
(1 + 2 / 3)
(1 + 0.6666)
F1N = (F2N1 + F2N2) / F2N3 = 1.0
(( 1 + 2) / 3)
(3 / 3)
F1N = ((F2N1 / F2N2) * 100) + .5 = 50.5
(( 1 / 2) * 100) + .5
((0.5 * 100) + .5)
(50 + .5)
Example 3 The following example illustrates the use of the INTEGER, ROUNDED, and TRUNCATED
parameters:
If:
SENDFLD W 5 N 2 VALUE(10.75)
RCVFLD W 5 N 1
Then:
Assignment Statement RCVFLD Result
RCVFLD INTEGER ROUNDED = SENDFLD 11.0
RCVFLD INTEGER TRUNCATED = SENDFLD 10.0
850
Easytrieve® Report Generator 11.6
RCVFLD INTEGER = SENDFLD 10.0
RCVFLD ROUNDED = SENDFLD 10.8
RCVFLD TRUNCATED = SENDFLD 10.7
RCVFLD = SENDFLD 10.7
Format 2 (Logical Expression Evaluation) Statements:
DEFINE F1P W 2 P MASK HEX
DEFINE F2P W 2 P VALUE X'123D'
JOB INPUT NULL NAME MYPROG
F1P = F2P AND X'FFFE'
DISPLAY SKIP 2 +
'F1P = F2P AND X''FFFE'' = ' F1P
F1P = F2P OR X'000F'
DISPLAY SKIP 2 +
'F1P = F2P OR X''000F'' = ' F1P
F1P = F2P XOR X'FFFF'
DISPLAY SKIP 2 +
'F1P = F2P XOR X''FFFF'' = ' F1P
F1P = F2P XOR F2P
DISPLAY SKIP 2 +
'F1P = F2P XOR F2P = ' F1P
STOP
Results:
Resulting
Value
F1P = F2P AND X'FFFE' = 123C
F1P = F2P OR X'000F' = 123F
F1P = F2P XOR X'FFFF' = EDC2
F1P = F2P XOR F2P = 0000
ATTR Parameter
The ATTR parameter in Easytrieve assigns screen attributes to a field or literal. Use the ATTR parameter in DECLARE,
DEFAULT, ROW, and TITLE statements.
You can specify a declared screen attribute name or a list of attribute keywords. You can use the ATTR parameter in the
following statements:
851
Easytrieve® Report Generator 11.6
• DECLARE
• DEFAULT
• ROW
• TITLE
When used in these statements, the ATTR parameter completely overrides any site or screen default attributes. For
information about how to set default screen attributes that override site attributes, see DEFAULT Statement.
The ATTR parameter can be specified without an attribute-name or an attribute-list only on the DECLARE statement. This
lets a named attribute be declared and then assigned later in the program. A runtime error occurs if a named attribute is
used without any attributes assigned to it. The DEFAULT, ROW, and TITLE statements require an attribute-name or an
attribute-list after the ATTR keyword.
This parameter has the following format:
attribute name
ATTR [ - ]
attribute list
[( - )]
attribute-list
[SENDONLY] +
[CURSOR] +
[ASKIP ] +
[PROTECT]
[NUMERIC] +
[INTENSE ] +
[INVISIBLE]
[GREEN ]
[RED ]
[BLUE ]
[TURQ|TURQUOISE] +
[PINK ]
[YELLOW ]
[BLACK ]
[WHITE ]
[MUSTFILL] +
[MUSTENTER] +
[TRIGGER] +
[BLINK ]
[REVERSE ] +
[UNDERLINE]
[ALARM] +
[BOX ]
[LEFT ]
852
Easytrieve® Report Generator 11.6
[RIGHT]
[UNDER]
[OVER ]
attribute-name
Specify a declared screen attribute name. For more information, see DECLARE Statement.
SENDONLY
The SENDONLY parameter specifies that the field is not to be received. The field is ignored if entered.
SENDONLY is implied for literals.
CURSOR
Specify CURSOR to place the cursor on this field when displayed on the terminal. If more than one field contains
the CURSOR attribute, the cursor is placed on the first field that contains CURSOR.
CURSOR is ignored for literals.
Note: The cursor cannot be moved into a field that also contains the ASKIP, PROTECT, or SENDONLY attributes.
[ASKIP ] or [PROTECT]
ASKIP specifies that the field is an auto-skip field. PROTECT specifies that the field is protected and not auto-
skipped. If neither is specified, the field is unprotected.
ASKIP is implied for literals.
[NUMERIC]
NUMERIC specifies that only numeric data can be entered in this screen field. Use NUMERIC for permitting only
numeric data in alphanumeric fields. NUMERIC is implied for all numeric data types, and ignored for literals.
[INTENSE] or [INVISIBLE]
INTENSE specifies that the field displays brightly. INVISIBLE specifies that the field is present on the screen but is
not displayed. INVISIBLE is ignored for literals.
On 3270 extended attribute terminals, INTENSE is ignored if a color attribute is also specified.
[GREEN], [RED], [BLUE], [TURQ|TURQUOISE], [PINK], [YELLOW], or [WHITE]
The value specified is the color of the field or literal when displayed on a screen. If no color is specified, hardware
defaults apply.
[MUSTFILL]
Specify MUSTFILL to require that all spaces have a non-blank character typed into them. MUSTFILL is ignored
for literals and on terminals that do not support a mandatory-fill attribute.
[MUSTENTER]
Specify MUSTENTER to send an error message to the terminal if the field was not changed. MUSTENTER is
ignored for literals and on terminals that do not support a mandatory-enter attribute. MUSTENTER is ignored for
literals.
[TRIGGER]
TRIGGER causes the screen to be received as soon as the terminal operator has modified the field and tries to
move the cursor out of the field. TRIGGER is ignored for literals and on terminals that do not support a trigger
attribute.
[BLINK] or [REVERSE] or [UNDERLINE]
BLINK displays the item blinking. REVERSE displays the item in reverse video. UNDERLINE displays the item
underlined.
[ALARM]
ALARM causes the terminal alarm to sound. ALARM is ignored for literals.
[BOX], [LEFT], [RIGHT], [UNDER], or [OVER]
BOX specifies that field outlining displays a box surrounding the field.
LEFT specifies that field outlining displays a vertical line to the left of a field.
RIGHT specifies that field outlining displays a vertical line to the right of a field.
853
Easytrieve® Report Generator 11.6
UNDER specifies that field outlining displays a horizontal line below a field.
OVER specifies that field outlining displays a horizontal line above a field.
Note: BOX, LEFT, RIGHT, UNDER, and OVER are ignored on terminals that do not support outlining attributes.
BEFORE-BREAK Report Procedure
The BEFORE-BREAK procedure in Easytrieve calculates percentages and average totals. A BEFORE-BREAK
procedure is invoked before printing the summary lines for a control break.
These values must be calculated immediately before printing.
The BEFORE-BREAK procedure is invoked once for each level of break. For example, assume two control fields are
specified. When the minor field causes a control break, the BEFORE-BREAK procedure is invoked only once. When the
major field causes a control break, BEFORE-BREAK is invoked twice.
The value of LEVEL (a system-defined field) can be used to determine which control break is being processed. The value
of BREAK-LEVEL (a system-defined field) contains the number of the field causing the control break. TALLY (a system-
defined field) contains the number of records in a particular control group. For examples of LEVEL and BREAK-LEVEL,
see Programming.
NOTE
If NOPRINT is specified on a CONTROL statement, the BEFORE-BREAK procedure is still executed.
A BEFORE-BREAK procedure must be delimited by an END-PROC statement. For more information, see PROC
Statement.
This statement has the following format:
BEFORE-BREAK. PROC
Example:
Consider the following percentage calculation, paying special attention to when and how PERCENT is calculated:
Statements:
FILE FILE1 FB(80 8000)
LAST-NAME 1 5 A
STATE 6 2 A
ZIP 8 5 N
PAY-NET 13 5 N 2
*
PERCENT W 2 N 2
TOTAL-NET S 8 N 2
*
JOB INPUT FILE1 NAME MYPROG
*
TOTAL-NET = TOTAL-NET + PAY-NET
PRINT REPORT1
*
REPORT REPORT1 LINESIZE 80 +
SUMMARY SUMCTL DTLCOPY
SEQUENCE STATE ZIP LAST-NAME
CONTROL STATE ZIP
LINE 01 LAST-NAME STATE ZIP PAY-NET PERCENT
854
Easytrieve® Report Generator 11.6
* BEFORE-BREAK. PROC PERCENT = PAY-
NET * 100 / TOTAL-NET END-PROC
Data:
BROWNIL6007612345
BROWNIL6007667890
JONESIL6007709876
JONESIL6007754321
SMITHTX7521811111
SMITHTX7521866666
Results:
LAST-NAME STATE ZIP PAY-NET PERCENT
BROWN IL 60076 802.35 36.10
JONES IL 60077 641.97 28.89
IL 1444.32 64.99
SMITH TX 75218 777.77 35.00
TX 777.77 35.00
2222.09 100.00
The BEFORE-BREAK procedure computes the percentage for each control break by multiplying the sum of PAY-NET by
100 and then dividing by TOTAL-NET.
NOTE
TOTAL-NET is a static (S) working storage field summed in the JOB activity processing.
BEFORE-LINE Report Procedure
The BEFORE-LINE procedure in Easytrieve prints a literal string before a detail line on the report or to change the
contents of the detail line before printing.
A BEFORE-LINE procedure in Easytrieve is invoked immediately before the printing of each detail line on a report. The
BEFORE-LINE procedure is invoked before each individual line in a line group. The system-defined field LINE-NUMBER
contains the number of the line in the group being processed.
A BEFORE-LINE procedure must be delimited by an END-PROC statement. For more information, see PROC Statement.
For an example, see the AFTER-LINE Report Procedure.
This statement has the following format:
BEFORE-LINE. PROC
BEFORE-SCREEN Screen Procedure
The BEFORE-SCREEN procedure in Easytrieve performs I/O, initializes screen fields, or sets the cursor position.
A BEFORE-SCREEN procedure is invoked before the screen activity sends the data to the terminal. It precedes building
the screen and the terminal I/O process.
855
Easytrieve® Report Generator 11.6
You typically use a BEFORE-SCREEN procedure to perform I/O, initialize screen fields, or set the cursor position.
GOTO SCREEN, REFRESH, and RESHOW are invalid in the BEFORE-SCREEN procedure, and in any procedure
performed by the BEFORE-SCREEN procedure.
A BEFORE-SCREEN procedure must be delimited by an END-PROC statement. For more information, see the PROC
Statement.
This statement has the following format:
BEFORE-SCREEN. PROC
Example:
SCREEN NAME SCRN1
KEY F3 NAME 'Exit' EXIT
KEY F8 NAME 'Forward'
. . . BEFORE-SCREEN. PROC GET PERSNL IF EOF PERSNL EXIT END-IF END-PROC
CALL Statement
The CALL statement in Easytrieve dynamically or statically invokes subprograms written in other programming
languages.
The program being called can be either statically or dynamically bound with your Easytrieve program. The way that the
called program is bound is determined by the following list, in order:
1. If the program was declared on a DECLARE statement, the STATIC or DYNAMIC keyword on the DECLARE
statement determines how it is bound.
2. If specified, the CALL parameter on the PARM statement supplies the default for all called programs in your
Easytrieve program.
3. The default is determined by the environment. The default on the mainframe and Windows is DYNAMIC. The default
on Unix platforms is STATIC.
COBOL programs cannot be called by Easytrieve programs in the CICS environment. For more information, see the IBM
CICS Programmer's Reference Manual.
Any mainframe program being called in a CICS environment must execute in conversational mode. The task must not be
terminated by a called program.
For more information about subprogram linkage, see Inter-Program Linkage.
This statement has the following format:
field name
[ { - } ]
program name return field
CALL - [USING ( { } ...)] [RETURNS - ]
literal
[ {' ' } ]
program-name
Program-name is the name of the subprogram that you want invoked. It is loaded into storage as part of an
activity initiation.
NOTE
The underscore character (_) is not allowed in the program-name.
856
Easytrieve® Report Generator 11.6
USING {field-name} or USING {'literal'}
USING specifies the parameter list that is passed to the subprogram.
Field-name must identify a system-defined field, a working storage field, or a field defined in an accessible file.
'Literal' can be any alphanumeric literal that is passed to the program.
NOTE
The field-name for the USING parameter includes only the data. It does not include the leading two-byte
length value as in the field-name for the USING parameter used with the PROGRAM statement.
[RETURNS return-field]
RETURNS identifies a numeric field that contains the return code passed back by a called subprogram. If the
program is calling a COBOL subprogram, the return code is the value in the COBOL RETURN-CODE field. If
the program is calling an Assembler subprogram, the return code is the value contained in register 15 on the
mainframe. If you are coding a C subprogram, the return code is the value returned from the function.
Return-field is a numeric Easytrieve field that contains the returned value. The field can be a user-defined field or
you can use the system-defined field, RETURN-CODE, to pass the return code to the operating system.
Examples
The first example shows a CALL statement without parameters; the second shows one with parameters:
CALL ASMPGM
CALL ASMPGM USING ('USERFIL', USERFLD)
CASE and END-CASE Statements
The CASE and END-CASE statements in Easytrieve conditionally execute one of several alternative groups of
statements based on the value of a specific field.
A CASE statement can be nested within a CASE statement. Other conditional execution statements can also be nested
within a CASE statement. A CASE statement can be nested within any other conditional execution statement.
This statement has the following format:
field name
CASE -
compare literal range literal
WHEN - -1 [THRU - -1] [...]
statement
-1
compare literal n range literal n
WHEN - - [THRU - - ] [...]
statement n
-
[OTHERWISE ]
statement n
[ - +1]
END-CASE
The following diagram illustrates CASE statement logic:
857
Easytrieve® Report Generator 11.6
field-name
Field-name specifies a field that contains a value that is compared to the values represented by compare-literal
[THRU range-literal].
Field-name can be a field of any type. If field-name is numeric, it must have zero or no decimal places.
WHEN
You can specify as many WHEN conditions as necessary. At least one WHEN condition is required. You cannot
code statements between CASE and the first WHEN condition. You must supply a unique set of values to be
compared with field-name in each WHEN condition.
compare-literal [THRU range-literal]
Compare-literal is the value to be compared with field-name. You can specify a single literal, a series of literals, or
a range of literals. A range is represented by compare-literal THRU range-literal. A range is satisfied when field-
name is greater than or equal to the lesser of compare-literal and range-literal and is less than or equal to the
greater of compare-literal and range-literal.
When field-name is alphanumeric, compare-literal and range-literal must also be alphanumeric. The comparison
is based on the greater of the length of field-name and compare-literal or range-literal. The shorter field is padded
with spaces to equal the length of the longer field.
When field-name is numeric, compare-literal and range-literal must also be numeric and must not have any
decimal places.
858
Easytrieve® Report Generator 11.6
The set of literal values that are specified for a given WHEN, including the unspecified values that are implied by a
range, must be unique as compared to the literal values of any other WHEN for the same CASE.
statement-1 to statement-n
Statement-1 and statement-n represent any number of Easytrieve statements that are executed when the
WHEN comparison is satisfied. Whenever one or more of these statements is a CASE statement, the CASE
statements are considered to be nested.
OTHERWISE
OTHERWISE is an optional statement that specifies a group of statements to be executed if no WHEN
comparison was satisfied. If OTHERWISE is not specified and field-name does not equal any of the specified
WHEN conditions, execution continues with the statement following END-CASE.
statement-n+1
Statement-n+1 represents any number of Easytrieve statements that are executed when no WHEN comparisons
are equal. Whenever one or more of these statements is a CASE statement, the CASE statements are
considered to be nested.
END-CASE
END-CASE terminates the body of the CASE statement. END-CASE must be specified after each CASE
statement and its associated statements.
Example:
The following example uses CASE to analyze the data to select employees' years of service that fall into a range
(identified by the WHEN statement) and, as a result, display 'ONE WEEK VACATION' or 'TWO WEEKS VACATION', or for
all other cases, display 'THREE WEEKS VACATION'.
FILE EMPLOYEE
EMPYRS 5 2 N
...
CASE EMPYRS
WHEN 0 THRU 4
DISPLAY 'ONE WEEK VACATION'
WHEN 5 THRU 10
DISPLAY 'TWO WEEKS VACATION'
OTHERWISE
DISPLAY 'THREE WEEKS VACATION'END-CASE
...
CLOSE Statement
The CLOSE statement in Easytrieve closes a file.
At the termination of each activity, all files that were opened during the activity are automatically closed. You can use the
CLOSE statement to close the file before the activity terminates. The next I/O statement using the file reopens the file.
You can also close an SQL file with the CLOSE statement so that a new cursor can be created. For more information, see
SQL Database Processing.
Note: You cannot use the CLOSE statement to close a printer file or to close an automatic input or output file. Virtual files
without RETAIN are deleted when closed. CLOSE has no effect on IDMS files.
This statement has the following format:
859
Easytrieve® Report Generator 11.6
file-name
CLOSE
file-name
File-name specifies the file to be closed.
Example
CLOSE FILEA
COMMIT Statement
The COMMIT statement in Easytrieve establishes a logical unit of work.
The COMMIT statement establishes the end of the current logical unit of work and the beginning of the next.
The COMMIT statement establishes a recovery point for updates. The ROLLBACK statement can then be used to recover
any recoverable actions since the last COMMIT. (The operating environment determines which actions are recoverable.
For more information, see Control Program Flow.)
COMMIT terminates any active holds on files. All open SQL cursors are closed and all updates to databases are
committed.
NOTE
Cursors defined with the HOLD option (DB2 only) are not closed.
This statement has the following format:
COMMIT
Example:
WRITE PERSNL ADD
. . .
IF . . . COMMIT
ELSE
ROLLBACK
END-IF
Conditional Expressions
Conditional expressions in Easytrieve are specified through IF and DO statements to offer an alternative to the normal
top-to-bottom execution of statements.
Easytrieve accepts seven different conditions: Field Relational, Field Series, Field Class, Field Bits, File Presence, File
Relational, Record Relational.
This statement has the following format:
{IF } [ {AND} ]
condition condition
{DO WHILE } [ { } ]...
{DO UNTIL } [ {OR } ]
Examples:
860
Easytrieve® Report Generator 11.6
The following list provides skeletal examples of each type of conditional expression that is used in an IF statement:
Type Example
Field Relational IF field-1 = field-2
Field Series IF field-1 = field-2, field-3, field-4
Field Class IF field-1 ALPHABETIC
Field Bits IF field-1 ON X'0F4000
File Presence IF EOF file-name
File Relational IF MATCHED file-1, file-2, file-3
Record Relational IF DUPLICATE file-name
Field Bits Condition
The field bits condition in Easytrieve compares selected bits of a field for on (1) or off (0) conditions.
This statement has the following format:
Relational
Subject Operator Object
field name
{IF } {ON } { - -2}
field name
{DO WHILE} - -1 [NOT] { } { }
literal
{DO UNTIL} {OFF} { }
Subject
Field-name-1 is the subject of the comparison. It can be any field type. The NOT parameter indicates the
condition test is reversed.
Relational Operator
The relational operators ON and OFF test for bit values of one or zero respectively.
Object
Field-name-2 or a literal identifies the bit mask to be tested. Easytrieve tests only those bits that correspond to
one (1) bits in the mask. The length of the object must equal the length of the subject. When you code a literal as
the object, it must be a hexadecimal literal. Indicate a hexadecimal literal by preceding it with an X and enclosing
it in single quotes.
If the subject is a VARYING field, the object must be equal to the length of the data portion of the subject. The test
is performed based on the actual length of the subject. The object cannot be a VARYING field.
Example:
This example illustrates the use of the field bits condition:
DEFINE FIELD-1 W 1 B VALUE X'20'
DEFINE FIELD-NUM W 4 B VALUE X'FF00FF00'
DEFINE PATTERN-8 W 1 B VALUE X'80'
DEFINE LOWER-CASE W 1 A VALUE X'81'
*
JOB INPUT NULL NAME MYPROG IF FIELD-1 ON PATTERN-8
DISPLAY 'PERFORM CODE FOR PATTERN 8'
861
Easytrieve® Report Generator 11.6
END-IF IF LOWER-CASE OFF X'40'
DISPLAY 'THIS LETTER IS LOWER CASE'
END-IF IF FIELD-NUM ON X'FF000000'
DISPLAY '1ST BYTE HIGH VALUES'
END-IF
STOP
Field Class Condition
Review which conditions are determined by the field class condition in Easytrieve .
The field class condition determines whether:
• All positions of a field contain alphabetic, numeric, space, or zero characters.
• A nullable field is null.
• The cursor is in a specific field on the screen.
• A field was modified by the terminal user.
• A field is active in a control break of the current report.
This statement has the following format:
Subject Object
{ALPHABETIC }
{BREAK }
{CURSOR }
{HIGHEST-BREAK}
{IF } {MODIFIED }
field name
{DO UNTIL } - [NOT] {NULL }
{DO WHILE } {NUMERIC }
{SPACE }
{SPACES }
{ZERO }
{ZEROS }
{ZEROES }
{HIGH-VALUES }
{LOW-VALUES }
Subject
Field-name is the subject of the comparison. Each byte of the field must pass the test before the test is true. The
NOT parameter indicates that the condition test is reversed.
Field-name can be indexed or subscripted.
Object
The object determines the class of data to be tested for.
{ALPHABETIC}
ALPHABETIC tests for the upper-case characters A to Z or a blank space in each byte of the subject field.
862
Easytrieve® Report Generator 11.6
{BREAK}
BREAK tests whether this field is currently being processed as a CONTROL break field on a report. The BREAK
test is an alternative to testing the field-name LEVEL for a specific numeric value. Field-name must be defined on
a CONTROL statement or it must be the reserved word FINAL.
{CURSOR}
CURSOR tests whether the cursor is in the specified field on the screen. CURSOR can be used only in screen
activity procedures.
If CURSOR is used, the condition must refer to a field on a ROW statement within the screen declaration.
NOTE
Results are unpredictable if:
• Field-name contains the ASKIP, PROTECT, or SENDONLY attributes.
• Field-name occurs more than once in a screen.
• Two screen fields redefine the same storage area and one of the fields is used in an IF test.
• The subject is indexed or subscripted and the value of the index or subscript has changed since the
screen was received.
• The test is performed after the user presses CLEAR, PA1, PA2, or PA3.
{HIGHEST-BREAK}
HIGHEST-BREAK tests whether this field caused the CONTROL break on a report. The HIGHEST-BREAK test is
an alternative to testing the field-name BREAK-LEVEL for a specific numeric value. Field-name must be defined
on a CONTROL statement or it must be the reserved word FINAL.
{MODIFIED}
MODIFIED tests whether the terminal operator changed the data in the field. The field is considered MODIFIED
only if the contents of the field upon receipt of the screen do not equal the contents of the screen at the time the
screen is displayed.
MODIFIED can be used only in screen activity procedures.
If MODIFIED is used, the condition must refer to a field on a ROW statement within the screen declaration.
NOTE
Results are unpredictable if:
• Field-name occurs more than once in a screen.
• Two screen fields redefine the same storage area and one of the fields is used in an IF test.
• The subject is indexed or subscripted and the value of the index or subscript has changed since the
screen was received.
• The test is performed after the user presses CLEAR, PA1, PA2, or PA3.
{NULL}
NULL tests whether a nullable field is NULL.
{NUMERIC}
NUMERIC tests for the digits 0 to 9 (in the correct format for the field's data type), and for a possible algebraic
sign in the low-order position of type-P fields or in the high-order position of type-N fields.
{SPACE}
SPACE and SPACES test for the character space in each byte of single-byte subjects.
{ZERO}
ZERO, ZEROS, and ZEROES test for the digit 0 (in the correct format for the field's data type), and for a possible
algebraic sign in the low-order position of type-P fields or in the high-order position of type-N fields.
863
Easytrieve® Report Generator 11.6
{HIGH-VALUES}
HIGH-VALUES tests for the character X'FF' in each byte of single-byte and MIXED format subjects and in each
double byte of DBCS subjects.
{LOW-VALUES}
LOW-VALUES tests for the character X'00' in each byte of single-byte and MIXED format subjects and in each
double byte of DBCS subjects.
Example
This example illustrates the use of the field class condition:
FILE PERSNL FB(150 1800)
REGION 1 1 N
BRANCH 2 2 N
EMPNAME 17 20 A
NAME-LAST EMPNAME 8 A
NAME-FIRST EMPNAME +8 12 A
*
TOTAL-NUMERIC W 3 N VALUE 0
TOTAL-NON-ZEROS W 3 N VALUE 0
TOTAL-ALPHABETIC W 3 N VALUE 0
*
JOB INPUT PERSNL NAME MYPROG FINISH FINISH-PROC IF REGION NUMERIC
TOTAL-NUMERIC = TOTAL-NUMERIC + 1
END-IF IF BRANCH NOT ZERO
TOTAL-NON-ZEROS = TOTAL-NON-ZEROS + 1
END-IF IF EMPNAME ALPHABETIC
TOTAL-ALPHABETIC = TOTAL-ALPHABETIC + 1
END-IF
*
FINISH-PROC. PROC
DISPLAY TOTAL-NUMERIC
DISPLAY TOTAL-NON-ZEROS
DISPLAY TOTAL-ALPHABETIC
END-PROC
Field Relational Condition
The field relational condition in Easytrieve compares fields with values.
This statement has the following format:
Relational
Subject Operator Object
{IF } {EQ|= }
field name
{ELSE-IF } {NE|Ø=|NQ } { - -2 }
field name literal
{ } - -1 {LT|< |LS } { }
arithmetic expression
{DO WHILE} {LE|<=|LQ|Ø> } { - }
864
Easytrieve® Report Generator 11.6
{DO UNTIL} {GT|> |GR }
{GE|>=|GQ|Ø< }
Subject
Field-name-1 is the subject of the comparison.
Relational Operator
Code any of the relational operators to control the condition's evaluation process.
Object Code
Code field-name-2, a literal, or an arithmetic-expression designates the object of the comparison.
NOTE
Alphanumeric literals must be enclosed within single quotes. For information about how Easytrieve
evaluates arithmetic expressions, see Assignments and Moves in the Programming section.
Alphanumeric Subjects
When the condition subject is an alphanumeric field, the following evaluation rules apply:
• The object must be either a field or an alphanumeric literal.
• If necessary, numeric field objects are converted to zoned decimal. Comparison of VARYING alphanumeric fields with
numeric fields is not permitted.
• The comparison is based on the greater of the length of the subject and the length of the object. The shorter item is
padded with spaces to the length of the longer item. For downward compatibility with existing Easytrieve programs, this
rule is subject to the following exception:
– When a fixed length subject is compared with a longer fixed length object, the comparison is based on the length of
the subject.
– The object is truncated to match the length of the subject. The compiler then generates a warning message.
• Comparison is logical (bit-by-bit).
• Comparisons of varying length fields (fields which use the VARYING option of the DEFINE statement) are based on
the length of the data at the time of the comparison.
Numeric Subjects
When the condition subject is a numeric field, the following evaluation rules apply:
• The object must be a numeric field, a numeric literal, or an arithmetic expression.
• Comparison is arithmetic.
Mixed Subjects
When the condition subject is a MIXED field, the following evaluation rules apply:
865
Easytrieve® Report Generator 11.6
• Easytrieve supports only equal (EQ =) and not equal (NE Ø= NQ) conditions. If you use any of the other conditional
operators, an error occurs.
• The object must be a field, an alphanumeric literal, a MIXED literal, or a DBCS literal.
• A conversion is not performed if the object is an EBCDIC alphanumeric field or literal.
• If the object is a MIXED field or literal, the DBCS portion of data is converted into the DBCS code system of the
subject. Easytrieve also converts the shift codes to the values defined for the DBCS code system of the subject in the
DBCS Options module.
• If the object is a DBCS field or literal, the data is converted into the DBCS code system of the subject. When this
conversion occurs, the shift codes defined for the code system of the subject are added to the data.
• Numeric field objects are converted to zoned decimal (if necessary).
• To match the length of the subject, Easytrieve truncates or pads the object. Padding uses the single-byte space
character. During truncation, no DBCS character is split. When truncation occurs within the DBCS portion of a field, the
truncation is adjusted to the nearest double byte boundary.
• Comparison is logical (bit-by-bit).
DBCS Subjects
When the condition subject is a DBCS field, the following evaluation rules apply:
• Easytrieve supports only equal (EQ =) and not equal (NE Ø= NQ) conditions. If you use any of the other conditional
operators, an error occurs.
• The object must be a field, an alphanumeric literal, a MIXED literal, or a DBCS literal.
• If the object is an EBCDIC alphanumeric field or literal, then each character is converted into the DBCS code system of
field-name-1.
• If the object is a MIXED field or literal, the DBCS portion of data is converted into the DBCS code system of the
subject. Easytrieve also converts the EBCDIC portion of data to its equivalent DBCS value based on the code system
of the subject. Shift codes are removed.
• If the object is a DBCS field or literal, the data is converted into the DBCS code system of the subject.
• If necessary, numeric field objects are converted to zoned decimal and then converts the EBCDIC result into the
equivalent DBCS characters based on the code system of field-name-1.
• To match the length of the subject, Easytrieve truncates or pads the object. Padding uses the DBCS space character.
• Comparison is logical (bit-by-bit).
Example:
This example illustrates various field relational conditions:
FILE PERSNL FB(150 1800)
EMP# 9 5 N
EMPNAME 17 20 A
NAME-LAST EMPNAME 8 A
NAME-FIRST EMPNAME +8 12 A
PAY-NET 90 4 P 2
PAY-GROSS 94 4 P 2
SEX 127 1 N
TOTAL-EMP# W 3 N VALUE 0
TOTAL-SEX W 3 N VALUE 0
TOTAL-PAY W 3 N VALUE 0
TOTAL-FIRST-NAME W 3 N VALUE 0
MALE W 1 N VALUE 1
JOB INPUT PERSNL NAME MYPROG FINISH FINISH-PROC IF EMP# GT 10000
TOTAL-EMP# = TOTAL-EMP# + 1
866
Easytrieve® Report Generator 11.6
END-IF IF SEX NE MALE
TOTAL-SEX = TOTAL-SEX + 1
END-IF IF PAY-NET LT (PAY-GROSS / 2)
TOTAL-PAY = TOTAL-PAY + 1
END-IF IF NAME-FIRST EQ 'LINDA'
TOTAL-FIRST-NAME = TOTAL-FIRST-NAME + 1
END-IF
*
FINISH-PROC. PROC
DISPLAY TOTAL-EMP#
DISPLAY TOTAL-SEX
DISPLAY TOTAL-PAY
DISPLAY TOTAL-FIRST-NAME
END-PROC
Field Series Condition
The field series condition in Easytrieve compares a field to a series or a range of values.
Evaluation rules for field series conditions are as follows:
• Alphanumeric (including DBCS and MIXED format fields) and numeric fields are evaluated as in the field relational
condition.
• An equal (=) relational operator tests if the subject is equal to or within range of any of the series of values comprising
the object.
• A not equal (Ø=) relational operator tests if the subject is unequal to or outside the range of all the series of values
comprising the object.
NOTE
A comparison within a range is satisfied if the subject is greater than the lesser of the two range values and the
subject is less than the greater of the two range values.
This statement has the following format:
Relational
Subject Operator
{IF }
{ELSE-IF } {EQ | = }
field name
{ } - -1 { } +
{DO WHILE } {NE | Ø= | NQ}
{DO UNTIL }
Object
field name field name
{ - -2 [ { - -3 } ] }
{ [THRU { } ]...}
literal literal
{ -1 [ { -2 } ] }
867
Easytrieve® Report Generator 11.6
Subject
Field-name-1 is the subject of the comparison.
Relational Operator
Equal and notequal are the only valid relational operators for field series conditions.
Object
Code field-name-2 or a literal-1 as often as you need to indicate the series of comparison objects. Field-name-2
THRU field-name-3, field-name-2 THRU literal-2, literal-1 THRU field-name-3, or literal-1 THRU literal-2 designate
a value range.
Note: Alphanumeric literals must be enclosed within single quotes.
Example:
This example illustrates the field series condition:
FILE PERSNL FB(150 1800)
REGION 1 1 N
BRANCH 2 2 N
DEPT 98 3 N
MARITAL-STAT 128 1 A
*
TOTAL-REGION W 3 N VALUE 0
TOTAL-BRANCH W 3 N VALUE 0
TOTAL-DEPT W 3 N VALUE 0
TOTAL-MARITAL W 3 N VALUE 0
WORK-REGION W 2 N VALUE 04
*
JOB INPUT PERSNL NAME MYPROG FINISH FINISH-PROC IF REGION = 0, 8, 9
TOTAL-REGION = TOTAL-REGION + 1
END-IF IF BRANCH NE 01, WORK-REGION
TOTAL-BRANCH = TOTAL-BRANCH + 1
END-IF IF DEPT EQ 940 THRU 950
TOTAL-DEPT = TOTAL-DEPT + 1
END-IF IF MARITAL-STAT NE 'M', 'S'
TOTAL-MARITAL = TOTAL-MARITAL + 1
END-IF
*
FINISH-PROC. PROC
DISPLAY TOTAL-REGION
DISPLAY TOTAL-BRANCH
DISPLAY TOTAL-DEPT
DISPLAY TOTAL-MARITAL
END-PROC
868
Easytrieve® Report Generator 11.6
File Presence Condition
The file presence condition in Easytrieve determines whether a record of the file is currently available for processing.
The object of the test is simply the availability of the record for processing. The file is available if the last GET or READ
operation was successful and there is a record that can be accessed.
NOTE
Results are unpredictable if data in a file is referenced after any output operation.
The optional EOF parameter causes the test to be true when the subject is at end-of-file. This test can never be true for
automatic input files.
The optional NOT parameter reverses the condition test.
For more information about file presence conditions, see the Easytrieve Programming Documentation.
This statement has the following format:
Subject
{IF }
file name
{DO WHILE} [NOT] [EOF] { - }
{DO UNTIL}
Subject
File-name designates the subject of the test.
Example 1
This example illustrates the use of the file presence condition:
FILE PERSNL INDEXED
%PERSNL
*
JOB INPUT NULL NAME MYPROG
READ PERSNL KEY '00970' STATUS IF NOT PERSNL
DISPLAY '00970 NOT ON FILE'
ELSE
DISPLAY EMPNAME
END-IF
STOP
Example 2
This example illustrates the use of the file presence condition in synchronized file processing:
FILE PERSNL FB(150 1800)
%PERSNL
FILE INVENT FB(200 3200)
%INVMSTR
FILE SORT1 FB(150 1800) VIRTUAL
COPY PERSNL
FILE SORT2 FB(200 3200) VIRTUAL
COPY INVENT
869
Easytrieve® Report Generator 11.6
COUNT-1 W 3 N VALUE 0
COUNT-2 W 3 N VALUE 0
*
SORT PERSNL TO SORT1 USING (ADDR-STATE) NAME MYSORT1
SORT INVENT TO SORT2 USING (LOCATION-STATE) NAME MYSORT2
*
JOB INPUT (SORT1 KEY (ADDR-STATE), +
SORT2 KEY (LOCATION-STATE)) +
NAME MYPROG FINISH FINISH-PROC IF EOF SORT2
DISPLAY 'EOF ON SECONDARY'
STOP
END-IF IF NOT PRIMARY
DISPLAY 'NO PERSONNEL RECORD- ' LOCATION-STATE
END-IF IF NOT SECONDARY
DISPLAY 'NO INVENTORY RECORD- ' ADDR-STATE
END-IF IF SORT1
* HOW MANY PERSONNEL RECORDS RETURNED
COUNT-1 = COUNT-1 + 1
END-IF IF SORT2
* HOW MANY INVENT RECORDS RETURNED
COUNT-2 = COUNT-2 + 1
END-IF
*
FINISH-PROC. PROC
DISPLAY COUNT-1
DISPLAY COUNT-2
END-PROC
File Relational Condition
The file relational condition in Easytrieve determines file presence and record matching for more than one file in JOBs
with synchronized file input.
This statement has the following format:
Subject
file name
[ - ]
IF [NOT] MATCHED [PRIMARY ] ...
[SECONDARY]
870
Easytrieve® Report Generator 11.6
Subject
The optional file-name, PRIMARY, and SECONDARY parameters identify the files to be tested. If you do not code
this parameter, the condition is true only if all input files have matching records.
The optional NOT parameter reverses the condition test.
Example:
This example illustrates the use of the file relational condition:
FILE PERSNL FB(150 1800)
%PERSNL
FILE INVENT FB(200 3200)
%INVMSTR
FILE SORT1 F(150) VIRTUAL
COPY PERSNL
FILE SORT2 F(200) VIRTUAL
COPY INVENT
COUNT-1 W 3 N VALUE 0
*
SORT PERSNL TO SORT1 USING (ADDR-STATE) NAME MYSORT1
SORT INVENT TO SORT2 USING (LOCATION-STATE) NAME MYSORT2
*
JOB INPUT (SORT1 KEY (ADDR-STATE), +
SORT2 KEY (LOCATION-STATE)) +
NAME MYPROG FINISH FINISH-PROC IF MATCHED
COUNT-1 = COUNT-1 + 1
END-IF
*
FINISH-PROC. PROC
DISPLAY COUNT-1
END-PROC
Record Relational Condition
The record relational condition in Easytrieve determines the relationship of the current record of a file to the previous and
next records of the same file.
This test is valid only for synchronized file processing and single file keyed processing.
This statement has the following format:
Subject
file name
{DUPLICATE} { - }
IF [NOT] {FIRST-DUP} {PRIMARY }
{LAST-DUP } {SECONDARY}
{DUPLICATE}
DUPLICATE is true when the previous or next record has the same key as the current record.
{FIRST-DUP}
FIRST-DUP is true for the first of two or more records with the same key.
871
Easytrieve® Report Generator 11.6
{LAST-DUP}
LAST-DUP is true for the last of two or more records with the same key.
Subject
The file-name, PRIMARY, and SECONDARY parameters identify the file to be tested.
The optional NOT parameter reverses the condition.
Example:
This example illustrates the use of the record relational condition:
FILE PERSNL FB(150 1800)
%PERSNL
FILE INVENT FB(200 3200)
%INVMSTR
FILE SORT1 FB(150 1800) VIRTUAL
COPY PERSNL
FILE SORT2 FB(200 3200) VIRTUAL
COPY INVENT
COUNT-1 W 3 N VALUE 0
COUNT-2 W 3 N VALUE 0
*
SORT PERSNL TO SORT1 USING (ADDR-STATE) NAME MYSORT1
SORT INVENT TO SORT2 USING (LOCATION-STATE) NAME MYSORT2
*
JOB INPUT (SORT1 KEY (ADDR-STATE) +
SORT2 KEY (LOCATION-STATE)) +
NAME MYPROG FINISH FINISH-PROC IF DUPLICATE PRIMARY
COUNT-1 = COUNT-1 + 1
END-IF IF DUPLICATE SORT2
COUNT-2 = COUNT-2 + 1
END-IF
*
FINISH-PROC. PROC
DISPLAY COUNT-1
DISPLAY COUNT-2
END-PROC
CONTROL Statement
The CONTROL statement in Easytrieve identifies control fields used for a report.
A control break occurs whenever the value of any control field changes or end-of-report occurs. The control break at end-
of-report is equivalent to the final break. A break level is also assigned to each control field. Comparison of control fields is
a logical compare.
You can specify one or more control breaks. If you do not specify any control breaks, a FINAL break is implied.
A break level is assigned to each control field. The system-defined field LEVEL contains the break level used in the
BEFORE-BREAK and AFTER-BREAK report procedures. LEVEL can have the following values:
872
Easytrieve® Report Generator 11.6
• 1 when processing the minor field break
• The number of control fields (n) when processing the major field break
• The number of control fields plus one (n+1) when processing the FINAL control break
The system-defined field BREAK-LEVEL contains the break level of the highest field to break.
An alternative to testing the LEVEL and BREAK-LEVEL fields is to use the IF BREAK and IF HIGHEST-BREAK tests.
Coding IF BREAK field-name is equivalent to coding IF LEVEL = x, where x is the break level assigned to field-name.
IF HIGHEST-BREAK performs the same function against the BREAK-LEVEL field. IF BREAK and IF HIGHEST-BREAK
have the advantage of dynamically changing the LEVEL value if fields are added to or removed from the CONTROL
statement.
Control fields are compared logically, rather than bit-by-bit. For example, packed fields containing zero with a C sign are
logically equal to zero with an F sign.
In an XML-formatted report, the CONTROL fields represent the hierarchy in the XML output file and all other CONTROL
statement parameters are ignored.
For detailed examples of the CONTROL statement, see Report Processing.
This statement has the following format:
field-name
[ ] [NEWPAGE]
CONTROL [ ] [ ] [NOPRINT]...
[FINAL ] [RENUM ]
[field-name] or [FINAL]
Prior to the first field-name, you can code FINAL to specify options for the control break at end-of-report. Field-
name specifies any non-quantitative field located in an active file or in a W-type working storage field.
Specify control fields in major to minor order.
NOTE
Varying length, K (DBCS/Kanji), and M (MIXED) fields cannot be specified on a CONTROL statement.
The following three options alter normal processing of a control break:
[NEWPAGE]
NEWPAGE causes a skip to top-of-page after control break processing is complete for the specified field.
[RENUM]
RENUM performs the same function as NEWPAGE, and also resets the page number to 1 on the page following
the control break.
[NOPRINT]
NOPRINT suppresses printing the summary line group for the specified control break. All other control break
processing for the specified control break is performed as usual.
Example
CONTROL FINAL NEWPAGE REGION NEWPAGE BRANCH DEPT
COPY Statement
The COPY statement in Easytrieve duplicates the field definitions of a named file.
You can code an unlimited number of COPY statements for any one file. Easytrieve duplicates the fields as if they were
coded at the place where Easytrieve encounters the COPY statement.
873
Easytrieve® Report Generator 11.6
The same rules of field definition apply when using the COPY statement (that is, field names must be unique in a given
file).
This statement has the following format:
file name
{ - }
COPY { }
database file name record name
{[ - - ]: - }
file-name
File-name is the name of a previously-defined file whose fields you want to duplicate.
[database-file-name]:record-name
Record-name is the name of a previously-defined database record whose fields you want to duplicate. Optionally,
code database-file-name for qualification.
Example 1
The following is a COPY statement example:
FILE PERSNL FB(150 1800)
EMPNAME 17 20 A HEADING ('EMPLOYEE NAME')
NAME-LAST EMPNAME 8 A HEADING ('LAST' 'NAME')
NAME-FIRST EMPNAME +8 12 A HEADING ('FIRST' 'NAME')
FILE SORTWRK FB(150 1800) VIRTUAL COPY PERSNL
SORT PERSNL TO SORTWRK USING +
(NAME-LAST NAME-FIRST) NAME MYSORT
JOB INPUT SORTWRK NAME MYPROG
PRINT REPORT1
*
REPORT REPORT1
LINE NAME-FIRST NAME-LAST
Example 2
This example shows a COPY with IDMS:
FILE DBASE IDMS(DEMOSS03)
RECORD CUSTOMER 104 KEY(CUST-NO)
CUST-NO 1 10 A
CUST-NAME 11 20 A
RECORD SALES 28
SLS-CUST-NO 1 10 A
FILE DDBASE FB(28 280) COPY SALES (fields from RECORD SALES copied)
JOB INPUT (DNASE) NAME MYPROG
RETRIEVE DBASE +
SELECT (CUSTOMER AREA 'CUSTOMER-REGION' +
SALES ID 'SA' SET 'CUSTOMER-SALES')
IF PATH-ID EQ 'SA'
MOVE LIKE SALES TO DDBASE
PUT DDBASE
874
Easytrieve® Report Generator 11.6
ELSE
GO TO JOB
END-IF
CURSOR Statement
The CURSOR statement in Easytrieve within a screen procedure sets the initial position of the cursor in a field for the
next display of the screen.
You can use the CURSOR statement only within screen procedures (AFTER-SCREEN, BEFORE-SCREEN, INITIATION,
TERMINATION), or within any procedure performed from a screen procedure.
The CURSOR statement must refer to a field on a ROW statement within the screen declaration.
NOTE
Results are unpredictable if:
• Field-name contains the ASKIP, PROTECT, or SENDONLY attributes
• Field-name occurs more than once in a screen
• Two screen fields redefine the same storage area and one is used in the CURSOR statement
Field-name can be subscripted or indexed. However, if the value of the subscript or index changes between the time the
CURSOR statement is executed and the time the screen is actually displayed, the CURSOR positioning is ignored. The
CURSOR statement:
• Overrides cursor placement if a screen field contains the CURSOR attribute.
• Can be executed any number of times before displaying the screen. The last CURSOR statement executed
determines the cursor placement.
• Cannot be moved into an auto-skip (ASKIP) field.
For information about cursor placement hierarchy, see the Programming section.
This statement has the following format:
field name
CURSOR AT -
field-name
Field-name refers to a field on a ROW statement within the screen declaration.
Example:
SCREEN NAME SCRN1
ROW 3 WORK-DESCRIPTION
ROW 5 EMP#
. . .
BEFORE-SCREEN. PROC CURSOR AT EMP#
END-PROC
DECLARE Statement
The DECLARE statement in Easytrieve declares named screen attributes and input edit patterns, and specifies how a
subprogram is linked.
Using declared attributes lets you dynamically change screen attributes during program execution. Using declared
attributes and edit patterns saves you coding time when the set of attributes or edit patterns are used many times.
875
Easytrieve® Report Generator 11.6
An attribute field can be assigned to another attribute field. Patterns and programs cannot be assigned.
Other than the assignment, declared screen attributes can be used only on DEFAULT, TITLE, and ROW statements.
Attributes can also be dynamically changed using the SET statement.
This statement has the following format:
attribute list
{ATTR [( - )] }
name pattern
DECLARE {PATTERN ' ' }
{PROGRAM {STATIC|DYNAMIC}}
name
Specify a name up to 128 characters for the set of declared screen attributes or set of declared pattern
characters.
ATTR [(attribute-list)]
Specify a list of attribute values. The attribute list must be enclosed in parentheses. For a list and explanations of
valid attributes, see ATTR Parameter.
PATTERN 'pattern'
PATTERN lets you specify a sequence of characters that describe the format of the data in the field. The
character string must be enclosed in single quotes.
Note: Use PATTERN to edit complex combinations of data types and character sequences. Use the MASK
parameter to edit numeric data.
The valid pattern characters and their meanings are listed in the following table:
Character Meaning
A Represents a lowercase or an uppercase letter.
B Represents a single blank.
D Represents a digit.
E Represents an empty string.
L Represents a lowercase letter.
N Represents an uppercase letter or a national character.
U Represents an uppercase letter.
X Represents any character.
"x" Double quotes surrounding a character or a sequence of
characters literally represent the character or sequence of
characters contained within. The x represents any character. . To
literally represent single or double quotes, use two sets of quotes
within the surrounding set of double quotes ('""""' or '"x""x"', '"''"' or
'"x''x"').
blank Blanks (unless contained in double quotes) serve as delimiters
but are otherwise ignored. They can be inserted into the pattern to
increase readability.
( ) Represents grouping to control the precedence of operators.
or | or , Represents a choice (or alternation operator).
876
Easytrieve® Report Generator 11.6
(m) or (m..n) or (m..*) or (*) or * Represents the repetition of the preceding pattern expression.
The m and n represent numbers and m must be less than n. A
single number with parentheses indicates the exact number of
repetitions. (m..n) represents a range of repetitions, minimum to
maximum. An asterisk in a range, (m..*), represents an infinite
maximum. An asterisk by itself, (*) or *, represents a range from 0
to infinity.
# or /-/ Represents the remove (or toss) operation. This operation applies
only to a single character set at a time and must immediately
follow that character set in the pattern. This operation removes the
character that matched the character set from the data.
+ Represents character set addition to form another character set.
- Represents character set difference to form another character set.
concatenation Concatenation is implied by proximity. For example, DDDU means
3 digits followed by an uppercase letter.
The precedence of operators from highest to lowest:
Grouping: () " "
Set construction: + -
Actions: #
Repetition: (n) (m..n) (m..*) (*)
Concatenation: proximity
Choice: |
The edit pattern is evaluated from left to right (the data from the screen is processed from left to right). Patterns examine
only one character at a time. They do not look ahead and they do not backtrack. For more information, see the
Easytrieve Programming Guide.
PROGRAM {STATIC|DYNAMIC}
PROGRAM lets you specify how you want to link a subprogram. Specify STATIC to indicate that you want
the subprogram to be linked with your Easytrieve program. Specify DYNAMIC to indicate that you want the
subprogram to be dynamically loaded. The default is taken from the PARM CALL statement.
Example
DECLARE PROTECT-FIELD ATTR (TURQ PROTECT)
DECLARE VARYING-ATTR ATTR
DECLARE PART-ID PATTERN 'A"-"DDA'
DEFAULT Statement
The DEFAULT statement in Easytrieve specifies screen-level overrides of system-defined attributes (Format 1) and
message attributes and locations (Format 2).
If used, DEFAULT statements must be the first statements coded in a screen activity.
You cannot code overlapping overrides. For example, the following code is in error because the attribute for
INFORMATION level messages is coded twice:
DEFAULT MESSAGE INFORMATION ATTR BLUE
DEFAULT MESSAGE (INFORMATION WARNING) ATTR GREEN
The following attributes are ignored for TITLE, LITERAL, and KEY:
877
Easytrieve® Report Generator 11.6
• CURSOR
• NUMERIC
• INVISIBLE
• MUSTFILL
• MUSTENTER
• TRIGGER
• ALARM
If coded, Easytrieve issues a warning message during compilation. All of the above attributes are also ignored for
MESSAGE, except for ALARM.
This statement has the following format:
Format 1
{TITLE }
attribute name
{FIELD { - } }
DEFAULT { [ERROR] ATTR { } }
attribute list
{LITERAL {( - )} }
{KEY }
Format 2
attribute name
{ { - } }
[INFORMATION] {ATTR { } }
attribute list
DEFAULT MESSAGE ( [WARNING ]...) { {( - )} }...
[ACTION ] { }
row number
{ROW - }
TITLE
Use TITLE to override attributes for all screen titles (fields and literals) in a screen activity.
Note: You can also override attributes at a title item level. See TITLE Statement.
LITERAL
Use LITERAL to override attributes for all row literals in a screen activity.
NOTE
You can also override attributes at a screen item level. See ROW Statement.
FIELD [ERROR]
Use FIELD to override attributes for all row fields in a screen activity. Optionally, specify ERROR to override
attributes for fields flagged in error by the automatic edit process.
NOTE
You can also override attributes at a screen item level. See ROW Statement.
KEY
Use KEY to override attributes for a function key display area in a screen activity.
ATTR {attribute-name} or ATTR {(attribute-list)}
Specify either a declared screen attribute name or one or more attribute keywords. For a list of attributes, see
ATTR Parameter. For information about how to declare screen attributes, see DECLARE Statement.
MESSAGE
Use MESSAGE to override attributes for any or all message levels (INFORMATION, WARNING, ACTION).
ROW row-number
Use ROW to override the placement of the message level (INFORMATION, WARNING, ACTION). Row-number
must be an unsigned integer that does not exceed the maximum screen size (SCREEN ROWCOUNT) and
specifies the row number on which the message is displayed.
878
Easytrieve® Report Generator 11.6
If ROW is not specified, all messages are displayed one line above the key display area, if used. For more
information, see KEY Statement.
Examples
Note the following examples of the message statement.
Example 1
You can use MESSAGE to display INFORMATION level messages in yellow and all other levels of messages in red:
DEFAULT MESSAGE INFORMATION ATTR YELLOW
DEFAULT MESSAGE (WARNING ACTION) ATTR (RED INTENSE)
Example 2
You can override the placement of messages on a screen using the ROW parameter:
SCREEN NAME MENU-SCREEN
DEFAULT FIELD ATTR (TURQ PROTECT)
DEFAULT FIELD ERROR ATTR (RED BLINK ALARM)
DEFAULT MESSAGE (INFORMATION WARNING) ATTR YELLOW ROW 23
DEFAULT MESSAGE (ACTION) ATTR RED ROW 24
DEFINE Statement
The DEFINE statement in Easytrieve specifies data fields within a file or within working storage.
You can generate DEFINE statements automatically by using the SQL INCLUDE or IDD statements.
This article contains the following information:
Field Length and Decimal Positions
Use the following table when specifying field-length and decimal-positions:
Data Maximum Number of
Format Length Decimal
Code (bytes) Positions
A 32,767* not valid
K 32,766* not valid
M 32,767* not valid
N 18 0 - 18
P 10 0 - 18
B 8 0 - 10
U 9 0 - 18
I 8 0
* For table file fields, ARG (argument) and DESC (description), the maximum length is 254 bytes.
NOTE
In CICS, the maximum total field length (field-length multiplied by maximum-occurrences) is 32,759.
Format
The DEFINE statement has the following format:
879
Easytrieve® Report Generator 11.6
DEFINE +
file qualifier field name
[ - :] - + } Field Name
start location
{ - } }
offset value
{* [+ - ] } }
{W } + } Location
{S } }
file qualifier overlay field name offset value
{[ - :] - - [+ - ]} }
field length decimal positions
{ - {A|M|K|N|P|B|U|I} [ - ] [EVEN]} }
{ } + } Attributes
file qualifier model field name
{[VARYING] [ - :] - - } }
[UPDATE] + }
}
font number heading literal
[HEADING ([# - ] ' - ' ...)] + }
}
index field name
[INDEX ( - - )] + }
}
mask identifier mask literal
[MASK ({[ - ][BWZ][' - ']|HEX})] + } Characteristics
}
maximum occurrences
[OCCURS - ] + }
}
initial value
[VALUE - ] + }
}
[RESET] }
Keyword
DEFINE
The DEFINE keyword must precede each field definition for definitions outside the library section.
You can omit the DEFINE keyword for fields defined after the associated FILE statement or for working storage
fields defined after any FILE statement.
Field Name
[file-qualifier:] field-name
File-qualifier identifies the appropriate file, record, or working storage for the field you are defining.
Field-name is the name of the field that you are defining. The field-name:
• Can be from 1 through 128 alphanumeric characters in length
• Can contain any character other than a delimiter
• Must begin with A through Z, 0 to 9, or a national character (#, @, $)
• Cannot be all numeric characters
Location
You must establish the location of the field's leftmost (starting) position in one of the following ways:
{start-location}
Start-location specifies the starting position relative to position one of the current file or record.
NOTE
Start-location must be specified as an unsigned integer.
880
Easytrieve® Report Generator 11.6
{* [+offset-value]}
The * (asterisk) indicates that the field begins in the next available starting position (highest location defined so
far, plus 1). The optional +offset-value is an offset you want added to the * value. There must be at least one blank
between the * and the optional +offset-value.
NOTE
+offset-value must be specified as a positive literal.
{W} or {S}
Coding W or S establishes a working storage field. S indicates a static working storage field. The product spools
W fields to report (work) files; it does not spool S fields.
NOTE
For more information about working storage fields, see Define Files and Fields.
{[file-qualifier:] overlay-field-name [+offset-value]}
Specify overlay-field-name if you want an overlay redefinition. If you use overlay redefinition, make sure that
field-name fits within the storage boundaries of overlay-field-name. Overlaying fields with a different data format
is allowed but may result in unexpected results as contents are not revalidated. Any indexes associated with
overlay-field-name also apply to field-name.
Specify the optional file-qualifier if the redefined field is in a file or record other than the file or record currently
being defined.
The optional +offset-value allows you to offset the field from the beginning of overlay-field-name.
Attributes
For each field-name you define, you must specify the field length in bytes, the data format, the number of decimal-
positions (if any), and the optional VARYING parameter for varying length alphanumeric fields.
{field-length}
Field-length specifies the length (in bytes) of the defined field. Field-length must be an unsigned integer.
{A|M|K|N|P|B|U|I}
Specify the data format by entering one of the following letters:
A (alphanumeric)
-- Use A when none of the numeric data types applies to the associated field. A-type fields in files are
EBCDIC format, unless the associated file was declared ASCII on the CODE parameter of the PARM or
FILE statement. A-type fields in working storage are either EBCDIC or ASCII, depending on the PARM
CODE PROCESS value.
M (MIXED alphanumeric)
-- (Mainframe only) Use M when you know the data in the associated field is EBCDIC, DBCS, or a mixture
of both. Easytrieve processes the field assuming that it contains EBCDIC data. The DBCS data in this
field must be identified by the shift codes in the field's DBCS code system. Easytrieve assumes that the
field's DBCS code system is the CA-PSI/DBCS processing code system, unless the field belongs to a file
that has the CODE parameter specified on its FILE statement. This field type is invalid for those DBCS
code systems that do not have an assigned shift code system and cannot support a MIXED field type.
K (DBCS alphanumeric)
-- (Mainframe only) Use K when you know the data in the field is in DBCS format. The length of the field
must be a multiple of two. The data in this field is associated with the DBCS code system defined as the
CA-PSI/DBCS processing code, unless the field belongs to a file that has the CODE parameter specified
on its FILE statement.
N (zoned decimal)
-- Use N when the field contains digits 0 to 9 in external decimal form. For example, 0 = X'F0' in EBCDIC
and X'30' in ASCII.
881
Easytrieve® Report Generator 11.6
Note: In the options table, ASCSIGN specifies which system to use to create zoned numeric fields. For
more information, see Compiler Options.
P (packed decimal)
-- Use P when the field contains numbers that meet the IBM definition of internal packed decimal. For
example, the two-byte packed field containing 123 looks like X'123F', and the two-byte packed field
containing -123 looks like X'123D'
B (binary)
-- Use B when the field contains binary data. In a quantitative binary field (a field with zero or more
decimal places specified), the high order bit is the sign bit. In a non-quantitative binary field (a field with no
decimal place specification), the high order bit is a binary digit.
NOTE
Information about signed (quantitative) and unsigned (non-quantitative) fields follows. For rules about
working with signed and unsigned fields, see Programming.
For example, in a one-byte quantitative binary field the following is true:
(HEX) 7F = (BIN) 0111 1111 = (DECIMAL) 127
(HEX) 80 = (BIN) 1000 0000 = (DECIMAL) 128-
For a one-byte non-quantitative binary field, the following is true:
(HEX) 7F = (BIN) 0111 1111 = (DECIMAL) 127
(HEX) 80 = (BIN) 1000 0000 = (DECIMAL) 128
The following table shows the length equivalent and maximum possible values for quantitative binary fields:
Field Length (in Bytes) Digits Maximum Value Minimum Value
1 3 127 128-
2 5 32,767 32,768-
3 7 8,388,607 8,388,608-
4 10 2,147,483,647 2,147,483,648-
5 12 549,755,813,887 549,755,813,888-
6 15 140,737,488,355,327 140,737,488,355,328-
7 17 36,028,797,018,963,967 36,028,797,018,963,968-
8 19 9,223,372,036,854,775,807 9,223,372,036,854,775,808-
The following table shows the length equivalent and maximum possible values for non-quantitative binary fields:
Field Length (in Bytes) Digits Maximum Unsigned Value
1 3 255
2 5 65,535
3 8 16,777,215
4 10 2,147,483,647
5 13 1,099,511,627,775
6 15 281,474,976,710,655
7 17 72,057,594,037,927,935
8 19 9,223,372,036,854,775,807
882
Easytrieve® Report Generator 11.6
U (unsigned packed decimal)
-- Use U for packed data where a sign is not needed. For example, a two-byte unsigned packed field containing
123 looks like X'0123'.
I (integer)
-- The field contains integer-formatted data in the native format of the host environment. The length of an Integer
(I) field must be two, four, or eight bytes. Decimal places must be blank or zero.
Numeric field capacities for signed I fields (quantitative) are:
Field Length (in Bytes) Maximum Value Minimum Value
2 32,767 -32,768
4 2,147,483,647 -2,147,483,648
8 9,223,372,036,854,775,807 -9,223,372,036,854,775,808
Numeric field capacities for unsigned I fields (non-quantitative) are:
Field Length (in Bytes) Maximum Unsigned Value
2 65,535
4 2,147,483,647
8 9,223,372,036,854,775,807
{[decimal-positions]}
Decimal-positions is an option that specifies the desired number of decimal positions for field-name. Decimal-
positions must be specified as an unsigned integer. If decimal-positions is specified (even if 0), the field is
considered to be quantitative. Otherwise, the field is considered non-quantitative. Quantitative fields are
automatically summed on reports. Decimal-positions cannot be specified for data type A.
[EVEN]
Use EVEN to indicate that a packed decimal field (P) is to contain an even number of digits. The high order digit is
zero. For example, a two-byte packed even field can only contain two digits, such as X'012F'.
NOTE
EVEN is valid only for P fields.
[VARYING]
Use VARYING to indicate that field-name is a varying length field. This means that the length of the data in this
field, for each occurrence in separate records, is unique. Varying length fields are alphanumeric and consist of a
two-byte length value followed by the data. VARYING fields typically are used for SQL VARCHAR columns.
NOTE
The VARYING parameter is not supported for M or K fields.
You can specify VARYING on type A fields. When VARYING is specified, the length attribute (field-length) is the
total number of bytes that the varying length field can occupy (two-byte length plus maximum size of data).
You can specify VARYING for file fields or working storage fields. For file fields, the starting position (start-
location) points to the two-byte indicator. For both file fields and working storage fields, overlay redefinition begins
with the two-byte length indicator.
When referencing a VARYING field in your program, you can use field-name alone or suffixed as shown below.
Assume field-name is FLDA:
• FLDA references the entire field (both length and data) as a variable length field
• FLDA:LENGTH references only the length (first two bytes) as a two-byte binary field
• FLDA:DATA references the data portion of the field (from byte three on) as an alphanumeric field
883
Easytrieve® Report Generator 11.6
When a VARYING field is displayed in your output, the data window is based on the maximum length of the field
(field-length minus two). The length indicator does not display in output unless DISPLAY HEX is specified.
Length restrictions for varying length fields are as follows:
Field Type Minimum Length Maximum Length
A 3 32769
The default value for a varying field is a string of zero length. However, if the VALUE option is coded, its value and
length become the default for the field.
{[file-qualifier:] model-field-name}
Optionally, you can specify a field name to use as a model for the field you are defining (field-name). The
attributes used in model-field-name are duplicated for field-name. If model-field-name is in a different file or
record, specify the name of that file. If you use this option, you need not specify attributes for field-name.
Characteristics
[UPDATE]
Specify UPDATE for each SQL field to be modified. You can specify UPDATE only for fields defined in an
Easytrieve SQL file.
NOTE
Only SQL fields specified as UPDATE can be modified by the UPDATE statement.
If UPDATE is specified on the FILE statement, UPDATE is used for all fields defined in the file.
NOTE
You must have UPDATE authorization for the column in the SQL table that this file references.
[HEADING ([#font-number] 'heading-literal'...)]
The HEADING option specifies an alternative report heading for field-name (the default is the actual field-name).
NOTE
HEADING can be used in the Easytrieve Online Screen Painter as a default prompt for field-name.
[INDEX (index-field-name ...)]
The INDEX option establishes indexes for field-name. You can specify multiple indexes by coding a list of index
names (index-field-name) enclosed in parentheses.
Easytrieve automatically allocates a four-byte quantitative binary field for each index. Any references you make
to a field with the INDEX option cause that field's location to be adjusted by the amount contained in index-field-
name. For more information, see the Programming section.
[MASK ({[mask-identifier][BWZ]['mask-literal']|HEX})]
The optional MASK parameter is used to format field-name for display.
You can use any letter from A to Y as an optional mask-identifier. You can use the letter to identify a new mask or
to retrieve a mask that was previously defined either in the Options Table or by a mask parameter on a previous
field definition. If the new mask that you identify does not already exist, Easytrieve retains the mask for future
reference. If you subsequently reference field-name for display, Easytrieve automatically uses the associated
letter identifier to determine the edit mask. Do not use the same identifier to establish more than one mask.
The BWZ (blank when zero) option suppresses the display of field-name when it contains all zeros. BWZ can be
used by itself or with other options on the MASK parameter.
'mask-literal'
Defines an edit mask and must be enclosed within single quotes. The actual edit mask is coded according
to the rules specified under the MASK Parameter. For more information, see MASK Parameter.
HEX
Specifies a special edit mask that instructs Easytrieve to display the contents of field-name in double-
digit hexadecimal format. You can display fields of up to 50 bytes with the HEX mask.
884
Easytrieve® Report Generator 11.6
NOTE
HEX edit masks are not allowed for VARYING fields.
[OCCURS maximum-occurrences]
The OCCURS option establishes an array for field-name.
Maximum-occurrences specifies the number of elements in the array (the number of occurrences of field-name).
Maximum-occurrences must be specified as an unsigned integer. The maximum value is 32,767. The total size
of the field (length * occurrences) is limited by the FLDMAX option in the options table. For more information on
FLDMAX, see Updating Options. You can reference the elements of this array by manipulating the INDEX defined
for field-name or by using subscripts. For more information, see the Programming section.
[VALUE initial-value]
The VALUE option initializes the contents of a field in working storage.
Initial-value can be any valid literal whose type matches the field-name type. If initial-value is non-numeric, it must
be enclosed in single quotes. The maximum length for initial-value is 254 bytes.
If the initial-value does not match the length of field-name, it is truncated or padded according to assignment
rules.
[RESET]
Use RESET only for W working storage fields. When you code RESET on the field definition for a W field, RESET
returns the field to its initial value whenever a JOB, SCREEN, or SORT is executed. You can use RESET with
OCCURS for array fields but not for redefined fields (fields having overlay redefinition). When you use RESET on
multiple fields, the fields are reset in the order of the field definitions.
NOTE
When W working fields are referenced in report processing, a RESET is not performed during the
printing of spooled reports.
Examples
The DEFINE statement specifies data fields within a file or within working storage. You usually specify file
fields and work fields in your Easytrieve library section, but you can also define them within an activity, as the
following examples illustrate. Example 1: DEFINE Statement in the Library Section
{ FILE PERSNL FB(150 1800)
Library { DEFINE EMP# 9 5 N
{ DEFINE EMPNAME 17 20 A
{ DEFINE EMP-COUNT W 4 N
*
{ JOB INPUT PERSNL NAME MYPROG
{ EMP-COUNT = EMP-COUNT + 1
Activities { PRINT REPORT1
*
{ REPORT REPORT1
{ LINE EMP# EMPNAME EMP-COUNT
Example 2: DEFINE Statement in an Activity
{ FILE PERSNL FB(150 1800)
Library { SALARY-CODE 134 2 N
{ *
{ JOB INPUT PERSNL NAME MYPROG
{ DEFINE EMP# 9 5 N
{ DEFINE EMPNAME 17 20 A
Activities { PRINT REPORT1
{ *
{ REPORT REPORT1
885
Easytrieve® Report Generator 11.6
{ LINE EMP# EMPNAME SALARY-CODE
When fields are defined in an activity, each field definition must start with the DEFINE keyword and physically
be defined before the field is referenced. In the library section, the use of the DEFINE keyword is optional.
Record Description
The examples below illustrate two ways of describing a record from a personnel file. The first method uses an asterisk (*)
to define the starting location of the fields. The second method uses absolute starting positions. In this case, both methods
result in the same description. The DEFINE keyword is not needed when the field definitions immediately follow the FILE
statement.
Method 1
FILE PERSNL FB(150 1800)
REGION * 1 N
BRANCH * 2 N
SSN * 5 P
EMP# * 5 N
JOB INPUT PERSNL NAME MYPROG
PRINT REPORT1
*
REPORT REPORT1
LINE EMP# REGION BRANCH
Method 2
FILE PERSNL FB(150 1800)
REGION 1 1 N
BRANCH 2 2 N
SSN 4 5 P
EMP# 9 5 N
JOB INPUT PERSNL NAME MYPROG
PRINT REPORT1
*
REPORT REPORT1
LINE EMP# REGION BRANCH
Working Storage Initialization
Easytrieve initializes numeric work fields to zeros and alphabetic work fields to blanks. To initialize these fields to other
values, use the VALUE parameter, as shown below:
DEFINE CURRENT-MONTH W 10 A VALUE 'JANUARY'
To reinitialize the field each time a JOB, SORT, or SCREEN activity is executed, add the RESET parameter.
Varying Length Fields
The VARYING parameter on the DEFINE statement designates varying length fields. An example of a varying length field
definition is as follows:
FLDA W 250 A VARYING
Because VARYING is used, this W type work field has two parts that are internally defined as follows:
forthetwo bytefieldlength
W 2 B 0 -
886
Easytrieve® Report Generator 11.6
forthedata
W 248 A
Alternative Report Headings
The default report heading for a field is the field name. You can override this default by using the HEADING parameter, as
shown in the following example:
FILE PERSNL FB(150 1800)
EMP# 9 5 N HEADING('EMPLOYEE' 'NUMBER')
PAY-NET 90 4 P2 HEADING('NET' 'PAY')
PAY-GROSS 94 4 P2 HEADING('GROSS' 'PAY')
WORK-FIELD W 4 P2 HEADING('AMOUNT' 'OF' 'TAXES')
Edit Masks
To add an edit mask to a telephone number, use the MASK parameter:
DEFINE PHONE S 10 N MASK '(999) 999-9999'
Arrays
The following example defines an array. There are 10 occurrences of the 2-byte numeric field, ELEMENT, in the array.
When the array field is used to define the entire array, ARRAY can be used to refer to the entire storage area.
DEFINE ARRAY W 20 A
DEFINE ELEMENT ARRAY 2 N 0 OCCURS 10
For more information about array processing, see Array Processing.
DELETE Statement
The DELETE statement in Easytrieve deletes a specific row from an Easytrieve SQL file.
DELETE performs a DELETE WHERE CURRENT OF cursor. The file must be defined with the UPDATE parameter.
Note: DELETE WHERE CURRENT OF cursor cannot be dynamically processed by the SQL interface for IDMS. To
perform SQL deletes, you must code native SQL statements using a searched delete statement.
This statement has the following format:
file name
DELETE [FROM] -
[FROM]
Optionally, code FROM for statement readability.
[file-name]
File-name must be the name of an Easytrieve SQL file.
Example
The following example selects a specific row from the table, and then deletes it:
FILE PERSNL SQL (PERSONNEL) UPDATE
EMPNAME * 20 A
WORKDEPT * 2 P O
EMPPHONE * 3 P O
PROGRAM NAME RETRIEVE-PERSONNEL
887
Easytrieve® Report Generator 11.6
SELECT FROM PERSNL WHERE EMPNAME = 'ROGERS PAT'
FETCH FROM PERSNL
IF EOF PERSNL
DISPLAY 'EMPLOYEE NOT FOUND'
ELSE
DELETE FROM PERSNL
END-IF
DISPLAY Statement
The DISPLAY statement in Easytrieve formats and transfers data to a system output device or a named file.
You can code DISPLAY to transfer printed data to the system output device, or you can optionally code a file name after
DISPLAY to cause data to be printed to the named file. The DISPLAY statement has three formats; Format 3 can only be
used when the file is associated with an extended reporting printer.
Unless you specify relative or absolute positioning, the first data entry of each DISPLAY statement begins in column 1 of
the print line. Each data entry that follows is printed next to the preceding entry. For HEX displays, the output is printed
five lines per 100 bytes of the record or field.
When you use DISPLAY in REPORT procedures, output is always in the appropriate place in the report. However, when
you use DISPLAY in a JOB activity, the output can be interspersed with the first unsequenced report if no file-name is
specified.
Data displayed to an output file is in an edited format. DISPLAY is not valid for nullable fields, but DISPLAY HEX is valid.
This statement has the following format:
Format 1
display file name
[ - - ] [{TITLE|NOTITLE} ]
skip integer
DISPLAY [ ] [SKIP - ] +
carriage control character
[SYSPRINT ] [CONTROL ' - - ']
field name
[ [ ] - ]
font number
[ [# - ] ]
literal
[ [ ]' ' ]
offset
[+ ] ...
offset
[- ]
column number
[COL - ]
position number
[POS - ]
Format 2
display file name
[ - - ] [{TITLE|NOTITLE} ]
skip integer
DISPLAY [ ] [SKIP - ] +
carriage control character
[SYSPRINT ] [CONTROL ' - - ']
file name
{ - }
field name
HEX { - }
record name
{ - }
Format 3
display file name
[ - - ] [ ]
888
Easytrieve® Report Generator 11.6
control literal
DISPLAY [ ] [CONTROL ' - ']
[SYSPRINT ] [ ]
Format 1
[display-file-name] or [SYSPRINT]
When you specify display-file-name, Easytrieve prints data to the named file. The named file should be
designated as a PRINTER file or unpredictable results can occur. If you do not specify display-file-name, the
default is SYSPRINT. SYSPRINT implies the system output device. The actual destination of SYSPRINT is
determined by the environment or a site option. For more information, see your system administrator.
[{TITLE|NOTITLE}]
The TITLE option specifies that a skip to a new page occurs before the data is printed. It also produces any titles
and headings if coded in a report procedure. If not coded in a report procedure, no titles are produced.
NOTITLE specifies that a skip to a new page occurs but titles and headings are not produced.
[SKIP skip-integer]
The SKIP skip-integer option specifies the number of lines skipped before printing data. When skip-integer is zero,
the current line being displayed overlays the previous line output to display-file-name.
[CONTROL 'carriage-control-character']
The CONTROL 'carriage-control-character' option sets the print carriage control character for the print line. Valid
alphanumeric values for 'carriage-control-character' are 0 to 9, +, -, A, B, or C. Depending on the make and model
of impact printer used, these characters select a precoded channel on a carriage control tape that determines
print line positions associated with the form to be printed.
When display-file-name is associated with an extended reporting printer, the printer must support ANSI or
machine carriage controls.
Note: This parameter is not valid for use in REPORT procedures.
[#font-number]
#font-number identifies the font that Easytrieve uses for the next display item. You can specify this option only if
display-file-name has been associated with an extended reporting printer. #font-number identifies the number of
a font defined for the extended reporting printer assigned to receive the print output. If you do not code the font
index, then the next display item uses the default font for the assigned extended reporting printer.
[field-name] or ['literal']
Code field-name or 'literal' in the order you want them to appear on the printed line.
Note: K fields are not valid on a DISPLAY statement.
[+offset] or [-offset]
Use the space adjustment options to add (+offset ) or subtract (-offset) horizontal line spaces preceding the next
display item.
Note: ±offset does not extend space beyond the left and right margin set points.
[COL column-number]
The COL column-number option specifies the absolute print column number on which Easytrieve begins to print
the next display item. Column-number can be any value that does not extend beyond the line margins.
Note: When using an extended reporting printer, an error occurs if two or more fields or literals overlap. For more
information, see the Programming Guide.
[POS position-number]
The POS position-number option coded in a DISPLAY statement within report procedures causes the next display
item to be left-justified under the corresponding position-number item in the LINE 01 statement.
Note: When using an extended reporting printer, an error occurs if two or more fields or literals overlap. For more
information, see the Programming Guide.
Format 2
889
Easytrieve® Report Generator 11.6
HEX {file-name} or HEX {field-name} or HEX {record-name}
Easytrieve produces a hexadecimal and character dump of the current file-name or field-name, whichever you
specify. For IDMS files, record-name refers to any record (segment); file-name refers to all records (segments).
Note: HEX file-name cannot be used in REPORT procedures.
Format 3
You can use this format of the DISPLAY statement only when display-file-name is associated with an extended reporting
printer. A syntax error occurs if display-file-name is not an extended reporting printer. For more information about
extended reporting, see the Programming Guide.
[CONTROL 'control-literal']
You can use the CONTROL parameter to output printer control records. 'Control-literal' can be an alphanumeric
or hexadecimal literal that Easytrieve outputs to the print file without paper control information. These control
cards contain instructions to extended reporting printers. Print control records for some printing systems define
the specification of the font sets that Easytrieve uses for a particular report. These control cards can be output to
the print data set before a report that uses the loaded font sets.
Examples
Format 1
The following example illustrates the use of Format 1 of the DISPLAY statement:
FILE BADKEYS FB(150 1800) TERMINAL
FILE PERSNL INDEXED
%PERSNL
FILE INKEYS
WHO * 5 N
JOB INPUT INKEYS NAME MYPROG
READ PERSNL KEY WHO STATUS
IF NOT PERSNL
DISPLAY BADKEYS 'BAD KEY =' +1 WHO
GOTO JOB
END-IF
When executed, the statements in this example produce the following output:
BAD KEY = 00973
Format 2
The following example illustrates the use of Format 2 of the DISPLAY statement:
FILE PERSNL INDEXED
%PERSNL
FILE INKEYS
WHO * 5 N
JOB INPUT INKEYS NAME MYPROG
READ PERSNL KEY WHO
DISPLAY SKIP 2 HEX PERSNL
When executed, the statements in this example produce the following output:
CHAR 104 G 01963 7ARNOLD LINDA 1569 COLONIAL TERR ANEW YORK NY10012 @ 911
890
Easytrieve® Report Generator 11.6
ZONE FFF21683FFFFF44FCDDDDC44DCDCC4444444FFFF4CDDDDCCD4ECDD4CDCE4EDDD4444DEFFFFF4444444444444403670450FFF
NUMR 1048327C019630071956340039541000000015690363659130359901556086920000581001200000000000000058C045C911
1...5...10...15...20...25...30...35...40...45...50...55...60...65...70...75...80...85...90...95..100
CHAR 082942 21245140401S 1001101968
ZONE 44FFFFFF44444444FFFFFFFFFFFE444FFFFFFFFFF444444444
NUMR 00082942000000002124514040120001001101968000000000
101...5...10...15...20...25...30...35...40...45...50
DLI Statement
The DLI statement in Easytrieve provides controlled input/output of an IMS/DLI database. This statement gives control
over the creation and maintenance of a database.
You can use the DLI statement in conjunction with (or independently of) the automatic input associated with RETRIEVE.
You can code the DLI statement at any place in a JOB activity that an input/output statement for any other file can be
coded. This statement provides complete control over the creation and maintenance of a database.
There are six different formats for the DLI statement:
Format 1
io record name function literal
{ - - } {' - ' }
file name
DLI - { } { } +
io field name function field name
{ - - } { - - }
search value literal
[ ] [ {' - - ' } ]
ssa number
[SSANO - ] [SSA { } ] ...
search value field name
[ ] [ { - - - } ]
Format 2
seg len literal
{CHKP} {' - - ' }
id field name
DLI { } { } - - +
seg len field name
{XRST} { - - - }
checkpoint len literal
[ {' - - ' } ]
checkpoint field name
[ { } - - ] ...
checkpoint len field name
[ { - - - } ]
Format 3
id field name
DLI CHKP - -
Format 4
file name
DLI - FOR ACCESS
Format 5
psb name literal
{' - - ' }
DLI PCB { }
psb name field name
{ - - - }
Format 6
DLI TERM
891
Easytrieve® Report Generator 11.6
This section describes the parameters for each of the six formats of the DLI statement.
Format 1
file-name
File-name identifies the database being processed. File-name is the same as the name coded on the FILE file-
name statement that identifies the DBD to be processed.
{io-record-name} or {io-field-name}
Io-record-name or io-field-name identifies the input/output area that is to receive the data. Io-record-name must
be the same as a corresponding segment-name coded on a RECORD statement. Io-field-name can only be a
working storage field. In either case, the area specified must be large enough to contain the longest segment
retrieved from the database.
{'function-literal'} or {function-field-name}
You can specify any IMS/DL/I function code whose parameter requirements conform to Format 1. The function
code can be specified as either an EBCDIC alphabetic literal ('function-literal') or an alphanumeric function-field-
name that contains a four-byte alphabetic code. Valid function codes (for example, GNP) are described in IBM's
IMS/DL/I Application Programming publications.
[SSANO ssa-number] or [SSA {'search-value-literal'}] or [SSA {search-value-field-name}]
Code the optional SSANO and SSA parameters when the database activity to be performed cannot be satisfied
without using segment search arguments. SSANO identifies a function-field-name that represents a four-byte
binary field. Function-field-name can be set dynamically to control the number of SSAs used in database system
calls. This value overrides the assumed number, which is equal to the count of SSA parameter entries.
The SSA parameter supplies segment search argument values. You can code the SSA values as search-value-
field-name or an alphabetic literal ('search-value-literal'). The SSA value must contain the segment search
argument in the exact form required by IMS/DL/I. If search-value-field-name contains DBCS data, the DBCS code
system of search-value-field-name must equal the DBCS code system of file-name.
Note: Multiple search value literals or search value field names must be enclosed in parentheses.
Format 2
Use Format 2 of the DLI statement to perform a symbolic checkpoint/restart. You must specify the compatibility option
(COMPAT=YES) for the PSB being processed; this option generates a dummy PCB that acts as an I/O PCB during
checkpoint/restart processing. Test CHKP-STATUS to determine the results of the call. For more information about CHKP-
STATUS, see "File Processing" in the Programming Guide. For more information about symbolic checkpoint/restart, see
IBM's IMS/DL/I Application Programming publications.
{CHKP} or {XRST}
Code CHKP to perform symbolic checkpoint or XRST to perform a symbolic restart.
{'seg-len-literal'} or {seg-len-field-name}
'Seg-len-literal' or seg-len-field-name specifies the length of the longest segment (or path of segments) in the
PSB. 'Seg-len-literal' must be a four-byte binary field.
[id-field-name]
Id-field-name must identify a 12-byte area in working storage. The first eight bytes of this area contain the
checkpoint ID. You should set the 12-byte area to spaces before performing the DLI XRST operation, then test it
after performing the operation. If your program is being started normally, the area will still contain spaces. If your
program is being restarted from a checkpoint, the area will contain the checkpoint ID that you supplied during the
DLI CHKP operation and in the restart JCL.
Optionally, you can also specify up to seven checkpoint areas in working storage that are saved during each
checkpoint and restored during a restart.
{'checkpoint-len-literal' } or {checkpoint-len-field-name}
'Checkpoint-len-literal' or checkpoint-len-field-name specifies the length of the checkpoint area defined by
checkpoint-field-name. Checkpoint-len-field-name must be a four-byte binary field.
892
Easytrieve® Report Generator 11.6
[checkpoint-field-name]
Checkpoint-field-name must identify a field in working storage. The length of this checkpoint area is specified by
checkpoint-len-field-name or 'checkpoint-len-literal'.
A checkpoint can be taken on a maximum of seven areas.
Format 3
Use Format 3 of the DLI statement to perform a basic checkpoint. For IMS, you must specify the compatibility option
(COMPAT=YES) for the PSB being processed; this option generates a dummy PCB that acts as an I/O PCB during
checkpoint processing. Test CHKP-STATUS to determine the results of the call. For more information of CHKP-STATUS,
see "File Processing" in the Programming Guide. For more information about basic checkpoints, see IBM's IMS/DL/I
Application Programming publications.
CHKP
CHKP causes a basic checkpoint to be performed.
id-field-name
Id-field-name must identify an 8-byte area in working storage. This area contains the checkpoint ID.
Format 4
Use Format 4 of the DLI statement when you are calling a subprogram (such as a COBOL program) that accesses DL/I
records. Coding this statement before referencing DLI fields causes the fields to become available for processing.
DLI file-name FOR ACCESS
File-name refers to an Easytrieve file definition containing the appropriate PCB field, record, and record field
definitions.
Format 5
Use Format 5 to schedule a PSB. Format 5 is used for CICS execution only. In other environments, it is ignored. Any
program that executes under CICS must schedule the PSB before accessing any PSB, including programs that are
accessing DL/I with the RETRIEVE statement. For activities that use the RETRIEVE statement, the PSB must be
scheduled in a JOB START proc, or in a previously-executed activity. When a PSB is scheduled, it stays scheduled until
one of the following occurs:
• Task termination
• Syncpoint
• Execution of the DLI TERM statement (see Format 6)
Test the UIBFCTR and UIBDLTR system-defined fields to determine the results of the operation. For more information
about scheduling PSBs and the values of UIBFCTR and UIBDLTR, see IBM's IMS/DL/I Application Programming
publications.
{'psb-name-literal'} or {sb-name-field-name}
'Psb-name-literal' or psb-name-field-name specifies the PSB to be scheduled. The maximum length of a PSB
name is eight bytes.
Format 6
Use Format 6 to terminate a PSB. Format 6 is used only for CICS execution. In other environments, it is ignored. Test
the UIBFCTR and UIBDLTR system-defined fields to determine the results of the operation. For more information about
scheduling PSBs and the values of UIBFCTR and UIBDLTR, see IBM's IMS/DL/I Application Programming publications.
DO UNTIL and DO WHILE Statements
Easytrieve 's loop control statements DO UNTIL, DO WHILE, and END-DO control and delimit repetitive program logic.
DO WHILE
893
Easytrieve® Report Generator 11.6
The truth value of the conditional expression determines whether statement-1 to statement-n are executed. Statement-1
... statement-n represents any number of Easytrieve statements. When the conditional expression is true, the statements
are executed and the program branches back to test the conditional expression. The program continues to loop as long
as the conditional expression is true. When the conditional expression is false, the program branches to the statement
following END-DO.
DO UNTIL
Statement-1 to statement-n are executed. The truth value of the conditional expression determines whether the group of
statements are executed again. When the conditional expression is true, the program branches to the statement following
the END-DO. When the conditional expression is false, the program branches back to execute the statements. The
program continues to loop until the conditional expression is true.
This statement has the following format:
{WHILE}
conditional expression
DO { } -
{UNTIL}
statement
-1
...
statement n
-
END-DO
The following diagram illustrates DO and END-DO statement logic:
894
Easytrieve® Report Generator 11.6
{WHILE} or {UNTIL}
A WHILE loop evaluates the condition at the top of a group of statements. An UNTIL loop evaluates the condition
at the bottom of a group of statements.
conditional-expression
Specify the condition that is the basis for the continuing execution of the loop. For conditional expression syntax,
see Conditional Expressions in "Statements A - C."
END-DO
END-DO terminates the body of the loop associated with the DO statement. An END-DO statement must be
specified after each DO statement and its associated statements.
Examples
DO UNTIL statement example:
FILE FILEA
ELEMENT 1 10 A OCCURS 10
CTR W 2 N
JOB INPUT FILEA
CTR = 1
895
Easytrieve® Report Generator 11.6
DO UNTIL CTR > 10
DISPLAY ELEMENT (CTR)
CTR = CTR + 1
END-DO
DO WHILE loop nesting example:
DEFINE COUNT-1 W 3 N VALUE 0
DEFINE COUNT-2 W 3 N VALUE 0
DEFINE RESULT W 3 N VALUE 0
*
JOB INPUT NULL NAME MYPROG
DO WHILE COUNT-1 LT 10
COUNT-1 = COUNT-1 + 1
COUNT-2 = 0
DO WHILE COUNT-2 < 10
COUNT-2 = COUNT-2 + 1
RESULT = COUNT-1 * COUNT-2
DISPLAY 'COUNT-1= ' COUNT-1 ' COUNT-2= ' COUNT-2 +
' RESULT= ' RESULT
END-DO
END-DO
STOP
ENDPAGE Report Procedure
The ENDPAGE procedure in Easytrieve produces page footing information.
An ENDPAGE procedure is invoked whenever end-of-page is detected.
An ENDPAGE procedure must be delimited by an END-PROC statement. For more information, see PROC Statement in
"Statements N - R."
This statement has the following format:
ENDPAGE. PROC
Example
ENDPAGE is typically used to produce page totals or other annotations, as in the following example of page footer
annotation:
FILE FILE1
LAST-NAME 1 5 A
STATE 6 2 A
ZIP 8 5 N
PAY-NET 13 5 N 2
JOB INPUT FILE1 NAME MYPROG
PRINT REPORT1
*
REPORT REPORT1 LINESIZE 65 +
SUMMARY SUMCTL DTLCOPY
SEQUENCE STATE ZIP LAST-NAME
CONTROL STATE NEWPAGE ZIP
896
Easytrieve® Report Generator 11.6
TITLE 'REPORT FOR THE STATE OF' STATE
LINE 01 LAST-NAME STATE ZIP PAY-NET
*
ENDPAGE. PROC
DISPLAY SKIP 2 '* CONFIDENTIAL - FOR INTERNAL USE ONLY *'
END-PROC
*
END-PROC Statement
The END-PROC statement in Easytrieve delimits statements in a procedure.
A procedure is a group of user-written Easytrieve statements designed to accomplish a particular objective.
For more information, see PROC Statement in "Statements N - R."
This statement has the following format:
END-PROC
ENDTABLE Statement
The ENDTABLE statement in Easytrieve delimits instream data used to create small tables.
ENDTABLE must be coded in the first eight positions of the source statement. The ninth position must be blank.
All data required to create an instream table file must be coded between the definition statements and the ENDTABLE
statement.
If the table data is to be stored in a macro, you must store the entire table definition from the FILE statement to the
ENDTABLE statement.
This statement has the following format:
ENDTABLE
Example
FILE DAYTABL TABLE INSTREAM
ARG 1 1 A. DESC 3 9 A
1 SUNDAY
2 MONDAY
...
7 SATURDAY
ENDTABLE
EXECUTE Statement
The EXECUTE statement in Easytrieve invokes a JOB, SORT, or SCREEN activity from either a PROGRAM or
SCREEN activity.
The EXECUTE statement transfers control to an activity. After the activity is executed, control returns to the next
executable statement following the EXECUTE. You cannot invoke a JOB, SORT, or SCREEN activity in a JOB or SORT
activity.
897
Easytrieve® Report Generator 11.6
EXECUTE statements in a SCREEN activity can invoke other activities. This is called activity nesting. However, recursion
is not permitted. That is, activity A can EXECUTE activity B, but activity B cannot then EXECUTE activity A.
NOTE
Recursion cannot be detected in the program. If it is attempted, unpredictable results can occur.
You can use the EXECUTE statement to invoke multiple stacked windows from a SCREEN activity. When each stacked
window terminates with an EXIT, the full screen image is restored to the screen image that existed before the EXECUTE.
An EXIT from the primary screen does not restore the screen.
This statement has the following format:
job-name sort-name screen-name
EXECUTE { | | }
{job-name|sort-name|screen-name}
Identifies the JOB, SORT, or SCREEN activity to be executed.
Example
PARM-FIELD W 5 A
PROGRAM NAME SAMPLE-PROGRAM USING PARM-FIELD
IF PARM-FIELD = 'DAILY'
EXECUTE DAILY-JOB
ELSE
EXECUTE WEEKLY-JOB
END-IF
JOB NAME DAILY-JOB
. . .
JOB NAME WEEKLY-JOB
EXIT Statement
The EXIT statement in Easytrieve terminates a SCREEN activity.
When an EXIT statement is encountered and the SCREEN activity was invoked from a PROGRAM or SCREEN activity,
control is returned to the statement following the EXECUTE statement.
If a SCREEN activity was invoked by an implied PROGRAM activity, EXIT terminates the program.
EXIT is a branch action that can be invoked directly by pressing a particular attention key. For more information, see KEY
Statement in "Statements G - M."
This statement has the following format:
EXIT
Example
SCREEN NAME MENU
KEY F3
...
AFTER-SCREEN. PROC
IF KEY-PRESSED = F3
EXIT
END-IF
898
Easytrieve® Report Generator 11.6
END-PROC
FETCH Statement
The FETCH statement in Easytrieve retrieves rows from an SQL file.
The FETCH statement retrieves rows from the open cursor and places the data in the file's data area. If the file does not
have an open cursor associated with it, the cursor previously selected is reopened. If no cursor was previously selected,
the default cursor (SELECT all defined fields FROM table) is opened.
You cannot use controlled statements (SELECT, FETCH, CLOSE) in a SORT or REPORT procedure.
The FETCH statement cannot reference an automatic input file in the same JOB activity. You can FETCH from a file other
than the automatic input file.
This statement has the following format:
file name
FETCH [FROM] -
[FROM]
Optionally, code FROM for statement readability.
file-name
File-name is the name of an Easytrieve SQL file.
Example
Following is an example of a PROGRAM activity that uses a default cursor:
FILE PERSNL SQL (PERSONNEL)
EMPNAME * 20 A
WORKDEPT * 2 P 0
PROGRAM NAME RETRIEVE-PERSONNEL
FETCH FROM PERSNL
DO UNTIL EOF PERSNL
DISPLAY EMPNAME +2 WORKDEPT
FETCH FROM PERSNL
END-DO
The above PROGRAM activity simply fetches each row of the table and displays the fields. The DO loop repeats the
process until end-of-file.
FILE Statement
The FILE statement in Easytrieve describes files that your program references. Access SQL, IDMS, and IMS/DL/I
databases using Easytrieve files.
Code FILE statements at the beginning of a program after the PARM statement, if one is used. Not all parameters are
necessary (or valid) for describing any one file. A review of all parameters will quickly indicate those required for any
particular file.
Code the optional parameters and subparameters of the FILE statement in any order following the file name. As shown,
you must code multiple subparameters within parentheses. The complete syntax of the FILE statement is shown below.
To maintain compatibility of programs using VSAM files that were written in prior versions of the product, Easytrieve
supports FILE statements containing VS and its related keywords (as follows):
file name literal
FILE - VS ([ES] [F] [PASSWORD ' '] +
899
Easytrieve® Report Generator 11.6
CREATE [RESET|UPDATE] [NOVERIFY]
For more information about using the FILE statement, see the Programming section.
This statement has the following format:
FILE filename +
[SEQUENTIAL [CREATE [RESET]] ] }
[INDEXED [UPDATE ] ] + }
[RELATIVE ] }
owner name table name correlation name
[SQL ([ - .] - [ - ]{,}...) ] } File
subschema name
[IDMS ( - [RESET]) ] } Type
relative position
[ { - } ] }
[DLI ({ }[RESET]) ] }
dbd name relative occurrence
[ { - [ - ]} ] }
password literal
[ {' - ' } ]
[PASSWORD { } ] +
password field name
[ { - - } ]
[NOVERIFY] +
parm literal
[ [ { - } ] ]
program name
[EXIT ( - [USING ( { } ...) ] [MODIFY]) ] +
parm field name
[ [ { - - } ] ]
[CARD ] }
[PUNCH ] } Device
line page size display page size
[PRINTER [([PAGESIZE ( - - [ - - ]) + ] } Type
line length
[ [LINESIZE - ])] ] }
record length
[F [ - ] ] }
[ ] }
record length
[V [ - ] ] }
[ ] }
block length
[ [ - ] ] }
[U [FULLTRK ] ] }
[ ] }
record length block length
[FB [ ( - [ - ] ) ] + } Record
[ [ [FULLTRK ] ] ] } Format
[ ] }
record length block length
[VB [ ( - [ - ] ) ] ] }
[ [ [FULLTRK ] ] ] }
[ }
record length block length
[VBS [ ( - [ - ] ) ] ] }
[ [ [FULLTRK ] ] ] }
area length
[WORKAREA - ] +
[ [INSTREAM ] ]
[TABLE [ ] ] +
max table entries
[ [ - - ] ]
900
Easytrieve® Report Generator 11.6
buffers
[BUFNO ] +
[DEFER] +
[ASA] +
xrpt printer
[EXTENDED - ] +
dbcs code name
[CODE {EBCDIC|ASCII| - - }] +
key field name
[KEY - - ] +
file identifier
[ {' - ' } ] }
[SYSNAME { } ] }
file identifier field name
[ { - - - } ] }
[ ] }
[ [MEMORY] ] }
[VIRTUAL ([RETAIN] [DISK ] ) ] }
[ ] }
terminal id literal
[ [ {' - - ' } ] ] }
[TERMINAL ([ID { } ] + ] }
terminal id field name
[ [ { - - - } ] ] }
[ ] }
[ [NOFORMFEED] + ] }
[ ] }
[ [ [BEFORE] ] ] } Data
[ [NEWPAGE [AFTER ] ]... ) ] } Set
[ ] } Type
spool class literal
[ [ {' - - ' } ] ] }
[SPOOL ( [CLASS { } ] + ] }
spool class field name
[ [ { - - - } ] ] }
[ ] }
destination literal
[ [ {' - ' } ] ] }
[ [NODE { } ] + ] }
destination field name
[ [ { - - } ] ] }
[ ] }
user id literal
[ [ {' - - ' } ] ] }
[ [USERID { } ] ) ] }
user id field name
[ [ { - - - } ] ] }
file-name (return to top)
File-name is a 1- to 128-character name used to define the file to Easytrieve . All statements that operate on the
file refer to this name. Every FILE statement must have a file-name immediately following the FILE keyword. File-
names must be unique in the program (that is, you can use a given file-name for only one file). The first three
characters of file-name must be different from the value of the work data set name prefix specified in the Site
Options Table (normally EZT).
For the relationship between a FILE statement and an external data set, see the SYSNAME parameter under
Data Set Types in this article.
File Types
Easytrieve processes all standard file types available in the operating environment. On a mainframe, this includes QSAM
(Queued Sequential Access Method); VSAM (Virtual Storage Access Method); SQL; printer files directed to an online
printer, terminal, or the operating system spooling subsystem (JES2 or JES3 in z/OS and POWER in VSE); IDMS and
IMS/DL/I database files; and the Easytrieve Virtual File Manager (VFM). On non-mainframe platforms, these include fixed
901
Easytrieve® Report Generator 11.6
length sequential, variable length sequential (new-line delimited), indexed, relative, VFM, and SQL database files. If you
do not specify a file type, the file is assumed to be sequential.
[SEQUENTIAL] (return to top)
SEQUENTIAL designates a QSAM or VSAM Entry Sequenced Data Set (ESDS) on a mainframe. On other
platforms, the file can be a fixed length or a variable length (new-line delimited) file. SEQUENTIAL is the default
file type if a file type is not specified.
Note: When SEQUENTIAL is specified, FILE-STATUS (a system-defined field) is available for the file.
[INDEXED] (return to top)
INDEXED designates a VSAM Key Sequenced Data Set (KSDS) or an ISAM file on a non-mainframe platform.
[RELATIVE] (return to top)
RELATIVE designates a mainframe VSAM Relative Record Data Set (RRDS), or a relative file on non-mainframe
platforms.
[SQL] ([owner-name.] table-name [correlation-name] {,} ...) (return to top)
The SQL parameter designates an SQL file. This parameter enables the product to manage the SQL cursor.
NOTE
• Only UPDATE, DEFER, and CODE are valid FILE statement parameters for an SQL file.
Table-name is the name of the SQL table to be accessed. Optionally, qualify the table with owner-
name. Table-name must be enclosed in parentheses.
Correlation-name is the name used to clarify or simplify the table to which a column belongs. If you
specify owner-name and your DBMS does not permit more than one level of qualification (IDMS,
Ingres, or Oracle), you should code a correlation-name for each table.
• The comma is a required separator.
When you specify SQL, the file can be used as the subject of either automatic input or controlled
processing using the SELECT, FETCH, CLOSE, INSERT, UPDATE, and DELETE statements. These
statements support full read-write access to the tables but you do not have to declare, open, and
close cursors to manage the tables. Multiple tables for a single file are joined for inquiry only.
[IDMS (subschema-name [RESET]) (return to top)
IDMS designates the file as an IDMS database file.
Subschema-name is a one- to eight-character name that specifies the subschema to be processed.
The optional RESET subparameter requests that all records under control of RETRIEVE be reset to binary zero
immediately prior to retrieving each root record.
When the first IDMS FILE statement is encountered, an IDMS Communications Block is created in working
storage.
For more information about IDMS processing, see the IDMS Database Processing section.
Note: Fields cannot be defined in association with the IDMS FILE statement. Fields are defined following the
RECORD or ELEMENT-RECORD statement.
DLI ({relative-position} [RESET]) or DLI ({dbd-name[relative-occurrence]} [RESET]) (return to
top)
(Mainframe only) DLI designates the file as an IMS/DL/I database file.
Relative-position is a positive numeric literal that identifies the relative position of the PCB within the PSB to be
processed.
Dbd-name specifies the name of the DBD. Relative-occurrence is the relative occurrence of like-name DBDs in
the PSB. It is required only if two or more DBDs have the same name.
The optional RESET subparameter requests that all records under control of RETRIEVE be reset to binary zero
immediately prior to retrieving each root record.
For more information, see IMS/DL/I Database Processing.
[CREATE [RESET]] (return to top)
Use CREATE to load the associated file.
902
Easytrieve® Report Generator 11.6
(Mainframe only) If you specify RESET, Easytrieve overwrites an existing data set with the REUSE attribute. If
RESET is not specified, or if RESET is specified and the associated VSAM data set does not have the REUSE
attribute, then Easytrieve receives an error condition when the OPEN is executed.
Note: In CICS, the use of RESET results in an execution error.
(Non-mainframe platforms only) If you specify RESET, Easytrieve deletes an existing data set before creation or
instructs the access method to overwrite the file. If RESET is not specified, new records are appended.
[UPDATE] (return to top)
Use UPDATE to permit the file to be updated.
For SQL, code UPDATE to specify that all columns defined for the file can be updated. If you do not specify
UPDATE for an SQL file, only those columns defined with the UPDATE parameter can be updated. UPDATE is
required to DELETE from or INSERT to an SQL file.
Note: You must have UPDATE, INSERT, or DELETE authorization for the SQL table that this file references.
[PASSWORD {'password-literal'}] or [PASSWORD {password-field-name}] (return to top)
'Password-literal' is the optional password for the file. You can specify the password as an alphabetic literal or a
hexadecimal quoted literal.
Password-field-name is a field you define that contains the password for the file. Easytrieve accesses the value
in password-field-name when the file is opened. Any valid password is accepted.
[NOVERIFY] (return to top)
Code NOVERIFY to ignore a VSAM open error code of 116(X'74'). This error indicates that a previous job
terminated without properly closing the associated VSAM data set. It could also indicate that a job executing on
another CPU is using the associated VSAM data set.
WARNING
Indiscriminate use of NOVERIFY can cause loss of data records.
[EXIT]
EXIT invokes a user-written program for each Easytrieve operation on the file. EXIT is not valid for VFM, SQL,
DL/I, or IDMS.
program-name
Specify the name of the user program.
[USING {parm-literal}] or [USING {parm-field-name}]
USING appends the associated parameters (parm-literal or parm-field-name) to the standard parameter
list passed to the exit program. Field names must be working storage or system-defined fields and must
be defined in the library section. There is a limit of 62 fields that can be passed to the exit program.
[MODIFY]
MODIFY specifies that Easytrieve provides input or output services, but that the exit can inspect and
modify each record after input and before output.
Device Types
The optional parameters CARD, PUNCH, and PRINTER specify the device type for SEQUENTIAL files. For MVS, if you
do not specify one of these parameters, the device type is determined by your JCL.
[CARD] (return to top)
(TSO and CMS usage) The CARD option retrieves the file data from the system input stream (SYSIN). Only one
file in an Easytrieve execution can use the CARD option. Files using this option must be 80-character unblocked
records.
Note: In TSO and CMS, you cannot use a CARD file if you want to execute your program interpretively.
(Non-mainframe platform usage) The CARD option indicates the file is stdin. It is treated as a variable length file
(new-line delimited) with a maximum record length of 256.
903
Easytrieve® Report Generator 11.6
[PUNCH] (return to top)
(TSO and CMS only) The PUNCH option indicates punched card output. Files created with this option are 80-
character unblocked records.
[PRINTER] (return to top)
PRINTER indicates that the file receives printed output routed to a file, an online printer, a terminal, or a
subsystem (JES/POWER) data set. Although normal input/output statements (GET, PUT, READ, WRITE) cannot
reference PRINTER files, the DISPLAY statement and the PRINTER parameter of the REPORT statement can
reference PRINTER files.
[PAGESIZE (line-page-size [display-page-size])
Specify PAGESIZE to define the logical print length of a printed page. For complete rules for specifying
PAGESIZE, see REPORT - Statement.
[LINESIZE line-length]
Code the LINESIZE parameter to specify the maximum number of data characters that can be printed on
a line. Line-length must be an unsigned integer from 1 to 32767.
Line-length must be at least one less than the length of the data portion of the file's logical record. If
the FILE definition does not provide the file's format and logical record length, then no compile time
verification of the line-length is done.
Line-length provides the default value for any REPORT specifying this file as its PRINTER file.
The default value of LINESIZE is calculated as one less than the data portion of the logical record if
the file format and record length are known at compile time. Otherwise, the default is taken from the
LINESIZE site option.
There are additional control characters (forms control information) that also must be stored in a logical
record. If one of the record format parameters is specified, it must be large enough to hold both the forms
control information and the data characters. The value of line-length must be less than or equal to the
maximum record length minus the size of the forms control information.
Record Format (return to top)
You can optionally code the record format of non-VSAM files for z/OS programs. If you do not code a record
format in z/OS, Easytrieve obtains it from the operating system when the file is opened. For input files,
Easytrieve always obtains the record format from z/OS. The record format and length are required for VSE and
non-mainframe FILE statements.
record length
[F [ - ] ]
[ ]
record length
[V [ - ] ]
[ ]
block length
[U [ - ] ]
[ [FULLTRK ] ]
[ ]
record length block length
[FB [ ( - [ - ] ) ] ]
[ [ [FULLTRK ] ] ]
[ ]
record length block length
[VB [ ( - [ - ] ) ] ]
[ [ [FULLTRK ] ] ]
[ ]
record length block length
[VBS [ ( - [ - ] ) ] ]
[ [ [FULLTRK ] ] ]
Easytrieve supports fixed (F), variable (V), and undefined (U) formats. Fixed and variable length records can be
blocked (FB,VB), though the blocking factor is ignored on non-mainframe platforms.
[VBS] (return to top)
(z/OS only) z/OS systems can process Variable Block Spanned (VBS) records using BFTEK=A
processing.
904
Easytrieve® Report Generator 11.6
[record-length] (return to top)
Record-length specifies the maximum record length.
[block-length] (return to top)
Block-length specifies the file's maximum block length.
For mainframe variable format files, allow four bytes of the record length for the Record Description Word
(RDW) and, if the file is blocked, four bytes of the block size for the Block Description Word (BDW).
NOTE
To obtain an MVS/DFP system determined block size within Easytrieve on the mainframe, do
one of the following:
• Include the DSORG, LRECL and RECFM parameters in the original JCL or TSO dynamic
allocation. This forces SMS to establish the block size before Easytrieve gets control in
OPEN processing. This is applicable for disk data sets only.
• Define a value of zero for the block length value. If you want Easytrieve to pick up the
logical record length from your JCL, code a zero for record-length. You must also code a
BLKSIZE=0 in your JCL or code no BLKSIZE parameter at all.
Examples
file name
FILE - FB(0 0)
This tells Easytrieve to pick up the LRECL from the JCL and to utilize the block size set by SMS.
file name
FILE - FB(150 0)
This tells Easytrieve to pick up the LRECL from this definition and to utilize the block size set by SMS.
file name
FILE - FB(150 3000)
This tells Easytrieve to pick up this definition and ignore both the JCL and the SMS-determined block size.
NOTE
If you code a zero block size within Easytrieve or in your JCL, and your data set is not SMS managed,
your program will abend with a 013 open problem.
[FULLTRK] (return to top)
A block length designation of FULLTRK establishes an output block size that equals the maximum track capacity
of the direct access device, or the next lower multiple of record size for FB files.
[WORKAREA area-length] (return to top)
The WORKAREA option establishes the number of bytes to be allocated as a work area for the file. WORKAREA
cannot be coded if the CARD parameter is specified. Area-length specifies the number of bytes to be allocated
and must be large enough to contain the longest record processed.
WORKAREA allows you to reference the fields in a file prior to the normal allocation of a file's data buffer. For
more information, see File Processing.
Note: WORKAREAs are not initialized by Easytrieve .
[TABLE] (return to top)
The TABLE option declares the file as the source for a SEARCH statement to access a table.
NOTE
VARYING length fields cannot be used for TABLE files.
[INSTREAM] or [max-table-entries]
The INSTREAM option indicates that the table file immediately follows the file description. The size of an
INSTREAM table is limited only by the amount of available memory. Max-table-entries specifies the maximum
number of entries in an external table. If INSTREAM or max-table-entries is not specified, the file is an external
table whose maximum number of entries is limited by the site option TBLMAX.
905
Easytrieve® Report Generator 11.6
[BUFNO buffers] (return to top)
BUFNO establishes the number of buffers allocated for the file. Buffers can be 1 to 255 for MVS programs. The
default value is obtained from the Site Options Table.
[DEFER] (return to top)
Coding the DEFER option instructs Easytrieve to delay the opening of the file until the first input or output
operation for the file occurs. The default opens all referenced files at the beginning of each Easytrieve activity.
[ASA] (return to top)
For MVS, the optional ASA parameter sets the DCB A option for RECFM.
For non-mainframe platforms, the optional ASA parameter causes output records to be written using the set of
mainframe ASA characters in column one. Without ASA, all records are formatted using ASCII printer control
characters.
[EXTENDED xrpt-printer] (return to top)
The EXTENDED parameter indicates that the file is to be associated with an extended reporting printer. This
means that input/output statements (GET, PUT, READ, WRITE) cannot reference these printer files. However, the
DISPLAY statement and REPORT statements can reference these printer files. Unless you code them, record
length and block size default to those defined for the printer in the printer set definition module.
Xrpt-printer identifies the extended reporting printer whose characteristics are to be associated with this file. You
must define the xrpt-printer in the printer set definition module.
For more information, see Extended Reporting and the Programming section.
[CODE {EBCDIC|ASCII|dbcs-code-name}] (Mainframe only) (return to top)
Use CODE dbcs-code-name to define the DBCS code system to be used for all K and M fields for this file. If this
is not specified, the default is taken from the CODE parameter on the PARM statement for this program. If the
CODE parameter is not specified on the PARM statement, then the default is taken from the processing code
system as defined in the CA-PSI Subsystems DBCS Options table.
[KEY key-field-name] (return to top)
Use the KEY parameter to specify the key field for your non-mainframe ISAM file. Easytrieve uses this
parameter only when the file is created. After the file is created, this parameter is ignored and key information is
obtained from the access method. If KEY is not specified during creation, the first field defined in the file is used
as the key field.
Data Set Types
SYSNAME {'file-identifier'} or SYSNAME {file-identifier-field-name} (return to top)
Code SYSNAME to associate an Easytrieve file with an external data set.
file-identifier
Must be an alphanumeric string.
file-identifier-field-name
Must be defined as an alphanumeric field of the required length.
The value of file-identifier-field-name is accessed when the file is opened. The required length and the set
of valid characters depend on the file type, the implementation, and the operating system.
NOTE
If SYSNAME is not specified, the file-name specified after the FILE keyword is used. The length
of file-name must conform to operating system standards.
For CICS:
For file types SEQUENTIAL, INDEXED, and RELATIVE, this is the FCT name of the associated
VSAM data set. The requirements for the format of the file-identifier character string are the same as
the requirements for the FCT name. If fewer than eight characters are provided, the value is padded
with blanks on the right to obtain a string of eight characters. File-identifier-field-name must be an
alphanumeric field of any format. Only uppercase alphabetic and numeric digits are allowed. The first
906
Easytrieve® Report Generator 11.6
character must not be a digit. If File-identifier-field-name is defined with a length greater than eight, the
FCT name must reside in the first 8 (or less) bytes with the remainder set to blanks.
For device type PRINTER, the SYSNAME parameter cannot be used. An execution error occurs.
For TSO:
For file types SEQUENTIAL, INDEXED, and RELATIVE, and device type PRINTER, this is the DDname
of the associated data set. The requirements for the format of the file-identifier character string are the
same as the requirements for the DDname. If fewer than eight characters are provided, the value is
padded with blanks on the right to obtain a string of eight characters. File-identifier-field-name must be
an alphanumeric field of any format. Only uppercase alphabetic and numeric digits are allowed. The first
character must not be a digit. If File-identifier-field-name is defined with a length greater than eight, the
DDname must reside in the first 8 (or less) bytes with the remainder set to blanks.
For data set type VIRTUAL, the SYSNAME parameter is ignored.
For CMS:
For file types SEQUENTIAL, INDEXED, and RELATIVE, and device type PRINTER, this is the FILEDEF
or DLBL name of the associated data set. The requirements for the format of the file-identifier character
string are the same as the requirements for the FILEDEF or DLBL. If fewer than eight characters are
provided, the value is padded with blanks on the right to obtain a string of eight characters. File-identifier-
field-name must be an alphanumeric field of any format. Only uppercase alphabetic and numeric
digits are allowed. The first character must not be a digit. If File-identifier-field-name is defined with a
length greater than eight, the FILEDEF or DLBL name must reside in the first 8 (or less) bytes with the
remainder set to blanks.
For non-mainframe platforms:
For SEQUENTIAL, INDEXED, and RELATIVE file types and the PRINTER device type, SYSNAME
is either a file description string or an environment variable specifying the file description string. If the
value of SYSNAME contains a path separator (/ or \), it is treated as a file description string. If it does not
contain a path separator, Easytrieve searches for an environment variable with the same name. If such a
variable is found, the value of the variable is used as the file description string. If the variable is not found,
the SYSNAME value is used as the path.
For more information about the file description string, see File Description String (Non-Mainframe Only).
The length of SYSNAME is limited to the lesser of 256 characters or the maximum path length supported
by your operating system.
[VIRTUAL] (return to top)
VIRTUAL identifies a file as an Easytrieve Virtual File Manager (VFM) file. Easytrieve virtual files are temporary
sequential work files that are normally deleted after the file is read and closed.
[RETAIN]
RETAIN inhibits the automatic deletion of a VFM file after it is read. The file is deleted if it is opened for
OUTPUT or CREATE in a subsequent JOB activity or at program termination.
[MEMORY] or [DISK]
MEMORY and DISK indicate the type of CICS temporary storage that Easytrieve is to use for storing this
file. MEMORY indicates a main storage resident temporary storage queue in CICS. DISK indicates an
auxiliary storage resident temporary storage queue. DISK is the default.
[TERMINAL] (return to top)
Code the TERMINAL parameter to route the output for this printer file to an online terminal. The TERMINAL
parameter is mutually exclusive with the SPOOL, VIRTUAL, and SYSNAME parameters.
A device type of PRINTER is implied.
[ID {'terminal-id-literal'}] or [ID {terminal-id-field-name}] (CICS only)
Specify the name of the destination terminal in 'terminal-id-literal' or terminal-id-field-name. This terminal
can be either a display terminal or an online printer. Any valid terminal ID is accepted.
When ID is not specified, output directed to this file is spooled until the file is closed. The output can then
be browsed at the originating terminal using the Report Display Facility. You can also then print the file.
907
Easytrieve® Report Generator 11.6
[NOFORMFEED]
Code NOFORMFEED to indicate that the form feed character cannot be used to start a new page. If
NOFORMFEED is not specified, then Easytrieve can use the form feed character to start a new page.
NEWPAGE [BEFORE] or NEWPAGE [AFTER]
Code NEWPAGE to eject the page each time the file is opened and each time it is closed. Specify
NEWPAGE BEFORE to eject the page each time the file is opened. Specify NEWPAGE AFTER to eject
the page each time the file is closed.
If NEWPAGE is not specified, Easytrieve does nothing to position the page.
[SPOOL] (return to top)
Code the SPOOL parameter to route the output for this printer file to the operating system spooling subsystem.
The SPOOL parameter is mutually exclusive with the VIRTUAL, TERMINAL and SYSNAME parameters. In CMS,
the printer device must be spooled to RSCS. SPOOL is ignored in non-mainframe platforms.
A device type of PRINTER is implied.
CLASS {'spool-class-literal'} or CLASS {spool-class-field-name}
Code CLASS to specify the spool class for the file. CLASS can be specified as a literal or as a field name.
Any valid class is accepted.
The default is CLASS A.
NODE {'destination-literal'} or NODE {destination-field-name}
Code NODE to specify the destination for the file. This destination is usually a local or remote printer
device name or a network node name, but can be anything meaningful to the operating system spooling
subsystem.
NODE can be specified as a literal or as a field name. Any valid node is accepted.
Note: If NODE is not specified, the destination for the file is not passed to the operating system spooling
subsystem.
USERID {'user-id-literal'} or USERID {user-id-field-name}
Code USERID to specify the user of the printed output. The NODE subparameter must also be specified
and must contain a network node name.
USERID can be specified as a literal or as a field name. Any valid user ID is accepted.
Note: If the USERID subparameter is not specified, the user ID is not passed to the operating system
spooling subsystem.
For mainframe tape files, if no BLKSIZE is explicitly specified on the FILE statement or in the JCL, the SAM Large Block
Interface (LBI) is used. This allows block sizes larger than 32760 for tape files.
Examples
The following examples illustrate FILE statements for various files.
Sequential (SAM) Files in z/OS
To define a sequential (SAM) file in z/OS, use:
FILE SEQFILE
Entry-sequenced, Fixed-length VSAM Files
To load an entry-sequenced, fixed-length VSAM file, use:
FILE ENTSEQ SEQUENTIAL F CREATE RESET
Virtual Files with RETAIN
To define a virtual file with RETAIN, use:
FILE VRTFILE V(200) +
VIRTUAL RETAIN
908
Easytrieve® Report Generator 11.6
Printer Files to Be Viewed at the Terminal
To define a printer file to be viewed at the terminal, use:
FILE PRTFILE PRINTER (PAGESIZE 20 LINESIZE 80) +
TERMINAL
GET Statement
The GET Statement in Easytrieve places the next or previous sequential record of the named file into the file's record
buffer.
To ensure record availability when using the GET statement, you must test for end-of-file (EOF) or file presence (IF file-
name). If you specify GET PRIOR, an EOF means you have reached the beginning of the file.
When you reverse the direction of a GET statement by using GET PRIOR, the record returned is the record immediately
preceding the record previously placed in the file's record buffer. When you reverse the direction of a GET PRIOR
statement by using only GET, the record returned is the record immediately following the record previously placed in the
field's record buffer.
You cannot issue a GET PRIOR statement following a POINT statement, or a GET statement following a POINT PRIOR
statement. For more information, see POINT Statement in "Statements N - R."
You cannot use GET for a file designated as automatic input. To inhibit automatic input, specify INPUT NULL on the JOB
statement:
JOB INPUT NULL
You can use GET to access a secondary file while automatically accessing a primary file.
This statement has the following format:
[HOLD ]
file name
GET - [PRIOR] [ ] [STATUS]
[OHOLD ]
file-name
File-name identifies the input file defined in the library section. File-name can be any file type except SQL.
[PRIOR]
Specify PRIOR to place the previous sequential record of the named file into the file's record buffer. If you specify
PRIOR and the position in the file is not established, the last record in the file is placed in the file's record buffer.
Note: If the access method of the operating system does not support retrieval of previous records, an execution
error occurs.
[HOLD] or [NOHOLD]
Except in CICS, Easytrieve automatically issues a hold request for records when UPDATE is specified on the
FILE statement. Use NOHOLD to override this process. In CICS, NOHOLD is the default.
Specify HOLD to hold a record for update. HOLD is invalid if UPDATE is not specified on the FILE statement.
HOLD does not mean you are required to perform the update; it holds the position in the file. Records are
automatically released when the update operation completes or a commit point is taken. You can also manually
release the hold on any record with the RELEASE statement.
NOHOLD specifies that a record is not to be held for update.
NOTE
In CICS, if you specify HOLD, you cannot browse (GET) a file; an execution error occurs. When you
want to update a record, use the READ statement.
909
Easytrieve® Report Generator 11.6
[STATUS]
Specify STATUS whenever the possibility exists for an unsatisfactory completion of the input/output request.
STATUS checks input/output processing to see if it was performed properly. STATUS causes the file's FILE-
STATUS field to be set with the appropriate return code. For information about how to determine the meaning of
the contents of FILE-STATUS, see the appendix "System-Defined Fields." Normally, a zero or non-zero test is
sufficient.
NOTE
FILE-STATUS is not defined if you do not specify a file type parameter on the FILE statement.
If you do not code STATUS and the operating system returns a non-zero status, Easytrieve issues an
appropriate diagnostic message.
Examples
The following code illustrates the use of the GET statement:
FILE PERSNL INDEXED
%PERSNL
PROGRAM NAME MYPROG GET PERSNL STATUS
IF PERSNL:FILE-STATUS NE 0
DISPLAY PERSNL:FILE-STATUS
ELSE
DISPLAY HEX PERSNL
END-IF
The following code illustrates testing for EOF when using the GET statement:
FILE MASTER
... GET MASTER
IF EOF MASTER
STOP
END-IF
...
GOTO Statement
The GOTO statement in Easytrieve modifies the natural top to bottom logic flow of statement execution.
The GOTO statement has the following format:
label
{GOTO } { }
{ } {JOB }
{GO TO} {SCREEN}
{label}
Specify label to immediately transfer execution control to the first statement following the associated label.
Processing then continues in a top-to-bottom sequence. The label must be contained in the same activity or
procedure. A label:
910
Easytrieve® Report Generator 11.6
• Can be up to 128 alphanumeric characters in length
• Can contain any character other than a delimiter
• Can begin with A to Z, 0 to 9, or a national character (#, @, $)
• Must not consist of all numeric characters.
A statement label is a complete Easytrieve statement that you can code before the following statements:
911
Easytrieve® Report Generator 11.6
• Assignment
• CASE
• COMMIT
• DELETE
• DLI
• END-DO
• END-PROC
• EXIT
• GET
• IDMS
• INSERT
• MOVE
• PERFORM
• PRINT
• READ
• RELEASE
• ROLLBACK
• SELECT (except non-file SQL)
• SQL
• STOP
• UPDATE
• CALL
• CLOSE
• CURSOR
• DISPLAY
• DO
• END-IF
• EXECUTE
• FETCH
• GOTO
• IF
• MESSAGE
• MOVE LIKE
• POINT
• PUT
• REFRESH
• RESHOW
• SEARCH
• SET
• Statement label
• TRANSFER
• WRITE
{JOB}
GOTO JOB causes an immediate branch to the top of the current JOB activity. It does not include execution of the
START procedure. When used in a START procedure, GOTO JOB terminates the START procedure. When used
in a FINISH procedure, GOTO JOB terminates the FINISH procedure.
912
Easytrieve® Report Generator 11.6
{SCREEN}
GOTO SCREEN branches immediately to the top of the current SCREEN activity, including execution of the
BEFORE-SCREEN procedure. It does not include execution of the INITIATION procedure. When used in an
INITIATION procedure, GOTO SCREEN terminates the INITIATION procedure.
GOTO SCREEN cannot be coded in a BEFORE-SCREEN procedure. If GOTO SCREEN is coded in a
TERMINATION procedure, GOTO SCREEN terminates the screen activity.
Example
The following example illustrates the use of GOTO in a program. The arrows indicate that control is passed to the first
executable statement following the label or job statement.
HEADING Statement
The HEADING statement in Easytrieve defines an alternative heading for a field. Using the HEADING statement in a
report allows you to override the default field headings for that report.
The HEADING statement overrides default field headings defined in the library section. The HEADING statement also
provides alternative heading capabilities for system-defined fields such as TALLY and LEVEL.
This statement has the following format:
field name font number heading literal
HEADING - ([# - ] ' - '...)
field-name
For reports, field-name specifies a field in your program. The heading you define is used for fields identified on
LINE 01 of your report declaration.
913
Easytrieve® Report Generator 11.6
[#font-number]
#Font-number defines the number of a font that Easytrieve uses to format 'heading-literal' in the heading area of
a report. You can only specify #font-number if you direct the report to an extended reporting printer. If you direct
the report to a normal printer, a syntax error occurs when you code #font-number. You can specify a unique font
index for each 'heading-literal' by coding the # sign and a value for #font-number before 'heading-literal'. Any
'heading-literal' that does not have a font index assigned uses the default font for the assigned extended reporting
printer.
'heading-literal'
'Heading-literal' can be up to 128 characters in length.
For reports, a single line of alphanumeric text replaces the default header and prints as a header over a column
or field. Multiple literals, each enclosed within single quotes ('') and separated by one or more blanks within the
parentheses, are stacked vertically over the column or field when printed.
Examples
The following example illustrates various report heading options:
Statements:
FILE PERSNL FB(150 1800)
SSN 4 5 P MASK '999-99-9999' + HEADING('SOCIAL' 'SECURITY' 'NUMBER')
EMPNAME 17 20 A
NAME-LAST EMPNAME 8 A
NAME-FIRST EMPNAME +8 12 A
PAY-NET 90 4 P 2
JOB INPUT PERSNL NAME MYPROG
PRINT REPORT1
*
REPORT REPORT1 LINESIZE 65 HEADING PAY-NET ('NET', 'PAY')
LINE EMPNAME SSN '* NO OVERTIME *' PAY-NET
Results:
SOCIAL
SECURITY NET
EMPNAME NUMBER PAY
WIMN GLORIA 025-30-5228 * NO OVERTIME * 251.65
BERG NANCY 121-16-6413 * NO OVERTIME * 547.88
IDD FILE Statement
The IDD FILE statement in Easytrieve identifies a non-IDMS file in the IDD and builds file and field definitions.
The file-name can be qualified by the file-name's version. All records defined within the file are used to generate the file's
field definitions, unless the optional SELECT parameter identifies specific records to be used.
This statement has the following format:
[ {HIGHEST}]
914
Easytrieve® Report Generator 11.6
file name
IDD FILE - [VERSION {LOWEST }] +
nnnn
[ { }]
record name
[SELECT ( - ...)] +
new file name
[FILENAME - - ]
file-name
File-name is the one to 32-character name that specifies the IDD file. File-name becomes the name of the FILE
created by the IDD FILE statement. To override this name, see the FILENAME parameter.
[VERSION {HIGHEST}] or [VERSION {LOWEST}] or [VERSION {nnnn}]
Specify HIGHEST, LOWEST, or nnnn (a positive integer) as the version of the file.
[SELECT (record-name ...)]
Record-name is a 1- to 32-character name that identifies a record of the file-name defined. Repeat the record-
name to identify as many records as needed. If you want to define all the field definitions for the file-name, omit
the SELECT clause.
[FILENAME new-file-name]
New-file-name is a 1- to 128-character name specifying the name of the file created by the IDD FILE statement.
IDD NAME Statement
The IDD NAME statement in Easytrieve establishes or re-establishes the dictionary entity retrieval environment,
and specifies the program name, the database name of the data dictionary, the Central Version Node, and the Secondary
Load Area's dictionary name and dictionary node.
IDD entities are retrieved from the designated dictionary/node until the environment is altered by issuing another IDD
NAME statement. You can use the IDD NAME statement as many times as required and before any other IDD statement.
However, you can use the PROGRAM-NAME parameter only once.
This statement has the following format:
program literal
IDD NAME [PROGRAM-NAME ' - '] +
db name table literal
[DBNAME ' - - - '] +
node literal
[NODE ' - '] +
dictionary literal
[DICTNAME ' - '] +
dictionary node literal
[DICTNODE ' - - ']
[PROGRAM-NAME 'program-literal']
'Program-literal' identifies the program name used to access an authorized subschema. 'Program-literal' must be
alphanumeric and is padded to the right (if necessary) to create an eight-byte value.
[DBNAME 'db-name-table-literal']
'Db-name-table-literal' identifies the DB Name Table of the data dictionary that contains definitions of schema,
subschema, records, and fields. 'Db-name-table-literal' must be alphanumeric and is padded to the right (if
necessary) to create an eight-byte value.
[NODE 'node-literal']
'Node-literal' specifies the IDMS Central Version Node that will process Easytrieve IDD requests. 'Node-literal'
must be alphanumeric and is padded to the right (if necessary) to create an eight-byte value.
[DICTNAME 'dictionary-literal']
'Dictionary-literal' identifies the Secondary Load Area dictionary name. 'Dictionary-literal' must be alphanumeric
and is padded to the right (if necessary) to create an eight-byte value.
915
Easytrieve® Report Generator 11.6
[DICTNODE 'dictionary-node-literal']
'Dictionary-node-literal' identifies the Secondary Load Area dictionary node. 'Dictionary-node-literal' must be
alphanumeric and is padded to the right (if necessary) to create an eight-byte value.
IDD RECORD Statement
The IDD RECORD statement in Easytrieve identifies and defines IDMS and non-IDMS records.
The elements defined within the record are used to generate field definitions at the location specified. The IDD RECORD
statement identifies and defines IDMS and non-IDMS records. The record-name can be qualified by the record's version.
The elements defined within the record are used to generate field definitions at the location specified.
This statement has the following format:
[ {HIGHEST}]
record name
IDD RECORD - [VERSION {LOWEST }] +
nnnn
[ { }]
start position
[ { - }]
offset
[ {* [+ ] }]
[LOCATION { }]
[ {W }]
[ {S }]
record-name
The record-name is the 1- to 32-character name that specifies the IDD logical record or the IDD standard record.
[VERSION {HIGHEST}] or [VERSION {LOWEST}] or [VERSION {nnnn}]
Specify HIGHEST, LOWEST, or nnnn (a positive integer) as the version of the file.
[LOCATION]
Use this optional parameter to specify the location at which the field definitions will be generated. If you do not
specify LOCATION, W (a W-type working storage field) is the default.
{start-position}
Start-position specifies the starting position relative to position one of the record.
{* [+offset]}
The * (asterisk) indicates that the field begins in the next available starting position (highest position assigned
so far, plus 1). The optional +offset is an offset you want added to the * value. There must be at least one blank
between the * and the optional +offset.
{W or S}
Coding W or S establishes a working storage field. W fields are spooled to report (work) files; S fields are not. W
is the default location if the LOCATION parameter is not coded.
IDD SUBSCHEMA Statement
The IDD SUBSCHEMA statement in Easytrieve identifies the subschema and builds the file, record, logical record,
element record, and field definitions for a subschema.
The subschema can be qualified by the schema and version. You can use the optional SELECT parameter to request that
only specific records be defined. If the SELECT parameter is omitted, the definitions of logical records are not generated.
Only database records can be defined in this way. The SELECT parameter must be used to generate logical record
definitions.
This statement has the following format:
916
Easytrieve® Report Generator 11.6
subschema name
IDD SUBSCHEMA - +
[ [ {HIGHEST}]]
schema name
[SCHEMA - [VERSION {LOWEST }]] +
nnnn
[ [ { }]]
[RESET] +
record name
[SELECT ( - ...)] +
file name
[FILENAME - ]
subschema-name
Subschema-name is a 1- to 8-character name specifying the SUBSCHEMA that contains the record and field
definitions to be retrieved. Subschema-name becomes the name of the FILE created by the IDD SUBSCHEMA
statement. For information about how to override this name, see FILENAME Parameter.
[SCHEMA schema-name [VERSION {HIGHEST} or {LOWEST} or {nnnn}]]
Schema-name is the one to eight-character name that specifies the schema that owns the subschema (when a
subschema can be owned by multiple schemas). The optional VERSION parameter specifies the version of the
schema.
[RESET]
The optional RESET parameter requests that all element records under control of RETRIEVE be reset to binary
zero immediately prior to retrieving each root record.
[SELECT (record-name ...)]
The optional SELECT clause identifies specific subschema records. Record-name is a one to 32-character name
that identifies a record for which the definition is accessed. Repeat record-name to specifically identify all the
records you need. To access all the database records (but not logical records) defined for the subschema, you
can omit the SELECT parameter.
[FILENAME file-name]
File-name is a 1- to 128-character name specifying the name of the file created by the IDD SUBSCHEMA
statement.
IDD VERSION Statement
The IDD VERSION statement in Easytrieve set a global override of the Site Options Table VERFILE, VERREC, and
VERSCHM defaults.
Other IDD statements appearing after the IDD VERSION statement, that have VERSION parameters as part of their
syntax but no VERSION parameter coded, default to the version specified in the IDD VERSION statement. IDD
statements that have a VERSION parameter coded override the VERSION statement. The defaults specified by the IDD
VERSION statement remain in effect until another IDD VERSION statement is issued.
You can code as many IDD VERSION statements as you require. If the IDD VERSION statement is not used, the default
versions are retrieved from the Site Options Table.
This statement has the following format:
[ {HIGHEST}]
IDD VERSION [SCHEMA {LOWEST }] +
nnnn
[ { }]
[ {HIGHEST}]
[FILE {LOWEST }] +
nnnn
[ { }]
917
Easytrieve® Report Generator 11.6
[ {HIGHEST}]
[RECORD {LOWEST }]
nnnn
[ { }]
[SCHEMA {HIGHEST}] or {LOWEST} or {nnnn}]
Specify HIGHEST, LOWEST, or a positive integer (nnnn) to identify the default version of the SCHEMA. Any
request to retrieve a subschema that specifies a schema but not a version uses this value.
[FILE {HIGHEST}] or {LOWEST} or {nnnn}]
Specify HIGHEST, LOWEST, or a positive integer (nnnn) to identify the default version of any FILE to be retrieved
when the version is not specified on the IDD FILE statement.
[RECORD {HIGHEST}] or {LOWEST} or {nnnn}]
Specify HIGHEST, LOWEST, or a positive integer (nnnn) to identify the default version of any RECORD to be
retrieved when the version is not specified on the IDD RECORD statement.
IDMS ACCEPT DBKEY Statement
The IDMS ACCEPT DBKEY statement in Easytrieve transfers database keys to program storage.
Format 1 returns the current database key for the record, set, or area specified. Format 2 returns the database key that is
the next, prior, or owner of the specified set. The IDMS ACCEPT DBKEY statement transfers database keys to program
storage. The IDMS ACCEPT DBKEY statement has two formats. Format 1 returns the current database key for the
record, set, or area specified. Format 2 returns the database key that is the next, prior, or owner of the specified set.
This statement has the following format:
Format 1
currency field name
[{RECORD} { - - }]
receive field name
IDMS ACCEPT DBKEY - - [{AREA } { }]
currency literal
[{SET } {' - ' }]
Format 2
set field name
{NEXT } { - - }
receive field name
IDMS ACCEPT DBKEY - - {PRIOR} { }
set literal
{OWNER} {' - ' }
Format 1
receive-field-name
Receive-field-name identifies the four-byte binary field to receive the specified database key.
{RECORD} or {AREA} or {SET}
Specify RECORD, SET, or AREA.
{currency-field-name} or {'currency-literal'}
Currency-field-name or 'currency-literal' identifies the currency for the desired key. Currency-field-name must be
a 16-byte alphanumeric field. 'Currency-literal' must be alphanumeric and is padded to the right (if necessary) to
create a 16-byte value. The default is the current record of the run-unit.
Format 2
receive-field-name
Receive-field-name identifies the four-byte binary field to receive the specified database key.
{NEXT} or {PRIOR} or {OWNER}
Specify NEXT, PRIOR, or OWNER.
918
Easytrieve® Report Generator 11.6
{set-field-name} or {'set-literal'}
Set-field-name or 'set-literal' identifies the name of the desired set. Set-field-name must be a 16-byte
alphanumeric field. 'Set-literal' must be alphanumeric and is padded to the right (if necessary) to create a 16-byte
value.
IDMS ACCEPT PAGE-INFO Statement
The IDMS ACCEPT PAGE-INFO statement in Easytrieve transfers database page information to program storage.
This statement has the following format:
currency field name
{ } { - - }
receive field name
IDMS ACCEPT PAGE-INFO - - {RECORD} { }
currency literal
{ } {' - ' }
receive-field-name
Receive-field-name identifies the four-byte binary field to receive the page information.
{currency-field-name} or {'currency-literal'}
Currency-field-name or 'currency-literal' identifies the record name for the desired key. Currency-field-name must
be a 16-byte alphanumeric field. 'Currency-literal' must be alphanumeric and is padded to the right (if necessary)
to create a 16-byte value.
IDMS ACCEPT PROCEDURE Statement
The IDMS ACCEPT PROCEDURE statement in Easytrieve returns information from the Application Program Information
Block (APIB) associated with a database procedure to the program.
This statement has the following format:
proc field name
{ - - }
apib field name
IDMS ACCEPT PROCEDURE { } TO - -
proc literal
{' - ' }
{proc-field-name} or {'proc-literal'}
Proc-field-name or 'proc-literal' identifies the name of a DBA-written database procedure. Proc-field-name must
be an eight-byte alphanumeric field. 'Proc-literal' must be alphanumeric and is padded to the right (if necessary) to
create an eight-byte value.
TO apib-field-name
Apib-field-name is a 256-byte alphanumeric area of storage to which the APIB is copied.
IDMS ACCEPT STATISTICS Statement
The IDMS ACCEPT STATISTICS statement in Easytrieve retrieves the system statistics.
For more information about the statistics produced, see your IDMS documentation.
This statement has the following format:
stat field name
IDMS ACCEPT STATISTICS - -
stat-field-name
Stat-field-name identifies a 100-byte field that you must define in working storage to receive the current system
runtime statistical information.
919
Easytrieve® Report Generator 11.6
IDMS BIND Statement
The IDMS BIND statement in Easytrieve signs on the activity with the database management system.
This statement has the following format:
subschema name
{ - }
IDMS BIND { } +
subschema literal
{' - '}
program name
[ { - }]
[PROGRAM-NAME { }] +
program literal
[ {' - '}]
db name table name
[ { - - - }]
[DBNAME { }] +
db name table literal
[ {' - - - '}]
node name
[ { - }]
[NODE { }] +
node literal
[ {' - '}]
dictionary name
[ { - }]
[DICTNAME { }] +
dictionary literal
[ {' - '}]
dictionary node name
[ { - - }]
[DICTNODE { }]
dictionary node literal
[ {' - - '}]
{subschema-name} or {'subschema-literal'}
Subschema-name identifies the subschema to be processed with IDMS. Subschema-name must be an eight-byte
alphanumeric field. 'Subschema-literal' must be alphanumeric and is padded to the right (if necessary) to create
an eight-byte value.
[PROGRAM-NAME {program-name}] or [PROGRAM-NAME {'program-literal'}]
Program-name or 'program-literal' specifies the name used to identify the program to IDMS during execution.
Program-name must be an eight-byte alphanumeric field. 'Program-literal' must be alphanumeric and is padded to
the right (if necessary) to create an eight-byte value.
[DBNAME {db-name-table-name}] or [DBNAME {'db-name-table-literal'}]
Db-name-table-name or 'db-name-table-literal' specifies a DB Name Table. Data retrieved during execution of
the user's program will be from the named database. Db-name-table-name must be an eight-byte alphanumeric
field. 'Db-name-table-literal' must be alphanumeric and is padded to the right (if necessary) to create an eight-byte
value.
[NODE {node-name}] or [NODE {'node-literal'}]
Node-name or 'node-literal' specifies the Central Version Node that will host the IDMS activity generated by the
user's program. Node-name must be an eight-byte alphanumeric field. 'Node-literal' must be alphanumeric and is
padded to the right (if necessary) to create an eight-byte value.
[DICTNAME {dictionary-name}] or [DICTNAME {'dictionary-literal'}]
Dictionary-name or 'dictionary-literal' specifies the dictionary name of a secondary load area. Dictionary-name
must be an eight-byte alphanumeric field. 'Dictionary-literal' must be alphanumeric and is padded to the right (if
necessary) to create an eight-byte value.
920
Easytrieve® Report Generator 11.6
[DICTNODE {dictionary-node-name}] or [DICTNODE {'dictionary-node-literal'}]
Dictionary-node-name or 'dictionary-node-literal' specifies the dictionary node of a secondary load area.
Dictionary-node-name must be an eight-byte alphanumeric field. 'Dictionary-node-literal' must be alphanumeric
and is padded to the right (if necessary) to create an eight-byte value.
IDMS BIND FILE Statement
The IDMS BIND FILE statement in Easytrieve gives the database management system access to the record in program
storage.
This statement has the following format:
file name record name
IDMS BIND FILE - RECORD -
file-name
File-name identifies the file where the record-area is to be allocated.
RECORD record-name
Record-name identifies the record to be bound with IDMS.
IDMS BIND PROCEDURE Statement
The IDMS BIND PROCEDURE statement in Easytrieve establishes communications between a program and a DBA-
written database procedure.
This statement has the following format:
proc field name
{ - - }
receive field name
IDMS BIND PROCEDURE { } TO - -
proc literal
{' - ' }
{proc-field-name} or {'proc-literal'}
Proc-field-name or 'proc-literal' identifies the name of a DBA-written database procedure. Proc-field-name must
be an eight-byte alphanumeric field. 'Proc-literal' must be alphanumeric and is padded to the right (if necessary) to
create an eight-byte value.
TO receive-field-name
Receive-field-name must be a 256-byte alphanumeric field. The contents of receive-field-name are copied to the
APIB as part of the execution of the IDMS BIND PROCEDURE statement.
IDMS COMMIT Statement
The IDMS COMMIT statement in Easytrieve requests the creation of a checkpoint.
This statement has the following format:
IDMS COMMIT [ALL]
[ALL]
This optional parameter controls which locks are released. The default is ALL EXCEPT THOSE HELD.
IDMS CONNECT Statement
The IDMS CONNECT statement in Easytrieve establishes a record as a member of a set occurrence.
921
Easytrieve® Report Generator 11.6
This statement has the following format:
record field name set field name
{ - - } { - - }
IDMS CONNECT RECORD { } SET { }
record literal set literal
{' - ' } {' - ' }
{record-field-name} or {'record-literal'}
Record-field-name or 'record-literal' identifies the record to be connected. Record-field-name must be a 16-byte
alphanumeric field. 'Record-literal' must be alphanumeric and is padded to the right (if necessary) to create a 16-
byte value.
{set-field-name} or {'set-literal'}
Set-field-name or 'set-literal' specifies the set to which the record is to be connected. Set-field-name must be a 16-
byte alphanumeric field. 'Set-literal' must be alphanumeric and is padded to the right (if necessary) to create a 16-
byte value.
IDMS DISCONNECT Statement
The IDMS DISCONNECT statement in Easytrieve cancels the relationship between a record and a set occurrence.
This statement has the following format:
record field name set field name
{ - - } { - - }
IDMS DISCONNECT RECORD { } SET { }
record literal set literal
{' - ' } {' - ' }
RECORD {record-field-name} or RECORD {'record-literal'}
Record-field-name or 'record-literal' identifies the record to be disconnected. Record-field-name must be a 16-byte
alphanumeric field. 'Record-literal' must be alphanumeric and is padded to the right (if necessary) to create a 16-
byte value.
SET {set-field-name} or SET {'set-literal'}
Set-field-name or 'set-literal' specifies the set from which the record is to be disconnected. Set-field-name must be
a 16-byte alphanumeric field. 'Set-literal' must be alphanumeric and is padded to the right (if necessary) to create
a 16-byte value.
IDMS ERASE Statement
Format 1 of the IDMS ERASE statement in Easytrieve makes a record unavailable for further processing and removes it
from all set occurrences. Format 2 makes a logical record unavailable for further processing.
This statement has the following format:
Format 1
[MEMBERS ]
record field name
{ - - } [PERMANENT]
IDMS ERASE RECORD { } [ ]
record literal
{' - ' } [SELECTIVE]
[ALL ]
Format 2
922
Easytrieve® Report Generator 11.6
logical record name boolean expression
IDMS ERASE RECORD - - [WHERE ( - )]
Format 1
RECORD {record-field-name} or RECORD {'record-literal'}
Record-field-name or 'record-literal' identifies the record to be erased. Record-field-name must be a 16-byte
alphanumeric field. 'Record-literal' must be alphanumeric and is padded to the right (if necessary) to create a 16-
byte value.
[MEMBERS] or [PERMANENT] or [SELECTIVE] or [ALL]
This optional parameter controls the type of erasure. The default is MEMBERS.
Format 2
RECORD logical-record-name
Logical-record-name is a one to 16-character name that identifies the logical record to be erased. Logical-record-
name must be the name of a logical record defined by a LOGICAL-RECORD statement.
[WHERE (boolean-expression)]
Code the optional WHERE clause to provide a Boolean expression IDMS uses to select the logical records to be
erased.
IDMS FIND and IDMS OBTAIN Statements
The IDMS FIND statement in Easytrieve locates a record. The IDMS OBTAIN statement locates and then retrieves a
record. Review the six formats of these statements.
The IDMS FIND and IDMS OBTAIN statements are described together because their formats are the same. The IDMS
FIND statement only locates (positions to) a record; the IDMS OBTAIN statement locates and then retrieves a record.
These statements have six formats:
• Format 1 locates/retrieves a record based on its DBKEY.
• Format 2 locates/retrieves the current occurrence of the record type, set, or area.
• Format 3 locates/retrieves a record within a set or area.
• Format 4 locates/retrieves the owner record within the set.
• Format 5 locates/retrieves a record based on its CALC key.
• Format 6 locates retrieves an ordered (sorted) record from a set.
NOTE
For information about how to retrieve logical records, see IDMS OBTAIN Statement in this article.
This statement has the following format:
Format 1
record field name
[ { - - }]
[ RECORD { }]
key field name record literal
{FIND } { - - } [ {' - ' }] [SHARE|SHR ]
IDMS { } DBKEY { } [ ] [ ]
key literal page field name
{OBTAIN} {' - ' } [ { - - }] [EXCLUSIVE|EXC]
[ PAGE-INFO { }]
page literal
[ {' - ' }]
Format 2
field name
{FIND } [{RECORD} { - }] [SHARE|SHR ]
IDMS { } CURRENT [{SET } { }] [ ]
923
Easytrieve® Report Generator 11.6
literal
{OBTAIN} [{AREA } {' ' }] [EXCLUSIVE|EXC]
Format 3
record field name
{FIND }# {NEXT } [ { - - }]
IDMS { }# {PRIOR } [RECORD { }] +
record literal
{OBTAIN}# {FIRST } [ {' - ' }]
{LAST }
nth field name
{ { - - } }
{NTH { } }
nth literal
{ { - } }
search field name
{SET } { - - } [SHARE|SHR ]
{ } { } [ ]
search literal
{AREA} {' - ' } [EXCLUSIVE|EXC]
Format 4
set field name
{FIND } { - - } [SHARE|SHR ]
IDMS { } OWNER SET { } [ ]
set literal
{OBTAIN} {' - ' } [EXCLUSIVE|EXC]
Format 5
record field name
{FIND } {CALC } { - - } [SHARE|SHR ]
IDMS { } { } RECORD { } [ ]
record literal
{OBTAIN} {DUPLICATE} {' - ' } [EXCLUSIVE|EXC]
Format 6
record field name set field name
{FIND } { - - } { - - }
IDMS { } [CURRENT] RECORD { } SET { } +
record literal set literal
{OBTAIN} {' - ' } {' - ' }
control field name
{ - - } [SHARE|SHR ]
USING ({ }...) [ ]
control literal
{' - ' } [EXCLUSIVE|EXC]
Format 1
DBKEY {key-field-name} or DBKEY {'key-literal'}
Key-field-name or 'key-literal' identifies the key of the database record. Key-field-name must be a four-byte binary
field. 'Key-literal' must be a four-byte hexadecimal value.
[RECORD {record-field-name}] or [RECORD {'record-literal'}]
Record-field-name or 'record-literal' identifies the record to be located/retrieved. Record-field-name must be a 16-
byte alphanumeric field. 'Record-literal' must be alphanumeric and is padded to the right (if necessary) to create a
16-byte value. The default is any record type that satisfies the DBKEY.
[PAGE-INFO {page-field-name}] or [PAGE-INFO {'page-literal'}]
Page-field-name or 'page-literal' identifies the record to be located/retrieved by its page information. Page-field-
name must be a 4-byte binary field. 'Page-literal' must be a 4-byte hexadecimal value.
924
Easytrieve® Report Generator 11.6
[SHARE|SHR] or [EXCLUSIVE|EXC]
These optional parameters determine the type of lock to be placed on the object record.
Format 2
[{RECORD|SET|AREA} {field-name|'literal'}]
Field-name or 'literal' identifies the record, set, or area to be located/retrieved. Field-name must be a 16-byte
alphanumeric field. 'Literal' must be alphanumeric and is padded to the right (if necessary) to create a 16-byte
value. The default locates/retrieves the current record of the run-unit.
[SHARE|SHR] or [EXCLUSIVE|EXC]
These optional parameters determine the type of lock to be placed on the object record.
Format 3
{NEXT} or {PRIOR} or {FIRST} or {LAST} or {NTH {nth-field-name|nth-literal}}
Nth-field-name or nth-literal identifies the record occurrence of the set or area to be located/retrieved. Nth-field-
name must be a four-byte binary integer. Nth-literal must be a positive or negative integer.
[RECORD {record-field-name}|'record-literal'}]
Record-field-name or 'record-literal' identifies the record to be located/retrieved. Record-field-name must be a 16-
byte alphanumeric field. 'Record-literal' must be alphanumeric and is padded to the right (if necessary) to create a
16-byte value. The default is the record that otherwise satisfies the search criteria.
{SET|AREA}{search-field-name|'search-literal'}
Search-field-name or 'search-literal' identifies the set or area that determines the scope of the search. Search-
field-name must be a 16-byte alphanumeric field. 'Search-literal' must be alphanumeric and is padded to the right
(if necessary) to create a 16-byte value.
[SHARE|SHR ] or [EXCLUSIVE|EXC]
These optional parameters determine the type of lock to be placed on the object record.
Format 4
OWNER SET {set-field-name|'set-literal'}
Set-field-name or 'set-literal' identifies the set to search. Set-field-name must be a 16-byte alphanumeric field.
'Set-literal' must be alphanumeric and is padded to the right (if necessary) to create a 16-byte value.
[SHARE|SHR] or [EXCLUSIVE|EXC]
These optional parameters determine the type of lock to be placed on the object record.
Format 5
{CALC} or {DUPLICATE}
This parameter determines whether the first (CALC) or next (DUPLICATE) record is located/retrieved.
RECORD {record-field-name|'record-literal'}
Record-field-name or 'record-literal' identifies the record to locate/retrieve. Record-field-name must be a 16-byte
alphanumeric field. 'Record-literal' must be alphanumeric and is padded to the right (if necessary) to create a 16-
byte value.
[SHARE|SHR] or [EXCLUSIVE|EXC]
These optional parameters determine the type of lock to be placed on the object record.
Format 6
[CURRENT]
This optional parameter controls the start of the search. The default begins with the owner of the current record
within the set.
925
Easytrieve® Report Generator 11.6
RECORD {record-field-name|'record-literal'}
Record-field-name or 'record-literal' identifies the record to locate/retrieve. Record-field-name must be a 16-byte
alphanumeric field. 'Record-literal' must be alphanumeric and is padded to the right (if necessary) to create a 16-
byte value.
SET {set-field-name|'set-literal'}
Set-field-name or 'set-literal' identifies the set to search. Set-field-name must be a 16-byte alphanumeric field.
'Set-literal' must be alphanumeric and is padded to the right (if necessary) to create a 16-byte value.
USING {control-field-name|'control-literal'}
Control-field-name or 'control-literal' identifies the control data item. The length and code system of the control
data item must match that in the database.
[SHARE|SHR] or [EXCLUSIVE|EXC]
These optional parameters determine the type of lock to be placed on the object record.
IDMS FINISH Statement
The IDMS FINISH statement in Easytrieve signs off the database management system.
This statement has the following format:
IDMS FINISH
IDMS GET Statement
The IDMS GET statement in Easytrieve retrieves current data records.
This statement has the following format:
record field name
[ { - - }]
IDMS GET [RECORD { }]
record literal
[ {' - ' }]
RECORD {record-field-name|'record-literal'}
Record-field-name or 'record-literal' identifies the record to locate/retrieve. Record-field-name must be a 16-byte
alphanumeric field. 'Record-literal' must be alphanumeric and is padded to the right (if necessary) to create a 16-
byte value. The default record is the current record type of the run-unit.
IDMS IF Statement
The IDMS IF statement in Easytrieve tests the status of a set.
This statement has the following format:
{MEMBER }
set field name
{ - - } {NOMEMBER}
IDMS IF SET { } { }
set literal
{' - ' } {EMPTY }
{NOEMPTY }
SET {set-field-name|'set-literal'}
Set-field-name or 'set-literal' identifies the set to search. Set-field-name must be a 16-byte alphanumeric field.
'Set-literal' must be alphanumeric and is padded to the right (if necessary) to create a 16-byte value.
926
Easytrieve® Report Generator 11.6
{MEMBER} or {NOMEMBER} or {EMPTY} or {NOEMPTY}
This parameter determines the type of test:
• Specify MEMBER if the current record is a member of specified set.
• Specify NOMEMBER if the current record is not a member of specified set.
• Specify EMPTY if no member record occurrences exist.
• Specify NOEMPTY if member record occurrences exist.
The IDMS IF statement is similar to the Easytrieve IF statement in that a corresponding END-IF statement is required
and the ELSE statement is optional. For more information, see the following sections in this article:
• IF Statement
• ELSE-IF Statement
• ELSE Statement
• END-IF Statement
IDMS KEEP Statement
The IDMS KEEP statement in Easytrieve places a shared or exclusive lock on a record.
This statement has the following format:
field name
[{RECORD} { - }]
IDMS KEEP [{SET } { }] [EXCLUSIVE]
literal
[{AREA } {' ' }]
[{RECORD|SET|AREA} {field-name|'literal'}]
Field-name or 'literal' identifies the desired record, set, or area to be locked. Field-name must be a 16-byte
alphanumeric field. 'Literal' must be alphanumeric and is padded to the right (if necessary) to create a 16-byte
value.
[EXCLUSIVE]
This optional parameter controls the lock for the record. The default is SHARED LOCK.
IDMS MODIFY Statement
Format 1 of the IDMS MODIFY statement in Easytrieve updates a record within the database. Format 2 updates a logical
record within the database.
This statement has the following format:
Format 1
record field name
{ - - }
IDMS MODIFY RECORD { }
record literal
{' - ' }
Format 2
logical record name boolean expression
IDMS MODIFY RECORD - - [WHERE ( - )]
Format 1
927
Easytrieve® Report Generator 11.6
RECORD {record-field-name|'record-literal'}
Record-field-name or 'record-literal' identifies the record to be modified. Record-field-name must be a 16-byte
alphanumeric field. 'Record-literal' must be alphanumeric and is padded to the right (if necessary) to create a 16-
byte value.
Format 2
RECORD logical-record-name
Logical-record-name is a 1- to 16-character name that identifies the logical record to be modified by IDMS.
[WHERE (boolean-expression)]
Code the optional WHERE clause to provide a Boolean expression to IDMS to select the logical records to be
modified.
IDMS OBTAIN Statement
The IDMS OBTAIN statement in Easytrieve is used to retrieve logical records.
NOTE
For information about how to retrieve database records, see IDMS FIND and IDMS OBTAIN Statements.
This statement has the following format:
{FIRST}
logical record name boolean expression
IDMS OBTAIN { } RECORD - - [WHERE( - )]
{NEXT }
{FIRST} or {NEXT}
Specify FIRST to retrieve the first occurrence of the logical record. Specify NEXT to retrieve subsequent
occurrences.
RECORD logical-record-name
Logical-record-name is a 1- to 16-character name that identifies the logical record to be retrieved. Logical-record-
name must be the name of a logical record defined by a LOGICAL-RECORD statement.
[WHERE (boolean-expression)]
Code the optional WHERE clause to provide a Boolean expression IDMS uses to select the logical records to be
retrieved.
IDMS READY Statement
The IDMS READY statement in Easytrieve establishes area availability with the database manager.
This statement has the following format:
area field name
[ { - - }] [{RETRIEVAL} [PROTECTED]]
IDMS READY [AREA { }] [{ } [ ]]
area literal
[ {' - ' }] [{UPDATE } [EXCLUSIVE]]
[AREA {area-field-name|'area-literal'}]
Area-field-name or 'area-literal' identifies the area to be made available for processing. Area-field-name must be a
16-byte alphanumeric field. 'Area-literal' must be alphanumeric and is padded to the right (if necessary) to create
a 16-byte value. If not specified, all areas in the subschema are readied.
[{RETRIEVAL|UPDATE} [PROTECTED|EXCLUSIVE]]
These optional parameters determine the type of access. The default is RETRIEVAL.
928
Easytrieve® Report Generator 11.6
IDMS RETURN Statement
The IDMS RETURN statement in Easytrieve retrieves the database key for an indexed record without retrieving the
record itself.
This statement has the following format:
set field name
{ - - }
receive field name
IDMS RETURN DBKEY - - FROM { } +
set literal
{' - ' }
symbolic key
[KEY - ] +
{ }
{CURRENCY }
{FIRST [CURRENCY] }
{LAST [CURRENCY] }
{NEXT [CURRENCY] }
{PRIOR [CURRENCY] }
{ }
key field name
{ { - - } }
{USING ({ }...)}
key literal
{ {' - ' } }
DBKEY receive-field-name
This is a four-byte binary field with zero (0) decimal places. This field receives the DBKEY of the indexed record.
FROM {set-field-name|'set-literal'}
Set-field-name or 'set-literal' identifies the index set to be accessed. Set-field-name must be a 16-byte
alphanumeric field. 'Set-literal' must be alphanumeric and is padded to the right (if necessary) to create a 16-byte
value.
[KEY symbolic-key]
This parameter retrieves the record's symbolic key into symbolic-key. Symbolic-key is the name of an
alphanumeric field that is large enough to contain the record's symbolic key.
{CURRENCY|FIRST [CURRENCY]|LAST [CURRENCY]|{NEXT [CURRENCY]|{PRIOR [CURRENCY]} {USING
{key-field-name|'key-literal'}}
These parameters determine the record for which the database key is returned:
• CURRENCY -- the current index entry
• FIRST [CURRENCY] -- the first entry in the index
• LAST [CURRENCY] -- the last entry in the index
• NEXT [CURRENCY] -- the entry following current of index. If the current of index is the last entry, an error
status of 1707 (END OF INDEX) is returned.
• PRIOR [CURRENCY] -- the entry before current of index
• USING -- the first index entry whose symbolic key matches the key-field-name or 'key-literal'. If no such entry
exists, a status code of 1726 (INDEX ENTRY NOT FOUND) is returned. The attributes of key-field-name or
'key-literal' must match the symbolic key of the index.
IDMS ROLLBACK Statement
The IDMS ROLLBACK statement in Easytrieve requests recovery.
This statement has the following format:
929
Easytrieve® Report Generator 11.6
IDMS ROLLBACK [CONTINUE]
[CONTINUE]
This optional parameter specifies the action taken after the recovery. The default is to terminate the run-unit.
IDMS STORE Statement
Format 1 of the IDMS STORE statement in Easytrieve places a new record occurrence into the database. Format 2
places a new logical record occurrence into the database.
This statement has the following format:
Format 1
record field name
{ - - }
IDMS STORE RECORD { }
record literal
{' - ' }
Format 2
logical record name boolean expression
IDMS STORE RECORD - - [WHERE ( - )]
Format 1
RECORD {record-field-name|'record-literal'}
Record-field-name or 'record-literal' identifies the record to store. Record-field-name must be a 16-byte
alphanumeric field. 'Record-literal' must be alphanumeric and is padded to the right (if necessary) to create a 16-
byte value.
Format 2
RECORD logical-record-name
Logical-record-name is a one to sixteen-character name that identifies the logical record that IDMS stores.
[WHERE (boolean-expression)]
Code the optional WHERE clause to provide a Boolean expression IDMS uses to select the logical records to be
stored.
IF, ELSE-IF, ELSE, and END-IF Statements
The IF statement in Easytrieve controls execution of associated statements. ELSE-IF identifies a conditional expression
tested when the previous conditional expression is false. Associated statements are coded between IF and END-IF.
The truth value of conditional-expression-1 determines whether statement-1 is executed. If conditional-expression-1 is
true, Easytrieve executes statements designated by statement-1. If conditional-expression-1 is false, Easytrieve tests
conditional-expression-2, if ELSE-IF is specified.
If ELSE-IF is specified, the truth value of conditional-expression-2 determines whether statement-2 is executed. If
conditional-expression-2 is true, Easytrieve executes statements designated by statement-2. If conditional-expression-2
is false, Easytrieve tests the conditional expression of the next ELSE-IF, if specified. If the conditional expression of the
last ELSE-IF statement is also false, Easytrieve executes statements designated by statement-3. You can nest as many
ELSE-IF statements within the IF as necessary. You must terminate the IF statement with a single END-IF.
If ELSE-IF is not specified and conditional-expression-1 is false, Easytrieve executes statements designated by
statement-3.
930
Easytrieve® Report Generator 11.6
If the ELSE statement is not specified and the conditional-expression is false, no statements are executed and control
passes to the statement following END-IF.
Statement-1, statement-2, and statement-3 each represent any number of Easytrieve statements. Whenever one or
more of these statements is an IF statement, the IF statements are considered to be nested. The format of nested IF
statements is that statement-1, statement-2, and statement-3 of any IF can be an IF statement.
This statement has the following format:
conditional expression
IF - -1
statement
[ -1]
conditional expression
[ELSE-IF - -2] [ . . . ]
statement
[ [ -2] ] [ ]
[ELSE ]
statement
[ [ -3] ]
END-IF
The following diagram illustrates IF, ELSE-IF, ELSE, and END-IF logic:
931
Easytrieve® Report Generator 11.6
conditional-expression
For conditional expression syntax, see Conditional Expressions in "Statements A - C."
ELSE-IF
ELSE-IF is optional and identifies a conditional expression to be tested when the previous conditional expression
is false. ELSE-IF statements allow multiple conditions to be nested without requiring an END-IF statement on
each condition. You can code as many ELSE-IF statements as necessary.
ELSE
ELSE is optional and identifies the statements to be executed when conditions are false. When the conditions of
the preceding IF or ELSE-IF are not satisfied, Easytrieve continues execution with the statement following ELSE.
NOTE
ELSE must be on a source statement by itself, unless it is followed by a period and a space.
END-IF
END-IF terminates the logic associated with the previous IF statement. An END-IF statement must be specified
after each IF statement and its associated statements. You do not specify an END-IF for an ELSE-IF.
Examples
932
Easytrieve® Report Generator 11.6
The following three examples illustrate the IF statement usage. In each of the illustrated cases, the field XMAS-BONUS
is computed to be three or five percent over PAY-GROSS. If the field PAY-GROSS is non-numeric, a warning message is
issued and the record is bypassed from further processing.
Example 1, Without Nested IF Statements:
FILE PERSNL FB(150 1800)
%PERSNL
XMAS-BONUS W 4 P 2 VALUE 0
TOT-XMAS-BONUS W 6 P 2 VALUE 0
*
JOB INPUT PERSNL NAME MYPROG FINISH FINISH-PROC IF PAY-GROSS NOT NUMERIC
DISPLAY EMP# ' PERSONNEL RECORD IS DAMAGED'
GO TO JOB END-IF IF PAY-GROSS > 500.00
XMAS-BONUS = PAY-GROSS * 1.03 ELSE
XMAS-BONUS = PAY-GROSS * 1.05 END-IF
TOT-XMAS-BONUS = TOT-XMASBONUS +
+ XMAS-BONUS
PRINT MYREPORT
*
FINISH-PROC. PROC
DISPLAY
DISPLAY 'TOTAL $ SPENT IN BONUS ' +
'MONEY ====> ' TOT-XMAS-BONUS
END-PROC
*
REPORT MYREPORT
LINE NAME-LAST XMAS-BONUS
Example 2, with Nested IF Statements:
FILE PERSNL FB(150 1800)
%PERSNL
XMAS-BONUS W 4 P 2 VALUE 0
TOT-XMAS-BONUS W 6 P 2 VALUE 0
*
JOB INPUT PERSNL NAME MYPROG FINISH FINISH-PROC IF PAY-GROSS NOT NUMERIC
DISPLAY EMP# ' PERSONNEL RECORD IS DAMAGED'
GOTO JOB ELSE IF PAY-GROSS > 500.00
XMAS-BONUS = PAY-GROSS * 1.03 ELSE
XMAS-BONUS = PAY-GROSS * 1.05 END-IF END-IF
TOT-XMAS-BONUS = TOT-XMAS-BONUS + XMAS-BONUS
PRINT MYREPORT
*
933
Easytrieve® Report Generator 11.6
FINISH-PROC. PROC
DISPLAY
DISPLAY 'TOTAL $ SPENT IN BONUS ' +
'MONEY ====> ' TOT-XMAS-BONUS
END-PROC
*
REPORT MYREPORT
LINE NAME-LAST XMAS-BONUS
Example 3, with ELSE-IF Statements:
FILE PERSNL FB(150 1800)
%PERSNL
XMAS-BONUS W 4 P 2 VALUE 0
TOT-XMAS-BONUS W 6 P 2 VALUE 0
*
JOB INPUT PERSNL NAME MYPROG FINISH FINISH-PROC IF PAY-GROSS NOT NUMERIC
DISPLAY EMP# ' PERSONNEL RECORD IS DAMAGED'
GOTO JOB ELSE-IF PAY-GROSS > 500.00
XMAS-BONUS = PAY-GROSS * 1.03 ELSE
XMAS-BONUS = PAY-GROSS * 1.05 END-IF
TOT-XMAS-BONUS = TOT-XMAS-BONUS + XMAS-BONUS
PRINT MYREPORT
*
FINISH-PROC. PROC
DISPLAY
DISPLAY 'TOTAL $ SPENT IN BONUS ' +
'MONEY ====> ' TOT-XMAS-BONUS
END-PROC
*
REPORT MYREPORT
LINE NAME-LAST XMAS-BONUS
INITIATION Screen Procedure
An INITIATION procedure in Easytrieve is invoked once during the start of the screen activity to perform actions that are
to be executed only once.
An INITIATION procedure is invoked once during the start of the screen activity.
You use INITIATION to perform actions that are to be executed only once. Typically, you use INITIATION to initialize a field
or position a file at a specific starting position.
REFRESH and RESHOW are invalid in an INITIATION procedure.
If GOTO SCREEN is executed in an INITIATION procedure, the INITIATION procedure is terminated and the BEFORE-
SCREEN procedure is invoked.
An INITIATION procedure must be delimited by an END-PROC statement. For more information, see PROC Statement in
"Statements N - R."
934
Easytrieve® Report Generator 11.6
This statement has the following format:
INITIATION. PROC
Example
INITIATION. PROC
MESSAGE 'Enter an employee number.' LEVEL INFORMATION
MOVE ZERO TO EMP-NO
MOVE SPACES TO EMPNAME
END-PROC
INSERT Statement
The INSERT statement in Easytrieve inserts a row into an Easytrieve SQL file.
Use the INSERT statement to insert a row into an Easytrieve SQL file.
INSERT does not require an open cursor. If no cursor is open for the file, one is not opened automatically. If a cursor is
open, the inserted record does not appear in the cursor's result set until the cursor is closed and re-opened with a new
SELECT statement.
The file must be specified with the UPDATE parameter.
This statement has the following format:
file name
INSERT [INTO] -
[INTO]
Optionally, code INTO for statement readability.
file-name
File-name identifies an Easytrieve SQL file.
Example
The following example inserts a new row into a table:
FILE PERSNL SQL (PERSONNEL) UPDATE
EMPNAME * 20 A
WORKDEPT * 2 P 0
EMPPHONE * 3 P 0
PROGRAM NAME RETRIEVE-PERSONNEL
EMPNAME = 'WIMN GLORIA'
WORKDEPT = 921
EMPPHONE = 3478 INSERT INTO PERSNL
JOB Statement
The JOB statement in Easytrieve defines and initiates a processing activity.
In a JOB activity, statements can specify various processing tasks including retreiving input files and databases,
examining and manipulating data, start print reports, and producing output files. The JOB statement defines and initiates a
processing activity. In a JOB activity, statements can specify various processing tasks:
935
Easytrieve® Report Generator 11.6
• Retrieval of input files and databases
• Examination and manipulation of data
• Initiation of printed reports
• Production of output files and databases
The JOB statement can also identify the name of an automatic input file (which can be any file or database that is
processed sequentially).
JOB activities can be executed by PROGRAM or SCREEN activities. If a PROGRAM activity is not coded, JOB and
SORT activities are automatically executed sequentially until a SCREEN activity is encountered.
This statement has the following format:
JOB +
file name field name
[ {( - [KEY - -1...)]...)} ]
[INPUT {NULL } ] +
[ {SQL } ]
start proc name
[START - - ] +
finish proc name
[FINISH - - ] +
job name
[NAME - ] +
[ { }]
[ENVIRONMENT{NONE }] +
[ {COBOL}]
[ [ACTIVITY ] [TERMINAL ] ]
[COMMIT ([ ] [ ])]
[ [NOACTIVITY] [NOTERMINAL] ]
[INPUT]
The optional INPUT parameter identifies the automatic input to the activity.
When you do not specify INPUT, Easytrieve automatically provides an input file. If a SORT activity immediately
preceded the current JOB activity, the default input is the output file from that SORT activity. Otherwise, the
default input is the first file named in the library section.
{file-name}
File-name identifies the automatic input file. File-name identifies any file defined in the library section of the
program eligible for sequential input processing. When Easytrieve processes the last automatic input record,
Easytrieve terminates the job activity.
NOTE
Except in CICS, Easytrieve issues a GET HOLD for a VSAM file with the UPDATE parameter as
automatic input. This lets you update an automatic input file in all environments except CICS.
For more information about database processing, see the Programming Guide.
{[KEY (key-field-name ...)]}
Specify key fields for JOB statement activities.
Code KEY (key-field-name) for each file-name of a synchronized file input process. During synchronized file
processing, Easytrieve sequentially processes the files, using KEY fields. KEY fields can be any fields from the
associated file. The only exceptions are varying length, index, or subscript fields, which cannot be used as keys.
For more detailed information about synchronized file processing, see the Programming Guide.
936
Easytrieve® Report Generator 11.6
NOTE
Synchronized file processing is not allowed for IDMS and IMS/DLI database files.
{NULL}
Code NULL as a file-name to inhibit automatic input. Use this when no input is required or when input is retrieved
by statements in the activity. When NULL is used, a STOP or TRANSFER statement must be executed in the JOB
activity, otherwise the activity executes indefinitely.
{SQL}
Code SQL instead of a file-name to use automatic retrieval of an SQL database without a file. The selection
criteria for the input are specified on the non-file SQL SELECT statement that must immediately follow the JOB
statement. For more information about automatic retrieval without a file and SQL database processing, see the
Programming Guide.
[START start-proc-name]
The optional START start-proc-name parameter identifies a procedure to be executed during the initiation of the
JOB.
Easytrieve optionally performs the procedure coded in start-proc-name before it retrieves the first automatic input
record. A typical START procedure sets working storage fields to an initial value or positions a file to a specific
record. You cannot reference fields in automatic input files, because no records have been retrieved at this stage
of processing.
If GOTO JOB is executed in a START procedure, the START procedure is terminated.
[FINISH finish-proc-name]
The optional FINISH finish-proc-name parameter identifies a procedure to be executed during the normal
termination of the JOB. After Easytrieve processes the last automatic input record, it performs the finish-proc-
name procedure. A typical finish-proc-name procedure displays control information accumulated during the
activity.
If GOTO JOB is executed in a FINISH procedure, the FINISH procedure is terminated at that point.
If STOP EXECUTE is executed in the JOB activity, the FINISH procedure is not performed.
ENVIRONMENT (z/OS only)
Specifies to establish the proper execution environment prior to calling any COBOL subprograms. The
environment is established prior to the JOB activity and is terminated after the activity termination.
ENVIRONMENT(COBOL) is ignored if the JOB activity contains no CALL statement and if no FILE EXITs are
specified. When used on the JOB statement, it establishes the ENVIRONMENT for only that JOB activity.
This processing is different if the JOB activity is invoked from within a PROGRAM activity if that PROGRAM
activity had activated the ENVIRONMENT, (through the PROGRAM ENVIRONMENT(COBOL) parm). In that
case, the PROGRAM activity's ENVIRONMENT will remain active during the execution of the invoked JOB
activity, and the ENVIRONMENT will not end at the JOB activity termination. Even if ENVIRONMENT(NONE) is
specified on the JOB or PARM statements, the PROGRAM activity's ENVIRONMENT will remain active during the
JOB activity execution.
When this parameter is absent, the default for ENVIRONMENT depends on how the ENVIRON system option
was set at installation and whether the ENVIRONMENT parameter of the PARM statement was specified. Using
the subparameter NONE overrides an existing default of COBOL and using COBOL overrides a default of
NONE. See the discussion of the PROGRAM statement, and see "Subprograms" for more information about this
parameter and the functionality of this feature.
[NAME job-name]
The NAME parameter names the JOB activity. Job-name:
• Can be up to 128 characters in length
• Can contain any character other than a delimiter
• Can begin with A to Z, 0 to 9, or a national character (#, @, $)
• Must not consist of all numeric characters
This parameter is used for documentation purposes or to identify this JOB on an EXECUTE statement.
937
Easytrieve® Report Generator 11.6
[COMMIT [ACTIVITY|NOACTIVITY] [TERMINAL|NOTERMINAL]]
Specify the COMMIT parameter to control the logical unit of work. COMMIT indicates when the activity commits
recoverable work. Each commit point posts all updates, additions, and deletions, terminates holds, and closes
SQL cursors.
Specify ACTIVITY to commit all recoverable work during the normal termination of the activity. Specify
NOACTIVITY to tell Easytrieve not to commit at the end of the activity. NOACTIVITY is the default.
Specify TERMINAL to commit all recoverable work during any terminal I/O operation. In CICS, this results in
terminal I/O being performed in a pseudo-conversational mode. Specify NOTERMINAL to tell Easytrieve not to
commit during a terminal I/O. TERMINAL is the default.
If this activity is executed by an activity that has NOTERMINAL specified, this activity performs terminal I/O as if
NOTERMINAL was specified.
NOTE
You can also issue your own COMMIT and ROLLBACK statements to commit or recover work on a
controlled basis.
For more information, see the Programming Guide.
Examples
Example 1
The following example illustrates the position of the JOB activities in an Easytrieve program.
Environment
...
Library
...
Activities {JOB...
... {...
JOB, SCREEN { job procedures
and/or { ...
SORT { ...
... { reports
... { ...
For more information about JOB activity flow control, see the Programming Guide.
Example 2
The following example illustrates a JOB statement that automatically reads a sequential file:
JOB INPUT PERSNL NAME SCAN-PERSONNEL-RECORDS
Example 3
The following example illustrates synchronized file processing. It shows a JOB statement for matching a transaction file
(TRANFILE) with a master file (MASTFILE). The JOB uses the FINISH parameter to execute a procedure when all the
input records have been recorded.
JOB NAME MATCH-FILES INPUT (TRANFILE KEY TRAN-EMP-NO +
MASTFILE KEY MAST-EMP-NO) +
FINISH DISPLAY-EOJ-MESSAGE
938
Easytrieve® Report Generator 11.6
KEY Statement
The KEY statement in Easytrieve defines valid keys for a screen, specifies descriptive text to be displayed for each valid
key, and assigns automatic functions for execution for each valid key.
If a key that is not defined on a KEY statement is pressed, an error message is displayed on the terminal prompting the
user to press a valid key.
If no KEY statements are coded, all keys are valid and you must provide code for all keys in your SCREEN activity
procedures.
The function key area is built depending on the sequence of keys specified in KEY statements. You must specify keys in
the order you want them displayed.
The key display area is built on the bottom line of a screen. If the key display area requires additional lines because of the
number of keys and the length of the descriptive text, additional lines at the bottom of the screen are used.
When used as the result of pressing an IMMEDIATE key, REFRESH redisplays the screen image with the original data
displayed on the screen. This is useful when the terminal user enters erroneous data on the screen and wants to restore
the screen with its original data.
When used as the result of a non-IMMEDIATE key, REFRESH can be used to rebuild the screen using current data from
the screen.
REFRESH can also be invoked by using the REFRESH statement. For more information, see REFRESH Statement in
"Statements N - R."
EXIT can also be invoked indirectly by executing it in a screen procedure. For more information, see EXIT Statement in
"Statements D - F."
NOTE
If you specify that one or more message areas use the same screen row as the function key area, messages
might overlap the function key area. The default for the message area is the row immediately preceding the key
display area.
Note: The CLEAR, PA1, PA2, and PA3 keys do not transmit data from the screen to the program. Also, cursor positioning
cannot be determined when these keys are pressed.
This statement has the following format:
[EXIT ]
key name key name literal
KEY - [THRU - ]...[NAME ' '] [ ] [IMMEDIATE]
[REFRESH]
key-name
Specify a symbolic name for a terminal key as described by the system-defined field, KEY-PRESSED.
KEY-PRESSED is a two-byte binary field that contains a value representing the most recent terminal key pressed
by the terminal user.
Easytrieve automatically defines symbolic names that correspond to values for the most common keys:
Terminal Key Symbolic Name Constant Value
Enter ENTER 1
Clear CLEAR 11
PA1 to PA3 PA1 to PA3 12 to 14
PF1 to PF24 F1 to F24 21 to 44
F1 to F12 F1 to F12 21 to 32
939
Easytrieve® Report Generator 11.6
NOTE
Only terminal keys with a KEY-PRESSED symbolic name can be used on a KEY statement. If other terminal
keys (such as test request) are required, you must test KEY-PRESSED using the constant value of the
terminal key in your program code. If you test for terminal keys without a symbolic name, you cannot code KEY
statements in your program.
[THRU key-name]
Use THRU key-name to specify a range of key-names. A range of key-names includes all keys whose constant
values for KEY-PRESSED fall between the constant values of the keys you specify for the range. For example, if
you code:
KEY CLEAR THRU F12
the PA1, PA2, and PA3 keys are also valid. The constant values of the PA keys (12, 13, 14) fall between the value
for CLEAR (11) and F12 (32).
NOTE
You can also specify a series of non-consecutive key-names by omitting THRU. You can optionally
separate a series of key-names with commas for readability. You can specify a range of key-names and
a series of key-names on the same KEY statement. See the examples below.
[NAME 'literal']
The optional NAME parameter allows you to specify descriptive text to be displayed with the key on the screen.
The format displayed on the screen is:
key-name=literal
Example:
F1=Help F3=Exit F12=Cancel
'Literal' can contain a maximum of 20 characters.
To display only the key-name on a screen, code NAME 'literal' with a blank space between single quotes (' ').
If you do not code NAME, no display is created for the key.
[EXIT|REFRESH]
Optionally, you can code EXIT or REFRESH to specify the branch action taken when a user presses key-name.
If EXIT or REFRESH is specified, the action is automatically executed by Easytrieve and the AFTER-SCREEN
procedure (if any) is not executed.
Specify EXIT to terminate the screen activity after editing and extracting data from screen fields into program
fields.
Specify REFRESH to restore the initial screen image by rebuilding it with current values of the program fields.
Data in screen fields is edited and extracted into program fields.
If no action is specified for key-name, you can test for key-name in your SCREEN activity procedures with the
system-defined field, KEY-PRESSED.
[IMMEDIATE]
Specify IMMEDIATE to execute a branch action, or the AFTER-SCREEN procedure if no action is specified,
without editing data in screen fields and moving it into the program fields.
Examples
The following table shows KEY statement examples:
Code Meaning
KEY F1 F1 is valid, but nothing is displayed on the screen. You must
provide code.
KEY F1 THRU F24 F1 to F24 are valid keys, but nothing is displayed on the screen.
You must provide code for all keys.
KEY F1 NAME 'Help' F1 is valid. F1=Help is displayed on the screen. You must provide
code.
940
Easytrieve® Report Generator 11.6
KEY F1 F4 F1 and F4 are valid keys, but nothing is displayed on the screen.
You must provide code.
KEY F1 THRU F4, F8 F1, F2, F3, F4, and F8 are valid keys, but nothing is displayed on
the screen. You must provide code for all keys.
KEY F12 EXIT NAME + F12 terminates the screen activity without moving data from
'CANCEL' IMMEDIATE screen fields into program fields. The AFTER-SCREEN procedure
(if any) is not executed. F12=CANCEL is displayed on the screen.
KEY F3 IMMEDIATE The AFTER-SCREEN procedure (if any) is executed without
editing or moving data in screen fields to program fields. Nothing
is displayed on the screen. You must provide code for F3.
KEY F3 EXIT F3 terminates the activity after editing and moving data from the
screen.
KEY F5 IMMEDIATE + REFRESH NAME + 'Refresh' F5 ignores the data on the screen and rebuilds the screen with
the values currently in memory. F5=Refresh is displayed on the
screen.
LINE Statement
The LINE statement in Easytrieve defines the contents of a report line.
One or more field values or literals can be contained on a report line; each as a line item. The data format of the field or
literal remains unchanged.
For control reports, any quantitative field on the LINE statement is automatically totaled on each summary line. This
feature can be overridden on the SUM statement.
In an XML-formatted report, only one LINE statement is allowed. All LINE statement parameters except field-name and
'literal' are ignored. For a detailed description of the XML report feature, see the Programming Guide.
This statement has the following format:
field name
{[ ] - }
font number
{[# - ] }
literal
{[ ] ' ' }
line number offset
LINE [ - ] {+ } ...
offset
{- }
column number
{COL - }
position number
{POS - }
[line-number]
Specify the optional line number with line-number. The line number specifies the position of the line in the line
group. The value must be from 1 to 99; the default is 1. You can omit line-number for the first LINE. You must
specify the line numbers for multiple LINE statements in ascending order with no duplicates. Specify at least one
data item (field-name or literal) on each LINE statement.
[#font-number]
#Font-number identifies the font specifications to be used for the next display item. You can only specify this
option if the report has been associated with an extended reporting printer. #Font-number identifies the number of
a font defined for the associated extended reporting printer. If you do not code the font, the next display item uses
the default font for the assigned extended reporting printer.
941
Easytrieve® Report Generator 11.6
{field-name}
Field-name can specify any field contained in an active file or in working storage. If the field is contained in a
file or W storage, data is transferred to the print line at the time the PRINT statement is executed. If the field is
contained in S storage, data is transferred to the print line at the time the line is printed.
NOTE
Field-name cannot specify a K field.
{'literal'}
'Literal' defines a static value for a line item. It must be a numeric literal, a hexadecimal literal, or an alphanumeric
literal. Alphanumeric literals must be enclosed within single quotes.
{+offset|-offset}
The space adjustment parameters, +offset or -offset, modify the spacing between line items. The offset value is
added to or subtracted from the SPACE value on the REPORT statement to give the absolute spacing between
line items. The absolute space value can range from zero to any amount that still allows the next line item to fit in
the line defined by LINESIZE on the REPORT statement.
{COL column-number}
COL specifies the column number where the next line item is placed. The value of column-number has a valid
range of 1 to nnn, where nnn cannot be so large that the following line item extends beyond the end of the line
defined by LINESIZE.
NOTE
You must specify the NOADJUST parameter on the REPORT statement to use the COL parameter.
When the report is associated with an extended reporting printer, an error results if two or more fields and/or
literals overlap.
{POS position-number}
The POS parameter lets you position line items on lines 2 to 99 so that they line up under particular line items on
the first line. Position-number corresponds to the line item number of LINE 01 under which the line item is placed.
Example
LINE 1 REGION BRANCH +5 DEPT EMPNAME
LINE 2 POS 4 ADDRESS
LINE 3 'NET==>' -2 PAY-NET POS 4 CITY ST ZIP
LINK Statement
The LINK statement in Easytrieve transfers control from the current program (parent program) to another named
program (child program).
When the child program terminates, execution is then returned to the statement following the LINK statement in the parent
program.
You can use LINK to invoke any program written in any language that is supported by the operating system in which the
program is executing, including Easytrieve. Similarly, the program can issue any command supported by the operating
system.
A program invoked using the LINK statement can issue terminal I/O or display reports, but only in fully-conversational
mode. For more information, see the Programming section.
NOTE
If you code the USING or GIVING parameter on the LINK statement, you must code a PROGRAM statement to
handle the parameters in the child program when it is written in Easytrieve.
942
Easytrieve® Report Generator 11.6
This statement has the following format:
program-field-name
{ }
LINK { } +
program-name
{' ' }
field-name
[ { } ]
[USING { } ] +
literal
[ {' ' } ]
field-name
[GIVING ]
{program-field-name|'program-name'}
Program-field-name is the name of the field that contains the name of the program to which you want to LINK.
'Program-name' is the name of the program to which you want to LINK.
USING {field-name|'literal'}
Code USING to pass a single parameter to the child program.
Field-name is the name of a field containing the parameter you want to pass to the child program.
'Literal' is a literal value you want to pass to the child program.
[GIVING field-name]
Specify GIVING to indicate that the parent program can accept a return parameter from the child program.
Field-name is the name of a field to which the returned parameter is written. For more information, see the
Programming section.
NOTE
If the child program returns a value, but the GIVING parameter is not specified, the value is ignored. Not
all operating systems allow the child program to return data to the parent program.
Example
LINK 'PROGB' USING EMP# GIVING PROGB-RETURN
LIST Statement
The LIST statement in Easytrieve regulates the printing or suppression of all statements in the printed output.
You can place a LIST statement anywhere in Easytrieve source code. LIST must be on a record by itself.
LIST does not appear in the printed output.
NOTE
The LIST statement and LIST option in the PARM statement are supported in r11.6 and use the same syntax
as r6.4. Note that the LIST option from r6.4 was renamed to LISTPRM, LISTFIL and LISTUC in r11.0. These
options are valid only in the Options table context (managed with ETOPLOAD).
To suppress all Easytrieve listing information, use the following:
LIST OFF
943
Easytrieve® Report Generator 11.6
PARM LIST(NOPARM)
For more information, see PARM Statement in "Statements N - R."
This statement has the following format:
[ON ] [MACROS ]
LIST [ ] [ ]
[OFF] [NOMACROS]
[ON|OFF]
ON specifies that all subsequent statements are to be printed. OFF suppresses the printing of all subsequent
statements.
[MACROS|NOMACROS]
MACROS specifies that macro statements are to be printed if a LIST ON is in effect. NOMACROS suppresses the
printing of macro statements.
Default: LIST ON MACROS.
MACRO Statement
The MACRO prototype statement in Easytrieve optionally defines the parameters of a macro. Use positional and
keyword parameters.
The MACRO prototype statement must be the first statement of a macro. The definition of positional and keyword
parameters follow the same rules as Field and Label names (see "Syntax Rules").
This statement has the following format:
positional count
MACRO [ - ] +
positional parameters keyword parameters
[ - ] ... [ - ] ...
MACRO
MACRO must be the first word on a prototype statement.
[positional-count]
Positional-count is an optional parameter that specifies the number of positional-parameters on the prototype
statement. It is required only when you use keyword-parameters and positional-parameters. You must code the
value as zero when you specify only keyword-parameters on the prototype statement.
[positional-parameters]
Use positional-parameters when a value is always required for the parameters each time the macro is invoked.
Frequently-used parameters are often positional, because you need only code the value of the parameter.
You must code positional-parameters before any keyword-parameters. The positional values are substituted
according to their position on the prototype statement.
[keyword-parameters]
Use keyword-parameters:
• To help keep track of a large number of parameters
• For optionally-used parameters
• To specify a default value for parameters
Keyword-parameters have two parts: the keyword name and the default value.
Examples
944
Easytrieve® Report Generator 11.6
The following series of examples depict the coding of macro prototype statements. For more information about system
services, see the Programming Guide.
Macro with No Substitution MACRO
...
...
Macro with Only Positional MACRO POS1 POS2
...
...
The number of positional-parameters is not indicated. You could have coded the optional positional-count parameter as a
'2.'
Macro with Only Keyword MACRO 0 KEY1 VALUE1 KEY2 VALUE2
...
...
Code the number of positional-parameters as zero. Positional-count is a required parameter when you use keyword-
parameters.
Macro with Positional and Keyword MACRO 1 POS1 KEY1 VALUE1
...
...
Macros with both positional and keyword-parameters require that you supply positional-parameters first, and also supply a
positional-count.
MASK Parameter
The optional MASK parameter in Easytrieve establishes a pattern (edit mask) for a field name.
The MASK parameter can be coded in the syntax of the following Easytrieve statements:
• DEFINE
• ROW
This statement has the following format:
mask identifier mask literal
[MASK ({[ - ][BWZ][' - ']|HEX })]
[mask-identifier]
Any letter from A to Y can be used as an optional mask-identifier. You can use the letter to identify a new mask
or to retrieve a mask that was previously defined in the Site Options Table or by a mask parameter on a previous
field definition. If the new mask that you identify does not already exist, the mask is retained for future reference.
If you subsequently reference a field-name for display, the associated letter identifier is automatically used to
determine the edit mask. Do not use the same identifier to establish more than one mask. You can define 192
unidentified edit masks and 25 identified edit masks for a total of 217 edit masks.
[BWZ]
The BWZ (blank when zero) option suppresses the display of field-name when it contains all zeros. BWZ can be
used by itself or with other options on the MASK parameter.
['mask-literal']
'Mask-literal' defines an edit mask and must be enclosed within single quotes. For information about coding the
actual edit mask, see the Editing Rules section that follows.
945
Easytrieve® Report Generator 11.6
HEX
HEX is a special edit mask that instructs the product to display the contents of field-name in double-digit
hexadecimal format. You can display fields of up to 50 bytes with the HEX mask.
NOTE
HEX edit masks are not allowed for VARYING fields.
Editing Rules
• Easytrieve edits field data only at the time of display and according to a specified edit mask pattern.
• The MASK parameter of the DEFINE and ROW statements specifies the edit mask pattern.
• Each digit of the field must be designated in the mask by an edit mask character:
Symbol Meaning
9 Prints a digit.
Z Prints a digit, except for leading zeros.
* Prints asterisks instead of leading zeros.
- Prints a minus sign prior to the first non-zero digit of a negative
number.
$ Prints a currency symbol prior to the first non-zero digit. The type
of currency symbol ($, ¥, £, _, etc.) is determined by the MONEY
Site Option.
x Insertion symbol -- prints any character with the edited data.
Decimal Digits
• When you display data, there is no implied relationship between the number of decimal digits in the edit mask and the
number of decimal digits in the field definition. You must code the correct number of decimal digits in the mask.
• When screen data is edited against a mask, the decimal point is automatically aligned.
Alphanumeric Fields
• Alphanumeric fields cannot be edited. (The exception is MASK HEX.)
Currency Symbols
• The currency symbol indicator is recognized in the input edit mask and appears in the output edit mask. For example, if
the currency symbol is set to #, a valid edit mask is '###,##9.99.'
Insertion Symbols
• Z, $, -, and * print digits only when coded as the first symbol of the edit mask, and only up to the first nine symbols.
All other symbols before the last digit position are treated as insertion symbols, including Z, $, -, and *. The symbols
comma (,) and period (.) can also be used as insertion symbols.
Insertion symbols before the first digit position always print.
• Insertion symbols between digit positions print according to the following rules:
– If the symbol that prints a digit following the insertion symbol is a 9, the insertion characters always print.
– If the digit position following the insertion symbols is a Z, $, -, or *, the insertion symbols print only if the digit position
prints. If the digit position does not print, the insertion symbols are replaced by fill symbols.
For example, in the mask 'ZZZ,999.99,' the comma always prints. In the mask 'ZZZ,Z99,99,' the comma prints only if the
digit prior to the comma is non-zero.
Fill Characters
946
Easytrieve® Report Generator 11.6
• The default fill character for an edit mask is a blank, unless an * (asterisk) is specified.
Mask Display Length
• When the first symbol of an edit mask is a dash (-) or a currency symbol, the display length of the mask is the length of
the mask plus one.
• The mask for a SUM field in a report is automatically increased by the number of digits that are specified by the
SUMSPACE parameter on the REPORT statement. The first digit position is duplicated the required number of times.
Negative Indicators
• Symbols following the last digit position specify the negative indicator. The symbols print if the value edited is negative.
If the value edited is positive, the symbols are replaced by fill characters.
System Default Masks - Numeric Fields
When you do not specify a mask, the following defaults apply:
Number of
Decimals Mask
none ZZZZZZZZZZZZZZZZZZ *
0 ZZZ,ZZZ,ZZZ,ZZZ,ZZZ,ZZZ-
1 ZZ,ZZZ,ZZZ,ZZZ,ZZZ,ZZZ.9-
2 Z,ZZZ,ZZZ,ZZZ,ZZZ,ZZZ.99-
3 ZZZ,ZZZ,ZZZ,ZZZ,ZZZ.999-
4 ZZ,ZZZ,ZZZ,ZZZ,ZZZ.9999-
5 Z,ZZZ,ZZZ,ZZZ,ZZZ.99999-
6 ZZZ,ZZZ,ZZZ,ZZZ.999999-
7 ZZ,ZZZ,ZZZ,ZZZ.9999999-
8 Z,ZZZ,ZZZ,ZZZ.99999999-
9 ZZZ,ZZZ,ZZZ.999999999-
10 ZZ,ZZZ,ZZZ.9999999999-
11 Z,ZZZ,ZZZ.99999999999-
12 ZZZ,ZZZ.999999999999-
13 ZZ,ZZZ.9999999999999-
14 Z,ZZZ.99999999999999-
15 ZZZ.999999999999999-
16 ZZ.9999999999999999-
17 Z.99999999999999999-
18 .999999999999999999-
* For zoned decimal fields with no decimals, the default mask
is '999999999999999999'.
Your system administrator can define additional edit masks in the Site Options Table when the product is installed.
Leading Zeros
Various methods are available for processing leading zeros.
Display
947
Easytrieve® Report Generator 11.6
When leading zeros are an important part of the number (such as social security numbers and part numbers) an edit mask
that displays these zeros is essential. These are examples of edit masks that display leading zeros:
Mask Field Contents Displayed Results
999-99-9999 053707163 053-70-7163
(99)-9999 006421 (00)-6421
Suppress
In some instances, leading zeros add unnecessary information and can confuse the reader. You can suppress the display
of leading zeros by using one of the following masks:
Mask Field Contents Displayed Results
$$,$$9 01234 $1,234
$$,$$9 00008 $8
$$,$$9.99 0123456 $1,234.56
ZZZ,ZZ9 000123 123
---,--9 +001234 1,234
---,--9 -001234 -1,234
Replace
In cases where fields must be protected (such as check amounts), you can use edit masks that replace leading zeros with
other symbols:
Mask Field Contents Displayed Results
**9 001 **1
**,**9 01234 *1,234
**,**9.99 0123456 *1,234.56
Negative Numbers
The symbols that are used as negative number indicators are displayed to the right of the last digit of the negative data
that you edit. You can use any symbols as negative number indicators, although the most typical indicators are the minus
sign (-) and the credit indicator (CR). If the number is positive, display of these symbols is inhibited. However, when the
field contents turn negative, the negative number indicators are edited into the displayed output as follows:
Mask Field Contents Displayed Results
ZZZ- -123 123-
ZZZ- +123 123
ZZZ CR -123 123 CR
ZZZ CR +123 123
ZZZ IS MINUS -123 123 IS MINUS
Examples
948
Easytrieve® Report Generator 11.6
The following edit mask examples illustrate editing mask rules:
Mask Field Contents Displayed Results
'Z,ZZZ,ZZZ.99' .01 .01
'ZZHELLOZZ9.99' 123.01 123.01
'ZZHELLOZZ9.99' 1234.01 1HELLO234.01
'**HELLO**9.99' 11.01 ********11.01
'**HELLO**9.99' 123.99 *******123.99
'**HELLO**9.99' 1234.99 *1HELLO234.99
'$$99$$99.99' 1234.99 $02$$34.99
'999Z999.99' 12345.99 012Z345.99
'SSN 999-99-9999' 123456789 SSN 123-45-6789
'ZZZ.99 MINUS' 12.45 12.45
'ZZZ.99 MINUS' -12.45 12.45 MINUS
'***.99 MINUS' 12.45 *12.45******
'***.99 MINUS' -12.45 *12.45 MINUS
'---.99' 123.45 123.45
'---.99' -123.45 -123.45
MEND Statement
The MEND statement in Easytrieve is an optional macro termination command used at the end of a macro.
MEND is required at the end of an instream macro. See also MSTART Statement.
MEND must be coded on a line by itself.
This statement has the following format:
MEND
MESSAGE Statement
The MESSAGE statement in Easytrieve allows you to issue your own specific messages for a screen activity.
You define the message type and specify the message text using the MESSAGE statement.
You can code the MESSAGE statement in a screen procedure or in another activity.
You can determine where messages of a particular level are displayed on the screen by overriding the default message
area on a DEFAULT statement. (The default message area is one line above the function key display area at the bottom
of the screen.) You can also use the DEFAULT statement to override default message attributes.
Easytrieve maintains an internal message area for each type of message. The MESSAGE statement updates the
pending message area. When the next screen is displayed, the screen message area is built from the pending message.
If different levels of messages are displayed on the same line (by default or override), then the message displayed is
controlled by message precedence. If two messages are sent to the same line on the screen, the message with the
highest severity is displayed. The severity precedence from highest to lowest is:
949
Easytrieve® Report Generator 11.6
• ACTION
• WARNING
• INFORMATION
If multiple MESSAGE statements of the same precedence are issued before displaying the screen, the last message
issued is displayed. There are Site Options that determine the display attributes for the three levels of messages. You can
override these attributes on a DEFAULT statement.
This statement has the following format:
literal
MESSAGE {' ' }
{ } ... +
field name
{ - }
[ {INFORMATION} ]
[LEVEL {WARNING } ]
[ {ACTION } ]
{'literal'} or {field-name}
Use 'literal' to define the text you want displayed in the message. Use field-name to specify a field whose contents
you want displayed as part of the message. A message can consist of a combination of literals and field-names.
The maximum length of a message is 130 characters. If the message exceeds the message area for the screen
on which it is displayed, the message is truncated.
[LEVEL {INFORMATION|WARNING|ACTION}]
Use LEVEL to specify the type of message you are defining.
INFORMATION messages typically inform a user that processing is proceeding normally.
WARNING messages tell the user that a potentially undesirable condition could occur or has occurred, even
though the error can be ignored.
ACTION messages are the most severe. They tell a user that an error has occurred and an action is required to
correct the error before continuing. ACTION is the default message level if no level is specified.
Example
epartment of not
MESSAGE 'D ' EMP-DEPT ' 900-999.' LEVEL ACTION
MOVE Statement
The MOVE statement in Easytrieve transfers character strings from one storage location to another. .
The MOVE statement is especially useful for moving data without conversion and for moving variable length data strings.
When you specify Format 1 parameters, data moves from left to right as if both areas were alphanumeric. The data
moved is unconverted. Send-file-name and receive-file-name can be any file in which data is currently available. For more
information about MOVE statement specification rules, see the Programming section.
When you process an SQL table as an Easytrieve file, the product knows which fields are nullable. This information is
obtained automatically from the SQL catalog when used to generate Easytrieve field definitions.
This statement has two formats.
Format 1
950
Easytrieve® Report Generator 11.6
send-file-name
{ }
send-record-name send-length-field
{ } [ ]
MOVE { } [ ] +
send-field-name send-length-literal
{ } [ ]
send-literal
{ }
receive-file-name receive-length-field
{ } [ ]
receive-record-name fill-character
TO { } [ ] [FILL ]
receive-field-name receive-length-literal
{ } [ ]
{send-file-name} or {send-record-name} or {send-field-name} or {send-literal}
The first parameter after the MOVE keyword (send-file-name, send-record-name, send-field-name, or send-literal)
identifies the sending data area. Send-file-name or send-record-name can be any file or database record with
current data availability. When send-file-name is an IDMS file, all records in the file are moved.
The default length of send-file-name is the current value of the system-defined RECORD-LENGTH field.
NOTE
If send-literal is non-numeric, it must be enclosed within single quotes.
[send-length-field] or [send-length-literal]
You can override the length of the sending field with the current value of send-length-field or send-length-literal.
{receive-file-name} or {receive-record-name} or {receive-field-name}
These parameters identify the receiving data area. Receive-file-name or receive-record-name can be any file or
database record with current data availability. The default length of receive-file-name is the current value of the
system-defined RECORD-LENGTH field.
[receive-length-field] or [receive-length-literal]
You can override the length of the receiving field with the current value of receive-length-field or receive-length-
literal.
[FILL fill-character]
Longer sending fields on the right are truncated. Longer receiving fields are padded on the right with spaces or a
character you specify in fill-character.
Fill-character must be one or two bytes. Non-numeric characters must be enclosed within single quotes. When fill-
character contains numeric characters, they are treated as a zoned decimal value.
Example
FILE PERSNL SQL (PERSONNEL)
SQL INCLUDE (EMP#) FROM PERSONNEL LOCATION * NULLABLE
DEFINE CTR1 W 10 N
DEFINE CTR2 W 2 N
DEFINE PLINE W 130 A
. . .
MOVE ZEROS TO CTR1, CTR2
MOVE SPACES TO PLINE
MOVE NULL TO EMP#
Format 2
{NULL }
951
Easytrieve® Report Generator 11.6
{SPACE }
{SPACES }
receive-field-name
MOVE { } TO ...
{ZERO }
{ZEROS }
{ZEROES }
{HIGH-VALUES}
{LOW-VALUES }
{NULL} or {SPACE} or {SPACES} or {ZERO} or {ZEROS} or {ZEROES} or {HIGH-VALUES} or {LOW-VALUES}
The first parameter after the MOVE keyword (NULL, SPACE, SPACES, ZERO, ZEROS, ZEROES, HIGH-
VALUES, or LOW-VALUES) identifies the sending data area. The default length of the field is the defined length of
receive-field-name. Moving spaces or zeros to a field fills the entire field with the selected character. Moving nulls
sets a nullable field to NULL. Moving spaces or zeros sets a nullable field to NOT NULL.
receive-field-name
Receive-field-name identifies the receiving data area. You can specify multiple receive-field-names. Receive-field-
names are set to the appropriate data format, such as packed zero for fields with a type of P.
Example
Statements:
DEFINE ASTERISK-LINE W 10 A VALUE '=========='
DEFINE COUNTER-1 W 10 N VALUE 99
DEFINE COUNTER-2 W 2 N VALUE 66
PROGRAM NAME MYPROG
DISPLAY COUNTER-1 +2 COUNTER-2
MOVE ZEROS TO COUNTER-1 COUNTER-2
DISPLAY COUNTER-1 +2 COUNTER-2
DISPLAY ASTERISK-LINE
MOVE '*' TO ASTERISK-LINE FILL '*'
DISPLAY ASTERISK-LINE
Results:
0000000099 66
0000000000 00
==========
**********
MOVE LIKE Statement
The MOVE LIKE statement in Easytrieve moves the contents of fields with identical names from one file, record, or
working storage to another.
Data movement and conversion follow the rules of the assignment statement.
This statement has the following format:
send-file-name receive-file-name
{ } { }
MOVE LIKE { } TO { }
send-record-name receive-record-name
{ } { }
952
Easytrieve® Report Generator 11.6
{send-file-name} or {send-record-name}
Send-file-name or send-record-name identifies the sending data area.
{receive-file-name} or {receive-record-name}
Receive-file-name or receive-record-name identifies the receiving data area.
Usage Notes
When you issue a MOVE LIKE statement, the contents of fields in send-file-name or send-record-name replace the
contents of fields with identical names in receive-file-name or receive-record-name. When receive-file-name or receive-
record-name contains overlapping fields, the order in which the fields are defined is important. The moves occur starting
with the first identically-named field in receive-file-name or receive-record-name and ending with the last identically-named
field in the file.
NOTE
The order in which fields are processed differs from previous versions of the product. In previous versions, the
moves occurred starting with the last identically-named field in receive-file-name or receive-record-name and
ended with the first identically-named field in the file.
If you want to move identically-named fields to or from working storage, you can use the keyword WORK as the send-file-
name or receive-file-name.
IDMS IDD Processing
In IDMS IDD processing, the fields of a file defined by an IDD statement are organized into group item structures. A group
item is a field subdivided by smaller fields. The smaller fields can themselves be group items and, therefore, subdivided by
even smaller fields. A group item owns its subdividing fields. A field without subdivision is called an elementary field.
In IDD processing, MOVE LIKE assigns a new value to the receiving field if all of the following conditions are met:
• The sending and receiving fields have matching names.
• The sending and receiving fields have matching qualifier (group item) names.
• Either the sending or receiving field is an elementary field.
Record name qualifiers do not participate in the process of matching qualifiers between two fields. For example, in a
MOVE LIKE from a record to a file (that owns the record), no matching is done between the record names of the receiving
file and qualifiers of source (record) fields. Therefore, source fields can be matched to a field under one record and
another source field can be matched to a field under a different record.
Differences Between MOVE LIKE and MOVE
The differences between the MOVE LIKE statement and the MOVE statement are as follows:
• The MOVE LIKE statement generates an assignment statement that provides data conversion according to data type.
For assignment statement specification rules, see the Programming section.
• The MOVE statement moves data without converting it.
Example
FILE PERSNL FB(150 1800)
REGION 1 1 N
BRANCH 2 2 N
NAME 17 16 A
NAME-LAST 17 8 A
NAME-FIRST 25 8 A
FILE MYFILE FB(150 1800)
953
Easytrieve® Report Generator 11.6
COPY PERSNL
JOB INPUT PERSONL NAME MYPROG
MOVE LIKE PERSNL TO MYFILE
PUT MYFILE
In this example, MOVE LIKE generates the following assignment statements:
MYFILE:NAME-FIRST = PERSNL:NAME-FIRST
MYFILE:NAME-LAST = PERSNL:NAME-LAST
MYFILE:NAME = PERSNL:NAME
MYFILE:BRANCH = PERSNL:BRANCH
MYFILE:REGION = PERSNL:REGION
Whatever values were in the fields of the file PERSNL are now found in the fields of the file MYFILE.
MSTART Statement
The MSTART statement in Easytrieve is used to begin an instream macro.
MSTART must be the first statement in the program.
This statement has the following format:
macro name
MSTART -
• macro-name
Specify the name of the macro. Macro-name must be from one to eight characters in length. The first character must be
alphabetic.
NOTE
For Panvalet and Endevor libraries the macro name can be from 1 to 10 characters in length.
NEWPAGE Statement
NEWPAGE in Easytrieve is a listing control statement that ejects the printer to the top of the next page before printing
the next line of the source program on the statement listing.
You can code a NEWPAGE statement anywhere in Easytrieve source code. NEWPAGE must be on a record by itself.
NEWPAGE does not appear in the printed output.
This statement has the following format:
NEWPAGE
PARM Statement
The PARM statement in Easytrieve overrides selected general standards for a program that are set in the Site Options
Table.
Alteration of the environment with the PARM statement lasts for only as long as the program is running.
Specification of the PARM statement is optional. Code the PARM statement only to modify the environment for your
program. If used, the PARM statement must be the first statement in your Easytrieve job.
Environment <============== PARM
...
954
Easytrieve® Report Generator 11.6
Library
...
Activities
Code PARM statement parameters and their subparameters in any order. You must code multiple subparameters within
parentheses.
PARM establishes program-level parameters in the following areas:
• SYNTAX, COMPILE, and LINK determine the mode of execution.
• ABEXIT, DEBUG, and LIST establish control over system facilities associated with compiler output and execution error
handling.
• VFM establishes system control parameters.
• SORT controls the interface to your installation's sort program.
• BIND, PLAN, PREPNAME, SQLID, SSID, USERID, PLANOPTS, and SQLSYNTAX establish parameters for SQL
execution.
• TRANSID controls CICS execution.
For more information about controlling Easytrieve with the PARM statement, see Compile and Link Your Program.
This statement has the following format:
PARM +
[ {SNAP } ]
[ABEXIT {NOSNAP} ] +
[ {NO } ]
[ {DYNAMIC } ]
[BIND {STATIC-ONLY} ] +
[ {ANY } ]
[ {STATIC } ]
[CALL {DYNAMIC} ] +
[ {AMODE24} ]
[ {EBCDIC } ]
[CODE PROCESS {ASCII } ] +
dbcs code name
[ { - - } ]
[CMPUSINGALTSEQ {YES|NO } ] +
[COMPILE] +
[ {MMDDYY}]
[DATE {YYMMDD}] +
[ {DDMMYY}]
[ [CLIST ] [PMAP ] [DMAP ] [FLDCHK ] [FLOW ]
[DEBUG ( [ ] [ ] [ ] [ ] [ ] +
[ [NOCLIST] [NOPMAP] [NODMAP] [NOFLDCHK] [NOFLOW]
[STATE ] [XREF {LONG } ] ]
number of table entries
[FLOWSIZ - - - ] [ ] [ { } ] ) ] +
[NOSTATE] [NOXREF {SHORT} ] ]
[ { }]
955
Easytrieve® Report Generator 11.6
[ENVIRONMENT{NONE }] +
[ {COBOL}]
program name
[LINK ( - [R])] +
[ [FILE ] [PARM ] ]
[LIST ([ ] [ ] ] +
[ [NOFILE] [NOPARM] ]
planname command program name
[PLAN ( [ - - ])] +
plan options module
[PLANOPTS ' - - '] +
access module access userid
[PREPNAME(SQL- - [' - '])] +
[SORT +
[ {NO } ]
([ALTSEQ { } ] +
alt sort table
[ {(YES [ - - ])} ]
device type
[DEVICE - ] +
storage amount
[ { - } ]
[MEMORY { } ] +
storage released
[ {(MAX [- - ])} ]
[ {ALL [CONSOLE] } ]
[ { [PRINTER] } ]
[ { } ]
[MSG ( {CRITICAL [CONSOLE] } ) ] +
[ { [PRINTER] } ]
[ {DEFAULT } ]
[ {NO } ]
core storage amount
[RELEASE - - ] +
number of work data sets
[WORK - - - - ])] +
auth id
[SQLID ' - '] +
[ {FULL } ]
[SQLSYNTAX {PARTIAL} ] +
[ {NONE } ]
ssid
[SSID ' '] +
[SYNTAX] +
transid
[TRANSID ' '] +
connect userid password
[USERID (' - ' [' '])] +
956
Easytrieve® Report Generator 11.6
[ [ {DISK } ] ]
buffer core storage
[VFM ([ - - ] [DEVICE { } ] ) ] +
[ [ {MEMORY} ] ]
[ {YES} ]
number-of-cylinders
[WORKFILE ( { } [ ] )]
[ {NO } ]
ABEXIT
[ABEXIT {SNAP|NOSNAP|NO}]
ABEXIT indicates the level of control exercised over program interrupt codes 1 to 11. SNAP prints a formatted dump of
Easytrieve storage areas along with an error analysis report. NOSNAP prints only an error analysis report. NO inhibits
Easytrieve interception of program interrupts.
It is advisable that the ABEXIT value in the site options table be set to NO, and to use the PARM ABEXIT(SNAP or
NOSNAP) during development as a debugging aid. Before moving the Easytrieve program into production, remove the
PARM ABEXIT override. This will reduce overhead for production applications.
AUTO-IDAA
[AUTO-IDAA {NONE|ENABLE|ENABFAIL}]
The AUTO-IDAA parameter can be specified in the PARM statement of programs that use Automatic Cursor Management
to enable automatic generation of SET CURRENT QUERY ACCELERATION commands.
You can specify this parameter for the following purposes:
• If you use an older Options Table that does not include the AUTOIDAA option
• To override the AUTOIDAA setting in a new Options Table that was generated after the APAR was installed
If AUTOIDAA is set to N in the options table, you can specify AUTO-IDAA ENABFAIL in the PARM statement for specific
programs to automatically generate the SET CURRENT QUERY ACCELERATION = ENABLE WITH FAILBACK
commands for only those programs.
NOTE
If the AUTO-IDAA parameter is included in the PARM statement of a program using Native Cursor Management,
it is ignored.
BIND
[BIND {DYNAMIC|STATIC-ONLY|ANY}]
BIND is an SQL-related parameter that identifies the type of SQL bind that you want for the execution of your application
program. BIND is currently used only by the mainframe DB2 SQL interface. It is ignored in other environments.
BIND DYNAMIC results in the dynamic execution of the SQL statements in your program. Dynamic processing
requires SQL statements to be dynamically prepared before they can be executed. The SQL interface controls the SQL
environment and does not prepare SQL statements repeatedly unless a syncpoint has been taken.
BIND STATIC-ONLY indicates that your application program is to execute statically. This option requires the creation of
a static-command-program that is then processed by the DB2 preprocessor. The DB2 preprocessor generates a DBRM
and finally a PLAN. During the execution of your application program, the SQL interface processes the SQL statements
in the static-command-program. If any errors are found in the static-command-program or its PLAN, SQL processing is
terminated.
BIND ANY indicates that a static-command-program is to be generated and a PLAN created, as with an option of STATIC-
ONLY. However, if the SQL interface encounters any errors with the static-command-program or its PLAN during the
execution of your application program, it switches to dynamic processing.
957
Easytrieve® Report Generator 11.6
BIND STATIC-ONLY or BIND ANY requires a value for the PLAN and LINK parameters. PLAN specifies the name of the
static-command-program and its DB2 PLAN name. LINK identifies the load module name of your link-edited Easytrieve
program. Your Easytrieve application program must run as a link-edited program for static SQL processing.
NOTE
Regardless of the option you specify for the BIND parameter, your program is dynamically processed when
being processed by the interpreter, that is, whenever the CHECK or RUN commands are executed.
If no value is specified for the BIND parameter in the program or in the options table, DYNAMIC is the default mode of
execution. Otherwise, the BIND value in the options table becomes the default.
The following table shows the use of the BIND parameter with the value specified in the options table.
BIND Parameter Options Table Options Table Options Table Options Table
Value Value Value Value
Value None A S D
None BIND defaults to BIND defaults to BIND defaults to BIND defaults to
DYNAMIC ANY STATIC-ONLY DYNAMIC
ANY ANY is the BIND ANY is the BIND Invalid -- an error Invalid -- an error
parameter parameter occurs occurs
STATIC-ONLY STATIC-ONLY is the STATIC-ONLY is the STATIC-ONLY is the Invalid -- an error
BIND parameter BIND parameter BIND parameter occurs
DYNAMIC DYNAMIC is the Invalid -- an error Invalid -- an error DYNAMIC is the
BIND parameter occurs occurs BIND parameter
CALL
[CALL {STATIC|DYNAMIC|AMODE24|AMODE31}]
CALL enables you to specify how subprograms referenced in CALL statements are linked to your Easytrieve program.
STATIC indicates that you want the subprogram to be linked with your Easytrieve program. DYNAMIC indicates that
you want the subprogram to be dynamically loaded. The default is DYNAMIC on the mainframe and in Windows, and the
default is STATIC in Unix environments. Individual subprograms can override this setting using the DECLARE statement.
AMODE24 indicates that this Easytrieve program will be calling an AMODE-24 subprogram, (using the CALL statement
or as a FILE EXIT). This will cause the Easytrieve runtime to allocate all dynamic storage and record buffers below the
16 MB line. AMODE31 allows all possible memory allocations to be made above the 16MB line. The default AMODE is
the setting of the AMODE31 system installation option.
CODE PROCESS
[CODE PROCESS {EBCDIC|ASCII|dbcs-code-name}]
(Mainframe DBCS) Use CODE dbcs-code-name to define the DBCS code system to be used for all K and M fields for this
file. If this parameter is not specified here, the default is taken from the processing code system as defined in the CA PSI
Subsystems DBCS Options Table.
Note: Using multiple code systems in a program can result in a longer execution time due to code system conversions.
CMPUSINGALTSEQ
[CMPUSINGALTSEQ {YES|NO}]
Identifies whether the collating sequence table is used for the character compare process. YES indicates that the collating
sequence table is used. NO indicates that the collating sequence table is not used. For more information about the
alternate collating sequence table, see Alternate Collating Sequence Table.
COMPILE
958
Easytrieve® Report Generator 11.6
[COMPILE]
COMPILE terminates execution after the completion of the syntax check and compile operations. Use COMPILE to review
the code generated in the Easytrieve Program Map (PMAP).
DATE
[DATE {MMDDYY|YYMMDD|DDMMYY}]
DATE specifies the format of the date placed at the top of the compiler listing and the date stored in the system-defined
SYSDATE field. Valid values are MMDDYY, YYMMDD, and DDMMYY, where MM is the month, DD is the day, and YY is
the year.
DEBUG
[DEBUG]
DEBUG and its subparameters control generation of certain system outputs.
WARNING
These outputs are very helpful to analyze programming errors that cause abnormal execution termination
(ABENDs).
ENVIRONMENT
ENVIRONMENT (z/OS only)
Specifies to establish the proper execution environment prior to calling COBOL subprograms. The environment is
established prior to each JOB activity that contains a CALL statement and is terminated after the activity for which it was
established.
When used on the PARM statement, it establishes the default (NONE or COBOL) for all JOB activities in the entire
program. When this parameter is absent, the default for ENVIRONMENT depends on the ENVIRON setting within the Site
Options Table being used. Using this parameter overrides that setting.
This parameter does not establish the default for PROGRAM activities. If the environment is desired for the PROGRAM
activity, the ENVIRONMENT parameter must be specified on the PROGRAM statement. The ENVIRONMENT is not
supported in SORT activities, or in REPORT PROCs executed within a SEQUENCEd REPORT. For more information
about this parameter and its functionality of this feature, see the PROGRAM and JOB statements, and the Code
Programs section.
LINK
[LINK (program-name [R])]
On the mainframe, controls the generation of the link editor NAME command as follows:
• If LINK(program-name) is specified, 'NAME program-name' is generated as the last line in the object deck.
• If LINK(program-name R) is specified, 'NAME program-name (R)' is generated as the last line in the object deck. The
subparameter R specifies that the program replaces an existing program with the same name.
• If no LINK parm is specified, no NAME command is generated into the object deck. In this case, the NAME command
must be provided manually in the link edit JCL. For example:
//LINK EXEC PGM=IEWL,PARM='LET,LIST,MAP'
...
//SYSLIN DD DISP=SHR,DSN=&&OBJECT.FROM.COMPILE
// DD *
NAME PROGNAM(R)
/*
NOTE
On non-mainframe platforms, LINK is ignored
959
Easytrieve® Report Generator 11.6
LIST
[LIST [FILE|NOFILE] [PARM|NOPARM]]
LIST controls the printing of certain system outputs.
FILE prints file statistics at the end of each activity. NOFILE inhibits this operation.
PARM prints a compile summary and system parameters at the conclusion of the syntax check operation. NOPARM
inhibits this operation.
[PLAN (planname [command-program-name])]
PLAN is an SQL parameter. Currently, it is used only by the mainframe DB2 SQL interface.
The PLAN parameter enables you to specify values for the static-command-program and its DB2 PLAN. The name
you specify for the static-command-program must be a valid load module name. This name must be different from the
program-name specified for the LINK parameter.
The value specified for planname must be the name of the DB2 PLAN that identifies the DBRM of the given static-
command-program. For information about how to generate the static-command-program, see Program Environment.
If not specified, command-program-name defaults to planname.
Because the link-edit of the static-command-program and the bind of the DB2 PLAN are performed outside the control of
Easytrieve , you must specify the correct names on the batch JCL to ensure successful execution of your program.
[PLANOPTS 'plan-options-module']
PLANOPTS is an SQL parameter. Currently, this parameter is used only by the Datacom/DB SQL interface.
Use PLANOPTS to specify the name of the plan options module that is to override the default Easytrieve plan options
module.
[PREPNAME (SQL-access-module ['access-userid'])]
PREPNAME is an SQL parameter. Currently, it is used by the SQL/DS and Datacom/DB SQL interfaces.
For the SQL/DS SQL interface, the PREPNAME parameter enables you to specify the name of the access module or
package that is to be associated with the SQL statements for this application program.
For the Datacom/DB SQL interface, PREPNAME enables you to specify the access plan.
For either database, the PREPNAME parameter also enables you to specify an owner ID ('access-userid') for the access
module or access plan. For information about obtaining an authorization ID, see your specific database documentation.
If PREPNAME is not specified, SQL-access-module defaults to program-name on the LINK parameter. If the LINK
parameter is not specified, SQL-access-module defaults to the value specified in the Site Options Table.
NOTE
You should specify a unique value for the SQL-access-module for each Easytrieve program. If you use the
same name for either parameter value, database catalog contention can occur, or an existing access module
could be replaced with another one. For information about establishing naming conventions, see your database
administrator.
PREPNAME can be abbreviated to PREP.
[SORT]
SORT overrides the default parameters used to interface with your installation's sort program. For information about these
SORT parameters, see the installation procedures on your product media.
• – [ALTSEQ {NO|(YES [alt-sort-table])}]
ALTSEQ identifies the collating sequence table for the sort process. NO indicates usage of the standard table. YES
identifies an alternative table. Alt-sort-table specifies the name of the table that you provide. When you omit alt-sort-
table, the default name is EZTPAQTT.
– [DEVICE device-type]
DEVICE specifies the device type for dynamically allocated sort work data sets. Device-type can be any valid unit
name or generic device type.
– [MEMORY {storage-amount|(MAX [-storage-released])}]
MEMORY specifies the maximum amount of core storage used by the sort program. Storage-amount is the amount
of storage made available for the sort and must be a value from 16 to 4096. MAX allows the sort program to obtain
maximum storage available. Storage-released is the amount of storage released (for system use) after the MAX
960
Easytrieve® Report Generator 11.6
amount has been reserved. A minus sign must immediately precede storage-released. Storage-amount and
storage-released values represent 1024-byte units of storage.
– [MSG {ALL|CRITICAL [CONSOLE|PRINTER]}|{DEFAULT|NO}]
Specifies the level of messages to be output by the sort program.
ALL outputs all messages. CRITICAL outputs only critical level messages. DEFAULT outputs messages at the level
specified when the sort program was installed. NO outputs no messages.
For ALL or CRITICAL messages, specify the location at which messages are received: PRINTER or CONSOLE.
– [RELEASE core-storage-amount]
RELEASE determines the amount of core storage reserved from the sort program. The value of core-storage-
amount should be set large enough to supply all of the core storage needs of any exits used as a part of the sort
process. Core-storage-amount must be a numeric value from 0 to 1024. The value represents 1024-byte units of
storage.
– [WORK number-of-work-data-sets])]
WORK specifies the type and number of work data sets used by the sort.
The value of number-of-work-data-sets controls the allocation of work data sets. When number-of-work-data-sets
is zero, you must supply DD statements for all work data sets (none are dynamically allocated). A number-of-work-
data-sets value from 1 to 31 specifies the number of work data sets dynamically allocated by the sort program.
[SQLID 'auth-id']
SQLID is an SQL parameter. Currently, this parameter is used only by the mainframe DB2 SQL interface.
SQLID enables you to change the authorization ID of your SQL session. If you specify a value for 'auth-id', the DB2 SET
CURRENT SQLID command is executed by the DB2 SQL interface at compile time. For the SET CURRENT SQLID
command to execute successfully, you must have installed the Pan/SQL Interface for a DB2 release of 2.1 or greater.
You must also have the correct DB2 authorization to execute the SET CURRENT SQLID command. For more information
about the SET CURRENT SQLID command, see your DB2 documentation.
This parameter is in effect only for the compilation of your application program, unless your program is coded using
automatic processing. If your program is coded using automatic processing, the SET CURRENT SQLID command is
executed again at the start of runtime. For native SQL processing, you must code the SET CURRENT SQLID command in
your program if you want to change the value for the current authorization ID.
For more information, see the SQL Database Processing section.
[SQLSYNTAX {FULL|PARTIAL|NONE}]
Use SQLSYNTAX to specify the level of SQL syntax checking that is to be performed on the SQL statements coded in
your program.
Specify FULL to indicate that detail level syntax checking should be performed. An SQL PREPARE statement is executed
by the Pan/SQL interface for those SQL statements that can be dynamically prepared. If you specify FULL, your DBMS
catalog must be available to Easytrieve .
Specify PARTIAL to indicate that SQL statements in your program should be syntax checked for valid commands and
secondary keywords. No connection is made to the DBMS catalog unless you have coded the SQL INCLUDE statement.
If you coded an SQL INCLUDE statement, your DBMS catalog must be available to Easytrieve . Your program cannot be
executed until it has been fully syntax checked, as described above.
Specify NONE with a BIND STATIC-ONLY parameter if you want syntax checking to be performed by the DB2
preprocessor in a batch environment. NONE causes partial syntax checking, as described above. If no compile errors are
found, your program executes, unless Easytrieve errors are found. No connection is made to the DBMS catalog unless
you have coded the SQL INCLUDE statement. If you coded an SQL INCLUDE statement, your DBMS catalog must be
available to Easytrieve .
If you specify NONE for a non-DB2 environment, partial syntax checking is performed, but the program is not executed
until full syntax checking is performed.
When running under the Easytrieve interpreter, dynamic processing is always performed. An option of NONE is effective
only for the batch compilation and execution of your program.
[SSID 'ssid']
SSID is an SQL parameter. Currently, SSID is used only by the DB2, Sybase, and Ingres interfaces.
961
Easytrieve® Report Generator 11.6
(For mainframe DB2) You can use SSID to specify the DB2 subsystem ID. If you specify this value, it is used at both
compile and runtime. If you do not specify the DB2 subsystem ID, the subsystem ID from the Site Options Table is used.
If no DB2 subsystem ID is specified in the Site Options Table, the SQL interface uses the ID from the DB2 system default
module DSNHDECP. The value of the subsystem ID is obtained at compile and runtime dynamically; therefore, there is
no need to recompile your program to change the ID. For the default values defined for your DB2 system, see your DB2
systems programmer or administrator.
(For non-mainframe platforms) You can use SSID to specify the name of the database or ODBC data source to which this
session will connect. If you do not specify the subsystem ID, the subsystem ID from the Site Options Table is used. If no
DB2 subsystem ID is specified in the site options table, DB2 uses the ID in the DB2DBDFT environment variable.
SSID is ignored in CICS.
[SYNTAX]
SYNTAX terminates Easytrieve processing after the syntax check operation.
[TRANSID 'transid']
(CICS only) Use TRANSID to specify the transaction identifier of a program to which control is transferred when the
application user presses an attention key after a pseudo-conversational terminal I/O.
[USERID ('connect-userid' ['password'])]
USERID is an SQL parameter. Currently, USERID is used by the SQL/DS, IDMS, and non-mainframe SQL interfaces.
USERID is used by the SQL interface to establish a connection to the database for compilation of the application program.
(For SQL/DS) You can use USERID to specify a valid userid and password for an explicit CONNECT.
(For IDMS) You can use 'connect-userid' to specify the IDMS dictionary name for an explicit CONNECT. If you do not
specify USERID, an implicit connection occurs according to the rules of the given database system.
(For non-mainframe SQL interfaces) You can use 'connect-userid' to specify the user identifier under which this session
will run. If you do not specify USERID, an explicit connection occurs without an 'identified-by' clause. 'Password' is
ignored.
NOTE
USERID can be abbreviated as USER.
[VFM ([buffer-core-storage] [DEVICE {DISK|MEMORY}])]
VFM establishes the work area parameters used by the Easytrieve Virtual File Manager access method.
Buffer-core-storage specifies the amount of core storage made available for the buffer pool. Valid numeric values for
buffer-core-storage are 6 to 4096. Buffer-core-storage represents 1024-byte units of storage.
DEVICE DISK reverts to disk device usage when the site option default is DEVICE MEMORY. DEVICE MEMORY inhibits
the use of an overflow device.
[WORKFILE ( {YES|NO} [number-of-cylinders])]
Use WORKFILE YES instead of VFM if you have multiple large reports in your program. NO is the default. When YES is
specified, sequential temporary disk files will be dynamically allocated for use as Report Workfiles. The space allocated
for each file is indicated by the number-of-cylinders parameter. If DD statements are coded for the Report Workfiles, the
number-of-cylinders parameter is ignored. For more information about print statement processing, see PRINT Statement
(Report Processing).
Examples
The following examples illustrate typical uses of the PARM statement.
Example: Use of PARM for Production
PARM LINK(MYPROG) DEBUG(CLIST, DMAP) + SORT (MSG (ALL, PRINTER))
FILE PERSNL FB(150 1800)
%PERSNL
JOB INPUT PERSNL NAME MYPROG
PRINT REPORT1
962
Easytrieve® Report Generator 11.6
*
REPORT REPORT1
LINE EMPNAME DEPT
Example: Use of PARM for Program Testing
PARM ABEXIT (SNAP) + DEBUG (PMAP, DMAP, FLDCHK, FLOW, + FLOWSIZ (20), STATE)
FILE PERSNL FB(150 1800)
%PERSNL
JOB INPUT PERSNL NAME MYPROG
PRINT REPORT1
*
REPORT REPORT1
LINE EMPNAME DEPT SALARY-COD
PERFORM Statement
The PERFORM statement in Easytrieve transfers control to a procedure and, after the procedure has been executed,
returns control to the next executable statement after the PERFORM statement.
When Easytrieve encounters the PERFORM statement, it immediately branches to the named procedure. After exiting
from the procedure, program execution continues with the next executable statement following the just-executed
PERFORM statement.
PERFORM statements in a procedure can invoke other procedures; this is called procedure nesting. However, recursion
is not permitted. That is, procedure A can invoke procedure B, but procedure B cannot then invoke procedure A. If
recursion is attempted, unpredictable results can occur.
This statement has the following format:
proc name
PERFORM -
proc-name
Specify the name of the procedure to be executed.
Example
The following example illustrates the use of the PERFORM statement in executing a user procedure:
FILE PERSNL FB(150 1800)
%PERSNL
XMAS-BONUS W 4 P 2 VALUE 0
*
JOB INPUT PERSNL NAME MYPROG
IF PAY-GROSS < 300.99 PERFORM SPECIAL-BONUS
ELSE PERFORM STANDARD-BONUS
END-IF
PRINT MYREPORT
*
SPECIAL-BONUS. PROC
XMAS-BONUS = PAY-GROSS * 1.20
END-PROC
*
963
Easytrieve® Report Generator 11.6
STANDARD-BONUS. PROC
XMAS-BONUS = PAY-GROSS * 1.05
END-PROC
*
REPORT MYREPORT
LINE NAME-LAST XMAS-BONUS
POINT Statement
The POINT statement in Easytrieve enables you to establish the position in an INDEXED or RELATIVE file from which
subsequent data is sequentially retrieved.
Data in the file becomes available only after the next successful sequential retrieval by either automatic file input or a GET
statement.
You cannot use a file presence test (IF file-name) to test the success of a POINT.
You cannot issue a GET PRIOR statement following a POINT statement, or a GET statement following a POINT PRIOR
statement. For more information, see GET Statement in the "Statements G - M."
GE is not supported for POINT PRIOR when the underlying access method does not support it.
This statement has the following format:
{= }
field name
{EQ} { - }
file name
POINT - [PRIOR] {GE} { } [STATUS]
literal
{GQ} { }
{>=}
file-name
File-name must be the same as on a FILE statement that describes an INDEXED or RELATIVE file.
[PRIOR]
Specify PRIOR if you want to use PRIOR on the GET statement. For more information, see GET Statement in
"Statements G - M."
{= } or {EQ} or {GE} or {GQ} or {>=}
Equal operators (= and EQ) initiate a file position search, based on an exact match between the file's keys and
the search value. The greater-than operators (GE, GQ, and >=) initiate a file position search, based on a file's key
being equal to or greater than the search value.
{field-name} or {literal}
The search value can be any valid field-name or literal. Alphanumeric literals must be enclosed within single
quotes. Easytrieve does not change the data format of field-name or literal. The search value must have the
same length as the file's key. RELATIVE files require field-name to be a 4-byte binary integer field. Field-name
cannot be nullable. Literal is not allowed for a RELATIVE file.
[STATUS]
Specify the STATUS parameter whenever the possibility exists for an unsatisfactory completion of the input/output
request.
STATUS checks input/output processing to see if it was performed correctly. STATUS causes the file's FILE-
STATUS field to be set with the appropriate return code. To determine the meaning of the contents of FILE-
STATUS, see the appendix "System-Defined Fields." Normally, a zero or non-zero test is sufficient.
NOTE
FILE-STATUS is not defined if you do not specify a file type parameter on the FILE statement.
964
Easytrieve® Report Generator 11.6
If you do not code STATUS and the operating system returns a non-zero status, Easytrieve issues an
appropriate diagnostic message.
In addition to FILE-STATUS, IF EOF file-name is true when the search value is greater than the highest key in the
file.
NOTE
CICS does not set EOF.
Example
The following example illustrates the use of POINT:
FILE PERSNL INDEXED
%PERSNL
JOB INPUT NULL NAME MYPROG POINT PERSNL GE '01963' STATUS
IF FILE-STATUS NE 0 OR EOF PERSNL
DISPLAY 'BAD POINT...FILE STATUS= ' FILE-STATUS
STOP
END-IF
GET PERSNL STATUS
IF FILE-STATUS NE 0
DISPLAY 'BAD GET...FILE STATUS= ' FILE-STATUS
ELSE
DISPLAY HEX PERSNL
END-IF
STOP
For more detailed examples on the use of POINT in file processing, see the Programming Guide.
POP Statement
The POP statement in Easytrieve is a listing control statement that restores previous listing control indicators.
POP is especially useful in macros to control the listing of the macro expansion without affecting listing control indicators
outside the macro. Use the PUSH statement to save the current indicators. You can then set listing control indicators for
use during macro expansion. The POP statement restores the saved indicators.
NOTE
Use the LIST statement to set listing control indicators.
You can place POP statements anywhere in the Easytrieve source code. POP must be on a record by itself. POP does
not appear in the printed output.
This statement has the following format:
POP
PRINT Statement
The PRINT statement in Easytrieve produces report output. Issue the PRINT statement to initiate a printed line.
In general, report output is not written directly to a report's printer file as with DISPLAY, but is scheduled for deferred
formatting and writing to the report's printer file, perhaps following resequencing of an intermediate file.
965
Easytrieve® Report Generator 11.6
For detailed examples of the use of PRINT in report processing, see the Programming Guide.
When you require an intermediate file (referred to as a report work file) for a report, executing PRINT causes fixed format
records (called spool records) to be output to the work file. Easytrieve determines the format of these records, which
includes all the fields required to produce the report except those in S type working storage.
This statement has the following format:
report name
PRINT [ - ]
[report-name]
Report-name is the name of the report as specified on a REPORT statement. If not given, it is assumed to be the
first report in the JOB activity.
Example
FILE PERSNL FB(150 1800)
%PERSNL
JOB INPUT PERSNL NAME PRINT-RPT PRINT REPORT1
REPORT REPORT1
TITLE 'PERSONNEL REPORT'
LINE EMP# SSN EMPNAME
PROC Statement
The PROC statement is used to begin an Easytrieve procedure and consists of a label naming the procedure and the
PROC statement.
A procedure is a group of user-written Easytrieve statements designed to accomplish a particular objective. The syntax
of a procedure has two statements:
• A label naming the procedure
• The PROC statement
In most cases, you can code any statement in a procedure. However, you cannot code certain input/output statements
(such as GET, PUT) in procedures invoked during SORT or REPORT processing.
PERFORM statements within a procedure can invoke other procedures; this is called procedure nesting. However,
recursion is not permitted. That is, procedure A can invoke procedure B, but procedure B cannot then invoke procedure A.
If recursion is attempted, unpredictable results can occur.
Screens and reports can contain special-named procedures. Each procedure is explained separately in this manual.
The screen procedures are as follows:
• AFTER-SCREEN
• BEFORE-SCREEN
• INITIATION
• TERMINATION
The report procedures are as follows:
• AFTER-BREAK
• AFTER-LINE
• BEFORE-BREAK
• BEFORE-LINE
• ENDPAGE
• REPORT-INPUT
• TERMINATION
966
Easytrieve® Report Generator 11.6
This statement has the following format:
Format 1
proc name
- . PROC
statement
-1
...
statement n
-
END-PROC
Format 2
proc name
-
PROC
statement
-1
...
statement n
-
END-PROC
proc-name
Proc-name is a label that identifies the procedure. A label:
• Can be up to 128 characters in length
• Can contain any character other than a delimiter
• Can begin with A to Z, 0 to 9, or a national character (#, @, $)
• Must not consist of all numeric characters
Proc-name must be followed by the keyword PROC as a separate statement.
statement-1...n
Statement-1 to statement-n are the statements that accomplish your procedure's task.
END-PROC
The END-PROC statement delimits the statements contained in the procedure.
PROGRAM Statement
The PROGRAM statement in Easytrieve identifies and initiates a processing activity that can optionally initiate JOB,
SORT, and SCREEN activities.
NOTE
Programs that include the PROGRAM statement must be compiled with the NEWFUNC option set to Y. The
following message is displayed when a program that includes the PROGRAM statement is compiled with the
NEWFUNC option set to N (compatibility mode):
*******B014 UNABLE TO RECOGNIZE STATEMENT
For more information about the NEWFUNC option, see Features and Enhancements Since Release 6.4.
A PROGRAM statement is required when:
• A program is the target of a TRANSFER from another program and parameters are passed between programs. See
TRANSFER Statement in "Statements S - Z."
• A program is the child program linked to from a parent program and parameters are passed between programs. See
LINK Statement in "Statements G - M."
• A parameter is passed to a program invoked from the operating system.
• You want to selectively execute other activities or execute a single activity multiple times.
967
Easytrieve® Report Generator 11.6
A PROGRAM statement defines an activity in which JOB, SORT, and SCREEN activities can be conditionally invoked.
If there is no PROGRAM statement, any JOB or SORT activities are sequentially executed until a SCREEN activity is
detected. The SCREEN activity is then executed. The sequential execution of activities does not proceed past the first
SCREEN activity. Any remaining activities must be executed by the first SCREEN activity.
A program terminates when:
• The bottom of the activity is reached
• A STOP EXECUTE statement is executed
• A TRANSFER statement is executed
A PROGRAM statement can be used to execute a sequence of statements. You can also use a JOB INPUT NULL
statement; however, you must then execute a STOP statement to terminate the activity.
This statement has the following format:
[ [ACTIVITY ] [TERMINAL ] ]
program name
PROGRAM [NAME - ] [COMMIT ([ ] [ ])] +
[ [NOACTIVITY] [NOTERMINAL] ]
[ENVIRONMENT {NONE }] +
[ {COBOL}]
field name field name
[USING - ] [GIVING - ]
[NAME program-name]
The NAME parameter names the processing activity. Program-name identifies the program. Program-name:
• Can be up to 128 characters in length
• Can contain any character other than a delimiter
• Can begin with A to Z, 0 to 9, or a national character (#, @, $)
• Must not consist of all numeric characters
This parameter is used for documentation purposes.
[COMMIT ([ACTIVITY|NOACTIVITY] [TERMINAL|NOTERMINAL])]
Specify the COMMIT parameter to control the logical unit of work. COMMIT indicates when the activity commits
recoverable work. Each commit point posts all updates, additions, and deletions, terminates holds, and closes
SQL cursors.
Specify ACTIVITY to commit all recoverable work during the normal termination of the activity. Specify
NOACTIVITY to tell Easytrieve not to commit at the end of the activity. ACTIVITY is the default.
Specify TERMINAL to commit all recoverable work during any terminal I/O operation. In CICS, this results in
terminal I/O being performed in a pseudo-conversational mode. Specify NOTERMINAL to tell Easytrieve not to
commit during a terminal I/O. TERMINAL is the default.
If this program is linked to by another Easytrieve program, this program performs terminal I/O as if
NOTERMINAL was specified.
NOTE
You can also issue your own COMMIT and ROLLBACK statements to commit or recover work on a
controlled basis.
For more information about commit processing, see the Programming Guide.
ENVIRONMENT (z/OS only)
Specifies to establish the proper execution environment prior to calling any COBOL subprograms. The
environment is established prior to the PROGRAM activity startup and is terminated after the activity has
terminated. ENVIRONMENT(COBOL) is ignored if the PROGRAM activity contains no CALL or EXECUTE
statement, and if no FILE EXITs are specified.
968
Easytrieve® Report Generator 11.6
The COBOL ENVIRONMENT started at the PROGRAM activity level stays active during any JOB activities
invoked from that PROGRAM activity. If the PROGRAM activity does not start a COBOL ENVIRONMENT, (or if
there is no PROGRAM activity), the COBOL ENVIRONMENT will be started for the JOB activities as directed by
the PARM ENVIRONMENT or the JOB ENVIRONMENT parameter specification.
When this parameter is absent, the default is ENVIRONMENT(NONE). No PARM statement, or Site Option
default is used. See JOB Statement for more information about this parameter and the functionality of this feature.
WARNING
For performance considerations, we recommend that you set the ENVIRONMENT option to COBOL if
many Easytrieve programs are calling Language Environment subprograms. The option should be set
to NONE if most CALLs are made to non-Language Environment subprograms.
[USING field-name]
Specify USING to indicate that this program (child program) can accept a parameter from the parent program or
operating system. Field-name is the name of a field to which the parameter is passed.
NOTE
The data for the field-name consists of a two-byte length value followed by the data. If the field-name
definition includes the VARYING parameter, the data in the field is alphanumeric and of varying length.
This applies to the standard way that z/OS invokes main programs. For more information about the
VARYING parameter, see DEFINE Statement.
If the program is linked via the LINK option of the PARM statement, the program could be invoked
directly on the JCL EXEC statement. Other programs could also invoke the program, but the
other program must observe the standard type one linkage convention. For more information, see
"Conventions for passing information through a parameter list" in the IBM z/OS MVS Programming:
Assembler Services Guide, available on the IBM website.
[GIVING field-name]
Code GIVING to return a single parameter to the parent program. Field-name is the name of a field containing the
parameter you want to return to the parent program.
Example: Equivalent Statements
FILE ...
... PROGRAM NAME EXAMPLE1
EXECUTE JOB1
EXECUTE PANEL1
JOB NAME JOB1
...
SCREEN NAME PANEL1
...
is equivalent to:
FILE ...
...
JOB NAME JOB1
...
SCREEN NAME PANEL1
...
Example: PROGRAM Statement with the USING Parameter
This example shows how the USING parameter can be used with the PROGRAM statement. The field that the USING
parameter accesses is named JCL-PARM, which is defined in the code with the VARYING option. The program
969
Easytrieve® Report Generator 11.6
TESTPARM receives the value for JCL-PARM from the PARM argument of the EXEC statement for the parent program
EZTPA00.
Program code:
//COMP EXEC PGM=EZTPA00,PARM='0123456789ABCDEF'
//SYSIN DD *
PARM DUMP(PCODE)
DEFINE JCL-PARM S 100 A VARYING
PROGRAM NAME TESTPARM USING(JCL-PARM)
EXECUTE TESTPARM1
JOB INPUT(NULL) NAME TESTPARM1
DISPLAY 'JCL-PARM: +' JCL-PARM '+'
DISPLAY 'JCL-PARM:LENGTH: +' JCL-PARM:LENGTH '+'
STOP
Program output:
JCL-PARM: +0123456789ABCDEF +
JCL-PARM:LENGTH: + 16 +
PUSH Statement
The PUSH Statement in Easytrieve is a listing control statement that saves the current listing control indicators.
PUSH is useful in macros to control the listing of the macro expansion without affecting the listing control indicators
outside the macro. PUSH saves the current indicators. You can then set the listing control indicators for use during macro
expansion. Use the POP statement to restore the saved indicators.
NOTE
Use the LIST statement to set listing control indicators.
You can code a PUSH statement anywhere in Easytrieve source code. PUSH must be on a record by itself. PUSH does
not appear in the printed output.
This statement has the following format:
PUSH
PUT Statement
The PUT statement in Easytrieve performs sequential file output. PUT outputs records to SEQUENTIAL files and also
adds consecutive records (mass sequential insertion) to an INDEXED or RELATIVE file.
To take advantage of VSAM's mass-sequential-insertion capabilities, you can use the PUT statement to add many records
to the same place in any established VSAM file.
If you use the PUT statement, you must include the UPDATE parameter on the FILE statement for RELATIVE or
INDEXED files. You must specify CREATE for SEQUENTIAL files. UPDATE informs Easytrieve that all input records can
potentially be updated or deleted.
This statement has the following format:
input file name
[ { - - ] }]
output file name
PUT - - [FROM { }][STATUS]
input record name
[ { - - }]
970
Easytrieve® Report Generator 11.6
output-file-name
The output-file-name parameter identifies the output file.
[FROM {input-file-name|input-record-name}]
FROM identifies the file or record from which the current record is copied.
When input-file-name is specified, the length of the output data is the same as output-file-name: RECORD-
LENGTH. The current value of input-file-name: RECORD-LENGTH is equal to the length of the input data.
However, if the length of the output file is greater than the length of the input file, the excess storage is not
initialized. Also, use of the FROM parameter does not update the data area of the output file.
For more information about RECORD-LENGTH, see the Programming Guide.
[STATUS]
Specify the STATUS parameter whenever the possibility exists for an unsatisfactory completion of the input/output
request.
STATUS checks input/output processing to see if it was performed properly. STATUS causes the file's FILE-
STATUS field to be set with the appropriate return code. To determine the meaning of the contents of FILE-
STATUS, see System-defined Fields. Normally, a zero or non-zero test is sufficient.
NOTE
FILE-STATUS is not defined if you do not specify a file type parameter on the FILE statement.
If you do not code STATUS and the operating system returns a non-zero status, Easytrieve issues an
appropriate diagnostic message.
Example
FILE FILEA INDEXED UPDATE
%PERSNL
FILE PERSNL
COPY FILEA
JOB INPUT PERSNL NAME MYPROG
PUT FILEA FROM PERSNL STATUS
IF FILE-STATUS NE 0
DISPLAY 'ADD FAILED'
DISPLAY HEX PERSNL
STOP
END-IF
READ Statement
The READ Statement in Easytrieve provides random access to INDEXED and RELATIVE files.
The key specified is normally a working storage field or a field in another file. It cannot be the key field of the file unless
WORKAREA is specified to make the field available prior to the READ.
You can use a file presence test (IF file-name) to determine the success of the READ. The test is true when the last GET
or READ was successful.
This statement has the following format:
key field name
{ - - } [HOLD ]
file name
READ - KEY { } [ ] [STATUS]
key literal
{' - ' } [NOHOLD]
file-name
Specify the file-name of the INDEXED or RELATIVE file to be randomly accessed.
971
Easytrieve® Report Generator 11.6
KEY {key-field-name|'key-literal'}
You must provide the key to the required record. The contents of key-field-name or 'key-literal' are used in a
search for a corresponding record in the file. Alphanumeric literals must be enclosed within single quotes. The
data format of key-field-name or 'key-literal.' is not changed. The access method can require that the search value
have the same length as the file's key. Key-field-name cannot be nullable.
RELATIVE files require key-field-name to be a 4-byte binary integer field. 'Key-literal' is not allowed for a
RELATIVE file.
[HOLD|NOHOLD]
A hold request is automatically issued for records when UPDATE is specified on the FILE statement. Use
NOHOLD to override this process.
Specify HOLD to hold a record for update. This is the default when UPDATE is specified for the file. HOLD is
invalid if UPDATE is not specified on the FILE statement. HOLD does not mean you are required to perform
the update. It holds the position of the file and can also lock the record (CICS only). Records are automatically
released when the update operation completes or a commit point is taken. You can also manually release the hold
on any record with the RELEASE statement.
NOHOLD specifies that a record is not held for update.
[STATUS]
Specify the STATUS parameter whenever the possibility exists for an unsatisfactory completion of the input/output
request.
STATUS checks input/output processing to see if it was performed properly. STATUS causes the file's FILE-
STATUS field to be set with the appropriate return code. To determine the meaning of the contents of FILE-
STATUS, see System-Defined Fields. Normally, a zero or non-zero test is sufficient.
NOTE
FILE-STATUS is not defined if you do not specify a file type parameter on the FILE statement.
If you do not code STATUS and the operating system returns a non-zero status, an appropriate diagnostic
message is issued.
The key specified is normally a working storage field or a field in another file. It cannot be the file's key field unless
WORKAREA is specified to make the field available prior to the READ.
You can use a file presence test (IF file-name) to determine the success of the READ. The test is true when the
last GET or READ was successful.
Example
FILE PERSNL INDEXED
%PERSNL
FILE INKEYS SEQUENTIAL
WHO 1 5 N
TOTAL-NET W 5 P 2
JOB INPUT INKEYS NAME MYPROG FINISH DISPLAY-TOTAL READ PERSNL KEY WHO STATUS
IF PERSNL:FILE-STATUS NE 0
DISPLAY 'UNSUCCESSFUL READ +
PERFORMED ON FILE PERSNL' +
+2 'KEY= ' WHO
ELSE
TOTAL-NET = TOTAL-NET + PAY-NET
END-IF
DISPLAY-TOTAL. PROC
DISPLAY 'TOTAL NET PAY' TOTAL-NET
END-PROC
972
Easytrieve® Report Generator 11.6
RECORD Statement (IDMS and IMS/DLI)
RECORD statements (Format 1) identify the IDMS database records available for automatic or controlled processing.
RECORD statements in Format 2 identify the IMS/DLI database segments that are to be available for processing.
NOTE
Code RECORD statements (Format 1) following the FILE statement to identify the IDMS database records
available for automatic or controlled processing.
IDMS
All fields defined following the RECORD statement are part of this record. The name of each field must be unique within
the record. However, the field does not have to be unique within the file that contains the record being defined. If a field
defined in another record has the same name as a field defined in this record, then all references to either field must be
qualified with the name of the field's containing record.
NOTE
The RECORD statement cannot be used to define logical records. To define a logical record, use the LOGICAL-
RECORD statement. To define an element record within a logical record, use the ELEMENT-RECORD
statement.
IMS/DLI
RECORD allocates a work space that contains the segment data during execution. Field definition statements, coded
immediately following a RECORD statement, relate to data fields within that segment. One RECORD statement must
be coded for each segment of the database to be processed. They must be coded in the same order as in the PSB that
defines the database. Not all segments of a database need to be defined, but the parent segment of each RECORD must
be coded because incomplete paths are not supported.
This statement has the following format:
Format 1 (IDMS)
record name record length field name
RECORD - - [KEY ( - ...)]
Format 2 (IMS/DLI)
segment name segment length parent segment name
RECORD - - [ - - ] +
key field name key field location key field length
[KEY ( - - , - - , - - )]
Format 1 (IDMS)
record-name
Record-name is the 1- to 16-character name of the record as defined in the subschema.
record-length
Record-length is a positive integer that designates the length of the record as defined in the subschema.
[KEY (field-name ...)]
KEY is an optional parameter that identifies the CALC keys of the record. The KEY parameter is required only for
the root record when using the tickler file. Field-name is the 1- to 30-character name used to designate one of the
record's CALC keys. Field-name must correspond to a CALC key field defined with the DDL for the record. You
must code the field-name parameter for each CALC key defined for the record.
In addition, a DEFINE statement for each field-name must be coded following the RECORD statement. The
DEFINE statement can be intermingled with DEFINE statements for other non-key fields of the record.
Format 2 (IMS/DLI)
973
Easytrieve® Report Generator 11.6
segment-name
Segment-name is the one- to eight-character name of the segment. This name must correspond to the name of a
segment in the DBD.
segment-length
Segment-length is a positive numeric integer that designates the length of the segment.
[parent-segment-name]
Parent-segment-name is an optional parameter that designates the parent of segment-name. This parameter is
not coded for the root segment, but it is required for all other segments.
[KEY]
The optional KEY parameter identifies the sequence field for the segment.
The KEY parameter is not necessary for the RECORD statement that defines the lowest segment in a path. The
KEY parameter is required for the root segment when using the tickler file.
(key-field-name)
Key-field-name is the one- to eight-character name used to designate the keyfield to the IMS/DLI database. The
name must correspond to the sequence field named in the DBD.
(key-field-location)
Key-field-location is a positive numeric integer that specifies the location of the key field within the segment.
(key-field-length)
Key-field-length is a positive numeric integer that specifies the length of the key field.
REFRESH Statement
The REFRESH statement in Easytrieve is used in the AFTER-SCREEN procedure to restore the initial screen image by
rebuilding it with the current values of the program fields.
When used as the result of pressing an IMMEDIATE key, REFRESH redisplays the screen image with the original data
displayed on the screen. This is useful when the terminal user enters erroneous data on the screen and wants to restore
the screen with its original data.
When used as the result of a non-IMMEDIATE key, REFRESH can be used to rebuild the screen using current data from
the screen.
REFRESH can also be invoked directly by pressing a particular attention key. For more information, see KEY Statement.
This statement has the following format:
REFRESH
Example
The following example illustrates the REFRESH statement being invoked when F6 is pressed. Because F6 is not an
IMMEDIATE key, the current values of QTY and PRICE are used to compute the extended price. F5 is used to clear
erroneous data from the screen.
DEFINE EXT-PRICE W 4 P 2
DEFINE QTY W 4 P 0
DEFINE PRICE W 4 P 2
SCREEN NAME TEST-REFRESH
KEY F2 NAME 'Reset to zero'
KEY F3 EXIT NAME 'Exit'
KEY F5 IMMEDIATE REFRESH NAME 'Refresh screen'
KEY F6 NAME 'Compute Ext Price'
974
Easytrieve® Report Generator 11.6
TITLE 'TEST REFRESH'
ROW 3 'Quantity . .' QTY
ROW 5 'Price . . .' PRICE
ROW 7 'Ext Price .' EXT-PRICE
BEFORE SCREEN. PROC
MOVE ZERO TO QTY, PRICE, EXT-PRICE
END-PROC
AFTER-SCREEN. PROC
IF KEY-PRESSED = F6
EXT-PRICE = QTY * PRICE REFRESH
END-IF
END-PROC
RELEASE Statement
The RELEASE statement in Easytrieve explicitly releases the hold on any record in a file.
Easytrieve automatically issues a hold request for GETs and READs when UPDATE is specified on the FILE statement.
Records are automatically released when the update operation completes or a commit point is taken. Alternatively, you
can use the RELEASE statement to manually release the hold on a record. If HOLD is not specified, RELEASE is ignored.
This statement has the following format:
file name
RELEASE -
file-name
File-name is the name of a file.
Example
READ PERSNL KEY '01193' HOLD
...
IF ...
WRITE PERSNL UPDATE
ELSE RELEASE PERSNL
END-IF
REPEAT and END-REPEAT Statements
The REPEAT/END-REPEAT construct in Easytrieve is used to display arrays on a screen.
Each array field on a ROW statement can be subscripted by the subscript specified in the VARYING parameter.
Optionally, array fields on ROW statements can contain a subscript for a second dimension. However, Easytrieve does
not automatically increment this second subscript.
This statement has the following format:
start field name
[ [ { - - } ] ]
number subscript
REPEAT [TIMES] [VARYING [FROM { } ] ] +
start integer
[ [ { - } ] ]
row number
[ROW - ]
975
Easytrieve® Report Generator 11.6
statements
ROW
END-REPEAT
number
Number is the number of times the group of ROW statements in the REPEAT construct is repeated.
[TIMES]
Optionally, code TIMES for statement readability.
[VARYING subscript]
VARYING is an optional parameter that causes Easytrieve to automatically increment a subscript field
(subscript).
The subscript is incremented by one, n times, where n is specified by number.
Subscript can be the name of a previously defined field. However, if it is not defined, Easytrieve automatically
defines the field as a 2 B 0 field. If you defined the field, you must have defined it as numeric (N, P, U, B, I) with
zero or no decimal places.
[FROM {start-field-name|start-integer}]
FROM is an optional parameter that defines the initial value for the REPEAT subscript. Subscript is automatically
incremented by one from either start-field-name or start-integer for each iteration of the group of ROW
statements. If FROM is omitted, the subscript starts at 1.
[ROW row-number]
Specify the row-number on which the repeating group of rows starts. If this is not specified, the repeating group of
rows starts on the last screen row specified plus one.
ROW statements
Code one or more ROW statements to be repeated. ROW statements are coded in a REPEAT/END-REPEAT
construct. For more information, see ROW Statement.
NOTE
ROW statements to be repeated cannot specify explicit row-numbers.
END-REPEAT
END-REPEAT terminates the body of the REPEAT statement. END-REPEAT must be specified after each
REPEAT statement and its associated ROW statements.
Example
The following example illustrates how to display an array on a screen. The REPEAT construct displays both a one-
dimensional array (WS-NAME), and a two-dimensional array (WS-STAT). Starting at row 4, Easytrieve displays the first
occurrence of the fields. The second dimension of WS-STAT is stated explicitly. Easytrieve increments USER-SUB and
displays the next occurrence until 15 occurrences are displayed.
This code:
...
WS-EMPLOYEE W 33 A OCCURS 30 . * 2-DIMENSIONAL TABLE OF
WS-NAME WS-EMPLOYEE 30 A . * 30 EMPLOYEES CONTAINING:
WS-STATUSES WS-EMPLOYEE +30 3 A . * EMPLOYEE NAME AND
WS-STAT WS-STATUSES 1 A OCCURS 3. * 3 STATUSES
...
SCREEN NAME EMPLOYEE-LIST
TITLE 'List of Employees'
976
Easytrieve® Report Generator 11.6
ROW 3 'Name' COL 30 'Statuses' REPEAT 15 TIMES VARYING
USER-SUB
ROW WS-NAME (USER-SUB) +
WS-STAT (USER-SUB, 1) WS-STAT (USER-SUB, 2) WS-STAT (USER-SUB, 3) END-REPEAT
Produces:
List of Employees
Name Statuses
WIMN, GLORIA F G O
BERG, NANCY C
CORNING, GEORGE I T
...
REPORT Statement
The REPORT statement in Easytrieve defines the type and characteristics of a report.
Although you can specify a large number of REPORT statement parameters, you will probably produce most reports using
default parameter values specified in the Site Options Table.
REPORT statement parameters fall into five basic groups:
• Format determination parameters
• Label parameters
• File directing parameters
• Spacing control parameters
• Testing aid parameters
The data window for fields with VARYING specified on the DEFINE statement is based on the maximum length of the
field. The window is padded to the right with blanks for VARYING fields less than the maximum.
You need not code the SUMMARY parameter to use SUMFILE.
For a complete explanation of reporting facilities, see Programming.
This statement has the following format:
report name
REPORT [ - ]+
[XML]+ }
[SUMMARY]+ }
summary- file- name
[SUMFILE ]+ }
sumfield addition
[SUMSPACE - ]+ }
tally- print- size
[TALLYSIZE ]+ }
}
[ {EVERY}] }
[DTLCTL{FIRST}]+ } Format
[ {NONE}] } Determination
} Parameters
[ { [ALL] }] }
[SUMCTL {([HIAR] [DTLCOPY])}]+ }
[ { [NONE] [DTLCOPYALL] }] }
977
Easytrieve® Report Generator 11.6
[ { [TAG ] }] }
}
number- of- labels
[ [ACROSS ] ] }
number- of- lines
[LABELS ([DOWN ])]+ } Label
label length
[ [SIZE - ] ] } Parameters
[ [NEWPAGE ] ] }
}
work- file- name
[FILE ]+ } File Directing
receive- file- name
[PRINTER ]+ } Parameters
line- page- size display- page- size
[PAGESIZE ( [ ])]+ }
line length
[LINESIZE - ]+ }
number- of- lines
[SKIP ]+ }
number- of- spaces
[SPACE ]+ }
number- of- lines
[TITLESKIP ]+ }
number- of- lines
[CONTROLSKIP ]+ }
}
[SPREAD ]+ }
[NOSPREAD] } Spacing Control
} Parameters
[NOADJUST]+ }
}
[NODATE ] }
[LONGDATE ]+ }
[SHORTDATE] }
}
[NOPAGE]+ }
[NOHEADING]+ }
}
number- of- records
[LIMIT ]+ } Testing Aid
n- number- of lines
[EVERY - ] } Parameters
Format Determination [report-name]
Report-name identifies the report. It is optional when there is only one report in a JOB activity. If you code multiple
reports, the first report can be unnamed but all others must be named. Each report-name must be unique in the
JOB activity. At least one report-name must be coded on a PRINT report-name statement. For unnamed reports,
code the PRINT statement without a report-name parameter.
Report-name:
• – Can be up to 128 characters in length
– Can contain any character other than a delimiter
– Can begin with A to Z, 0 to 9, or a national character (#, @, $)
– Must not consist of all numeric characters
• [XML]
Optionally use XML to produce a file formatted using Extensible Markup Language (XML). This hierarchically-
structured file is built according to the field relationships defined by REPORT, CONTROL, and LINE statements.
978
Easytrieve® Report Generator 11.6
Any spacing or positioning parameters (such as NOADJUST, COL, and SKIP) are ignored because the XML file
contains only field name (or HEADING) values and data values. XML also changes the default setting of the DTLCTL
parameter to EVERY. This causes every line-statement field to be written to the XML output file for each execution of a
PRINT statement. This behavior can be overridden using the DTLCTL parameter described later in this section.
For an XML-formatted report, no printed output is generated. There are no control totals or summary data lines printed
or written to any file. For information about the XML report feature, see Programming.
• [SUMMARY]On control reports, SUMMARY inhibits printing of detail data. Only control totals are printed.
• [SUMFILE summary-file-name]Optionally, use SUMFILE to generate a summary file that contains the control and
summary field values. Summary-file-name identifies the file to contain the summary data.
• [SUMSPACE sumfield-addition]Use SUMSPACE to define the print size for total fields on a control report. Sumfield-
addition is added to the length (in digits) of the field to define its print size. This expansion is necessary to prevent the
loss of significant data due to overflow conditions. The resulting print length is limited to a maximum of 18 digits. Valid
values for sumfield-addition are 0 to 9. No additional numeric edit characters are included in the resulting edit mask.
For example, totals such as 55555,555.55 can appear.
• [TALLYSIZE tally- print-size ]Use TALLYSIZE to set the print size for the field TALLY. Valid values for tally-print-
size are 1 to 18. The number of digits used for TALLY on a summary line is the sum of the values of TALLYSIZE and
SUMSPACE.
• [DTLCTL {EVERY|FIRST|NONE}]DTLCTL optionally defines detail line printing characteristics.
Specify EVERY to print the value of all control fields on every detail line.
Specify FIRST to print the value of all control fields on the first detail line of a page and on the first detail line after each
control break. Control field values are not printed on all other detail lines. Specify NONE to inhibit the printing of control
field values on detail lines.
• [SUMCTL {[ALL|HIAR|NONE|TAG] [DTLCOPY|DTLCOPYALL]}]
SUMCTL optionally defines total line printing characteristics. Specify ALL to print control field values on every total line.
Specify HIAR to print control field values in a hierarchical fashion on total lines. Only values for control fields on the
same hierarchical level, or higher than the breaking control field, are printed on the associated total line.
Specify NONE to inhibit printing of control field values on total lines.
Specify TAG to print control-field-name TOTAL as an annotation to the left of the associated total line where control-
field-name is the field-name for the breaking control field. There must be sufficient unused space on the left side of the
total line for this annotation.
Specify DTLCOPY to print detail information on total lines. Normally, only control field values and associated totals are
printed on total lines. Coding DTLCOPY prints the detail field contents, prior to the break, on the total line. These fields
are printed only when LEVEL is one (1).
Specify DTLCOPYALL to print detail fields for all control breaks.
• Label [LABELS [ACROSS number-of-labels ][DOWN number-of-lines ][SIZE label-length][NEWPAGE]]
Specify LABELS to indicate that the report is a label report.
NOTE
The NOHEADING and NOADJUST options are automatically activated when you specify LABELS; therefore,
you cannot specify TITLE and HEADING statements. You cannot use LABELS with SUMMARY.
Specify ACROSS number-of-labels to define the number of labels printed across the print line.
Specify DOWN to define the number of lines in a label. The value of number-of-lines is the number of lines reserved for
each label. The value range for number-of-lines is 1 to nnn, where nnn is at least as large as the largest corresponding
LINE nnn value.
Specify SIZE to set the length of each label. The value of label-length is the number of print positions on a label. Label-
length has a value range from 1 to nnn, where nnn is the length of the label.
NOTE
LABELS cannot be specified for extended reporting printers.
NEWPAGE controls the printing of the first line (LINE 01) of each label. When coded, NEWPAGE associates a printer
top-of-form request with the first line of each label.
The following algorithm confines the overall size of labels:
979
Easytrieve® Report Generator 11.6
number of print positions on an individual label
LINESIZE >= (ACROSS - 1) * SIZE + ( )
• File Directing [FILE work-file-name]
Optionally, specify FILE to identify the work file used for very large reports. Code this parameter when the default VFM
work file is too small to contain the report data. Work-file-name identifies the FILE that receives the work file data
NOTE
You should not use the FILE parameter in CICS. An execution error occurs when work-file-name is not a
virtual file.
NOTE
Instead of coding the FILE parameter for each report in your program, you can use the WORKFILE YES
parameter on the PARM statement. For more information, see PARM Statement.
• [PRINTER receive-file-name]
Optionally, specify PRINTER to direct the report's printed output. Receive-file-name identifies the FILE that receives
the report. This file must have the PRINTER or EXTENDED attribute specified. The default is the Easytrieve standard
print output file: SYSPRINT. The actual destination of SYSPRINT is determined by a site option. For more information
about the actual destination of SYSPRINT, see your system administrator. For more information about PRINTER files,
see Programming.
If the system print output file or receive-file-name has been associated with an extended reporting printer, then
Easytrieve automatically formats the report to satisfy the requirements defined for that extended reporting printer.
Easytrieve restricts the support of extended reporting facilities to those reports that are output to printer files that have
been associated with an extended reporting printer.
Spacing Control-each of the following parameters modifies the default spacing of a report page. You normally do not
use these parameters; however, they are available to support unique report spacing requirements.
• [PAGESIZE (line-page-size [display-page-size])]Specify PAGESIZE to define the logical print length of a printed
page. Line-page-size must be an unsigned integer from 1 to 32767, and must be at least as large as the sum of:
• – Title-number of the last TITLE statement
– Number-of-lines of TITLESKIP
– Number of HEADING lines plus one
– Line-number of the last LINE statement
– Number-of-lines of SKIP
In other words, at least one line group must fit on a report page.
Specify an asterisk (*) for line-page-size if you want to change display-page-size without changing the default line-
page-size.
Display-page-size must be zero or greater than or equal to the line-page-size.
When Easytrieve processes a LINE statement, it compares the line count to line-page-size. If the line count is less
than line-page-size, the LINE statement performs the BEFORE-LINE procedure and then prints the line. If the line
count is greater than or equal to line-page-size, the LINE statement performs the ENDPAGE procedure, processes
TITLEs, performs the BEFORE-LINE procedure, and finally prints the line. The line count is not compared again to
line-page-size after the LINE statement performs the BEFORE-LINE procedure.
Specify a value greater than zero for display-page-size to allow the DISPLAY statement to generate page breaks.
When display-page-size is greater than zero, the line count is compared to display-page-size. If the line count is
greater than display-page-size, then the DISPLAY statement performs the ENDPAGE procedure and generates a
page break with TITLEs.
Specify zero for display-page-size to inhibit DISPLAY statement generated page breaks. When display-page-size is
zero, the DISPLAY statement does not compare line count to display-page-size, and a page break is not generated.
The DISPLAY statement always increases line count, regardless of the display-page-size value.
When the report is directed to an extended reporting printer that does not support a Forms Control Block (FCB),
then Easytrieve multiplies line-page-size by the default height of the assigned extended reporting printer. This
enables Easytrieve to compare PAGESIZE with the heights of fonts used on the report, because they are both
980
Easytrieve® Report Generator 11.6
in the same base unit (the H-unit). The value of line-page-size multiplied by the default height of the assigned
extended reporting printer cannot exceed the maximum page length of that extended reporting printer.
• [LINESIZE line-length]
Code the LINESIZE parameter to specify the maximum number of data characters that can be printed on a line. Line-
length must be an unsigned integer from 1 to 32767.
Line-length must be at least one less than the length of the data portion of the file's logical record. If the FILE definition
does not provide the file's format and logical record length, then no compile time verification of the line-length is done.
The default value of LINESIZE is calculated as one less than the data portion of the logical record if the file format and
record length are known at compile time. Otherwise, the default is taken from the LINESIZE site option.
There are additional control characters (forms control information) that also must be stored in a logical record. If one of
the record format parameters is specified, it must be large enough to hold both the forms control information and the
data characters. The value of line-length must be less than or equal to the maximum record length minus the size of
the forms control information.
The first character in a PRINTER file contains the ASA carriage control information.
When the report is assigned to an extended reporting printer that is not a standard line printer, the maximum value of
line-length is not dependent upon the record size of the print data set. The insertion of overprint and function codes
into print records and the support of different fonts on the same print line all impact the relationship between LINESIZE
and print data set record size. Easytrieve supports any LINESIZE, provided line-length multiplied by the value of
the assigned extended reporting printers default width does not exceed the maximum page width of that extended
reporting printer.
Line-length overrides the value defined in the Site Options Table. If the report is directed to an extended reporting
printer, Easytrieve multiplies line-length by the default width of the assigned extended reporting printer. This value
defines the width of the print line in terms of the extended reporting printer's W-unit.
• [SKIP number-of-lines]Specify SKIP to define the number of blank lines to be inserted between line groups (between
the last LINE nnn and the next LINE 01). Number-of-lines has a valid range of 0 to nnn, where nnn allows for the
printing of at least one line group on each page. When you specify a value of 0, a line group containing multiple
lines can be spanned across a page break. A non-zero value inhibits this spanning. When the report is directed to
an extended reporting printer that does not support a Forms Control Block (FCB), the default height of the assigned
extended reporting printer defines the height of each line.
• [SPACE number-of-spaces]Specify SPACE to adjust the default number of blanks (space characters) inserted
between fields on TITLE and LINE statement items. The value of number-of-spaces has a valid range of 0 to nnn
(default is 3), where nnn does not cause line overflow. When the report is directed to an extended reporting printer,
Easytrieve multiplies number-of-spaces by the default width of the assigned extended reporting printer. This operation
expresses number-of-lines in terms of the printer's W-unit.
NOTE
The SPREAD parameter overrides this parameter.
• [TITLESKIP number- of-lines ]
Specify TITLESKIP to insert blank lines between the last title line and the first heading line (or LINE 01) of a report.
The value of number-of-lines has a valid range of 0 to nnn, where nnn allows for the printing of at least one line group
on each page.
When the report is directed to an extended reporting printer that does not support a Forms Control Block (FCB), the
height of each line is defined by the default height of the assigned extended reporting printer. This operation converts
number-of-lines into the H-units applicable to the printer.
• [CONTROLSKIP number- of-lines ]Specify CONTROLSKIP to define the number of blank lines to be inserted
following CONTROL total lines and the next detail line. Number-of-lines must be between 0 and 32767. If
CONTROLSKIP is not specified, one blank line plus the SKIP value is inserted after the CONTROL total line.
• [SPREAD|NOSPREAD]Specify SPREAD to insert the maximum number of spaces between each column of a report.
NOSPREAD deactivates SPREAD when it is the default specified in the Site Options Table. SPREAD and NOADJUST
are mutually exclusive. For more information about this parameter, and examples, see Programming.
981
Easytrieve® Report Generator 11.6
NOTE
SPREAD overrides the SPACE parameter.
• [NOADJUST] Specify NOADJUST to left-justify the title lines and report on the page. The default is centered on the
page. SPREAD and NOADJUST are mutually exclusive.
• [NODATE|LONGDATE|SHORTDATE]Specify NODATE to inhibit the printing of the date value on the first title line
(TITLE 01).
LONGDATE specifies that SYSDATE-LONG is to appear on the first title line.
SHORTDATE specifies that SYSDATE is to appear on the first title line.
• [NOPAGE]Specify NOPAGE to inhibit the printing of the value of PAGEWRD (in the Site Options Table) and the
current page number in the report title.
• [NOHEADING]Specify NOHEADING to inhibit the printing of column headings. The default is that each field's
HEADING value is printed as a column heading.
Testing Aid LIMIT and EVERY are used as testing aids for report development. These parameters control the amount
of data output on a report.
• [LIMIT number-of-records]Specify LIMIT to limit the number of records processed by the report. The value of
number-of-records has a valid range of 1 to 32,767.
• [EVERY n-number-of-lines]Specify EVERY to indicate that only every n line is printed in the report. The value of n-
number-of-lines has a valid range of 1 to 32,767.
REPORT-INPUT Report Procedure
A REPORT-INPUT procedure in Easytrieve selects or modifies report input data.
This procedure is performed for each PRINT statement (report input). To cause the data to continue into report
processing, you must execute a SELECT statement for the associated input data. In other words, input that does not get
selected is bypassed for continued processing.
Although you can code the logic to select records in the JOB activity itself, you can occasionally place the logic in a
REPORT-INPUT procedure.
When the report data has been spooled (because the report had been sequenced or the printer file was in use), the
REPORT-INPUT procedure is invoked as each spooled record is read to produce this report. This means that all records
printed are spooled and sorted (if SEQUENCE is specified). The REPORT-INPUT procedure is then invoked. For
performance reasons, you should select the records in a JOB activity, if possible.
A REPORT-INPUT procedure must be delimited by an END-PROC statement. See PROC Statement for more
information.
This statement has the following format:
REPORT-INPUT. PROC
Example
The following example illustrates use of the REPORT-INPUT procedure in final report input selection. Only the first record
in each ZIP code is selected.
Statements:
FILE FILE1
LAST-NAME 1 5 A
STATE 6 2 A
ZIP 8 5 N
PAY-NET 13 5 N 2
982
Easytrieve® Report Generator 11.6
HOLD-ZIP S 5 N VALUE 00000
JOB INPUT FILE1 NAME MYPROG
PRINT REPORT1
*
REPORT REPORT1 LINESIZE 65 +
SUMMARY SUMCTL DTLCOPY
SEQUENCE STATE ZIP
CONTROL STATE NEWPAGE ZIP
TITLE 'REPORT FOR THE STATE OF' STATE
LINE 01 LAST-NAME STATE ZIP PAY-NET
*
REPORT-INPUT. PROC
IF ZIP NE HOLD-ZIP
HOLD-ZIP = ZIP
SELECT
END-IF
END-PROC
*
Data:
BROWNIL6007612345
BROWNIL6007667890
JONESIL6007709876
JONESIL6007754321
SMITHTX7521811111
SMITHTX7521866666
Results:
11/23/09 REPORT FOR THE STATE OF IL PAGE 1
LAST-NAME STATE ZIP PAY-NET
BROWN IL 60076 123.45
JONES IL 60077 98.76
IL 222.21
11/23/09 REPORT FOR THE STATE OF TX PAGE 2
LAST-NAME STATE ZIP PAY-NET
SMITH TX 75218 111.11
TX 111.11
333.43
RESHOW Statement
The RESHOW statement in Easytrieve is used in an AFTER-SCREEN procedure to redisplay the screen image with
user-entered data intact.
In contrast to the REFRESH statement, the screen image is not rebuilt using the current values of program fields.
983
Easytrieve® Report Generator 11.6
Upon receiving the screen, Easytrieve saves a copy of the screen image. The RESHOW statement restores the saved
image.
This statement has the following format:
RESHOW
Example
As shown in the following example, RESHOW can be used to redisplay a screen following a request for help. The data
that the user entered on the screen before they requested help is redisplayed intact. When RESHOW is used with an
IMMEDIATE KEY, original screen data is retained, but not edited or saved into program fields.
...
SCREEN NAME MENU UPPERCASE
KEY ENTER
KEY F1 NAME 'Help' IMMEDIATE
KEY F3 NAME 'Exit' EXIT
TITLE...
ROW...
AFTER-SCREEN. PROC
IF KEY-PRESSED = F1
EXECUTE MENU-HELP RESHOW
END-IF
CASE OPTION
...
END-PROC
SCREEN NAME MENU-HELP
KEY F3 NAME 'Exit' EXIT
TITLE...
ROW...
RETRIEVE Statement (IDMS and IMS/DLI)
The RETRIEVE statement in Easytrieve identifies the database records that are automatically input to the JOB activity.
Code the RETRIEVE statement immediately following a JOB statement to specify automatic input. You can code only one
RETRIEVE statement in each JOB activity. Easytrieve processes the automatic input the same way as non-database
input.
For RETRIEVE statement examples, see the Programming Guide.
This statement has the following format:
Format 1 (IDMS)
file name
RETRIEVE - +
program name
[ { - }]
[PROGRAM-NAME { }] +
program literal
[ {' - '}]
db name table name
[ { - - - }]
984
Easytrieve® Report Generator 11.6
[DBNAME { }] +
db name table literal
[ {' - - - '}]
node name
[ { - }]
[NODE { }] +
node literal
[ {' - '}]
dictionary name
[ { - }]
[DICTNAME { }] +
dictionary literal
[ {' - '}]
dictionary node name
[ { - - }]
[DICTNODE { }] +
dictionary node literal
[ {' - - '}]
tickler file name
[KEYFILE - - + ] ]
calc key field name calc value field name
[KEYVALUE ( - - - EQ - - - ...) ] + ]
[ ] +
[DUPS ]
[NODUPS ]
record name
SELECT ( - +
area literal
[AREA ' - ' + ]
set literal
[SET ' - ' + ] +
index set literal index key literal
[INDEX ' - - ' [USING (' - - ' ...)]]
path literal
[ID ' - '] +
number of records
[LIMIT - - ] +
condition
[WHILE ( )] +
...)
Format 2 (IMS/DLI)
file name
RETRIEVE - +
tickler file name key field name
[KEYFILE - - KEYVALUE - - ] +
record name
SELECT ( - +
path literal
[ID ' - '] +
number of records
[LIMIT - - ] +
segment literal
[SSA ' - '] +
condition
[WHILE ( )] +
...)
985
Easytrieve® Report Generator 11.6
Format 1 (IDMS)
file-name
File-name is the same as the name coded in the FILE file-name IDMS and JOB INPUT (file-name) statements.
[PROGRAM-NAME {program-name|'program-literal'}]
Program-name or 'program-literal' specifies the name used to identify the program to IDMS during execution.
Program-name must be an eight-byte alphanumeric field. 'Program-literal' must be alphanumeric and is padded to
the right (if necessary) to create an eight-byte value.
[DBNAME {db-name-table-name|'db-name-table-literal'}]
Db-name-table-name or 'db-name-table-literal' specifies a DB name table. Data retrieved during execution of the
user's program is from the named IDMS database. Db-name-table-name must be an eight-byte alphanumeric
field. 'Db-name-table-literal' must be alphanumeric and is padded to the right (if necessary) to create an eight-byte
value.
[NODE {node-name|'node-literal'}]
Node-name or 'node-literal' specifies the central version node that hosts the IDMS activity generated by the
user's program. Node-name must be an eight-byte alphanumeric field. 'Node-literal' must be alphanumeric and is
padded to the right (if necessary) to create an eight-byte value.
[DICTNAME {dictionary-name|'dictionary-literal'}]
Dictionary-name or 'dictionary-literal' specifies the dictionary name of a secondary load area. Dictionary-name
must be an eight-byte alphanumeric field. 'Dictionary-literal' must be alphanumeric and is padded to the right (if
necessary) to create an eight-byte value.
[DICTNODE {dictionary-node-name|'dictionary-node-literal'}]
Dictionary-node-name or 'dictionary-node-literal' specifies the dictionary node of a secondary load area.
Dictionary-node-name must be an eight-byte alphanumeric field. 'Dictionary-node-literal' must be alphanumeric
and is padded to the right (if necessary) to create an eight-byte value.
[KEYFILE tickler-file-name][KEYVALUE (calc-key-field-name EQ calc-value-field-name ...)][DUPS|
NODUPS]
The optional tickler file is designated by coding the KEYFILE and KEYVALUE parameters. Tickler-file-name is the
name of a file that is sequentially processed to obtain the keys of the root records to be retrieved. The DBCS code
system of tickler-file-name must equal the DBCS code system of file-name.
Calc-value-field-name is a data field from tickler-file-name that contains a value for one of the CALC keys of the
root record. Calc-key-field-name is a CALC key field defined in the RECORD statement for the root record that is
to receive the value of calc-value-field-name. For information about coding how calc-value-field-name is assigned
to calc-key-field-name, see the Programming Guide.
You must code one calc-value-field-name for each key field defined in the KEY parameter of the RECORD
statement for the root record.
The key values are used in the CALC retrieval of root records. Therefore, only CALC records can be root records
when the tickler file is used. The optional keywords, DUPS and NODUPS, are used to specify whether CALC
records with duplicate keys are also retrieved. The OPTIONS table parameter CALCDUP has the default value.
The JOB activity is terminated at end-of-file for tickler-file-name.
The KEY parameter for the root record retrieved by the tickler file option must be specified on the RECORD
statement.
[SELECT (record-name ...)]
The SELECT parameter identifies which paths are retrieved. Record-name must be the same as coded on a
RECORD statement. Any number of records and paths can be coded under control of the following rules of
network structure:
• The first record-name coded is the root. It is retrieved by an area sweep, tickler file, or integrated index.
• A repeated record-name denotes a node in the network. A node is a record-type that is common in multiple
paths. The optional subparameters are not allowed when a record-name is repeated as a node.
• Paths are retrieved in the order in which they are identified.
986
Easytrieve® Report Generator 11.6
[AREA 'area-literal']
The optional AREA subparameter is coded to supply the sweep area. This subparameter can be specified only
if record-name is a root record. AREA is not allowed if INDEX has already been specified for this record. The 1-
to 16-character IDMS area name ('area-literal') controls retrieval within area of root records. 'Area-literal' must be
alphanumeric (non-DBCS), and is padded to the right (if necessary) to create a 16-byte value.
If the AREA subparameter is coded, Easytrieve uses OBTAIN NEXT record-name WITHIN AREA calls to
retrieve occurrences of this record. If this subparameter is omitted, Easytrieve uses OBTAIN NEXT record-name
calls instead.
[SET 'set-literal']
The SET subparameter specifies the name of the set used for retrieving the named record (record-name). This
subparameter is not allowed if record-name is the root record or if record-name is a node. SET is required for all
other records. 'Set-literal' must be alphanumeric (non-DBCS), and is padded to the right (if necessary) to create a
16-byte value.
If this record is a member of the specified set, Easytrieve uses OBTAIN NEXT record-name WITHIN SET calls
to retrieve occurrence of this record. If this record is the owner of the specified set, Easytrieve uses OBTAIN
OWNER calls instead.
[INDEX 'index-set-literal'[USING ('index-key-literal' ...)]]
Code the optional INDEX subparameter to designate the index set ('index-set-literal') that controls root retrieval
by integrated indexing. This subparameter can be specified only if record-name is a root record. INDEX is not
allowed if AREA has already been specified for this record. 'Index-key-literal' must be a alphanumeric (non-
DBCS), and is padded to the right (if necessary) to create a 16-byte value.
Note: The INDEX subparameter cannot be used with the tickler file.
The optional USING subparameter ('index-key-literal') designates the alphanumeric literals used to constrain the
index. You can code as many occurrences of 'index-key-literal' as are required to fully specify the index key value.
The values are concatenated in the order specified and form the index key value that is passed to IDMS. The
cumulative length of all literals specified must match the length of the index known to integrated indexing. The
code system of the data must also match.
When the INDEX subparameter is coded, Easytrieve uses OBTAIN NEXT WITHIN SET calls to retrieve all
occurrences of the root record except for the first occurrence. The retrieval of the first occurrence is determined
by the optional USING subparameter. If the USING subparameter is coded, Easytrieve retrieves the first root
record occurrence using an OBTAIN WITHIN SET USING SORT KEY call. If the USING subparameter is omitted,
an OBTAIN FIRST WITHIN SET call is used. Easytrieve uses the USING subparameter to establish the initial
position within the index set. Once this initial position has been established, retrieval of the root record proceeds
until the end of the index set is reached.
[ID 'path-literal']
Code the optional ID subparameter to establish the identity of retrieved paths. The system-defined field file-
name:PATH-ID is set to the value of 'path-literal' for the lowest record retrieved in the current path. 'Path-literal'
can be an alphanumeric value of one or two characters. It cannot contain any DBCS data. The default is spaces.
Whenever a key of the tickler file does not correspond to a root record in the database, file-name:PATH-ID is set
to NF (Not Found).
[LIMIT 'number-of-records']
The optional LIMIT subparameter controls the number of record occurrences to be retrieved. The limit applies
to the specific record in the path. 'Number-of-records' must be a positive integer. When this subparameter is not
coded, all occurrences of the record are retrieved.
[WHILE (condition)]
Code the optional WHILE subparameter to pre-screen input records. The syntax of the condition is exactly
the same as the conditional expressions described in the Programming Guide. When the associated record is
retrieved from IDMS, the condition is evaluated. Records are accepted for input only if the condition is true.
Format 2 (IMS/DLI)
987
Easytrieve® Report Generator 11.6
file-name
File-name identifies the database being accessed. File-name is the same as the name coded in JOB INPUT file-
name and FILE file-name statements.
[KEYFILE tickler-file-name KEYVALUE key-field-name]
You can designate the tickler file option by coding both the KEYFILE and the KEYVALUE parameters. Tickler-file-
name is the name of the file that is sequentially processed to get the keys of the root segments to be retrieved.
Key-field-name is a data field from tickler-file-name that contains the keys. The key values are used in the
segment search argument for the root segment. Easytrieve issues GU (get unique) calls at the root level for each
key found in tickler-file-name. Automatic input is terminated at end-of-file for tickler-file-name.
The DBCS code system assigned to tickler-file-name must match the DBCS code system of file-name.
[SELECT (record-name ...)]
The SELECT parameter identifies which segments (record-name) Easytrieve is to retrieve. Record-name must
be the same as the segment-name coded on a RECORD statement. You can identify any number of record-
names for input; however, the parent of all selected segments must also be selected.
[ID 'path-literal']
Code the optional ID subparameter to establish the identity of retrieved paths. The system-defined field PATH-
ID is set to the value of 'path-literal' for the lowest segment retrieved in the current path. PATH-ID is a two-byte
alphabetic field. 'Path-literal' can be an alphabetic value of one or two bytes. It cannot contain any DBCS data.
The default value for PATH-ID is spaces. When a key of the tickler file does not correspond to a root record in the
database, PATH-ID is set to NF (Not Found).
[LIMIT 'number-of-records']
The optional LIMIT subparameter controls the number of segment occurrences to be retrieved. The limit applies to
each path. 'Number-of-records' must be a positive integer. When this subparameter is not coded, all occurrences
of the segment are retrieved.
[SSA 'segment-literal']
You can code the optional Segment Search Argument (SSA) parameter for the root segment. 'Segment-literal'
is used in the creation of the SSA to qualify segment retrieval. This parameter is not valid when you use a tickler
file. The value supplied with SSA is enclosed within parentheses and concatenated with the segment-name to
produce the root segment's SSA. 'Segment-literal' cannot contain any DBCS data.
[WHILE (condition)]
Code the optional WHILE subparameter to pre-screen input segments. The syntax of the condition is exactly
the same as the conditional expressions described in the Programming Guide. When the associated record is
returned by IMS/DLI, the condition is evaluated. Segments are accepted for input only if the condition is true.
ROLLBACK Statement
The ROLLBACK statement in Easytrieve causes all uncommitted updates in the current logical unit of work to be rolled
back.
For more information about types of work that are recoverable, see the Programming Guide. Use the COMMIT statement
to commit any pending changes.
This statement has the following format:
ROLLBACK
Example
WRITE PERSNL ADD
...
988
Easytrieve® Report Generator 11.6
IF ...
ROLLBACK
ELSE
COMMIT
END-IF
ROW Statement
The ROW statement in Easytrieve specifies items (fields or literals) to be displayed or received on a row of a screen.
Multiple items can be coded on each ROW statement. Attributes can be specified for each literal coded on the ROW
statement. Attributes and editing criteria can be specified for each field-name coded on the ROW statement.
For more information, see the Programming Guide.
This statement has the following format:
row number
ROW [ - ] +
offset value field name
[+ - ] { - }
[ ] { } +
column number row literal
[COL - ] {' - '}
attribute name
[ { - } ]
[ATTR { } ] +
attribute list
[ {( - )} ]
[ {RIGHT} ]
[JUSTIFY { } ] +
[ {LEFT } ]
fill character
[FILL {' - '|NULL}] +
mask identifier mask literal
[MASK ({[ - ] [BWZ] [' - ']|HEX})] +
[NOMASK ]
pattern name
[ { - } ]
[PATTERN { } ] +
pattern
[ {' ' } ]
[UPPERCASE] +
literal literal
[VALUE ( [THRU ] [...])] +
attribute name
[ [ { - }] ] ]
[ERROR ( [ATTR { }] + ] ]
attribute list
[ [ {( - )}] ] ]
[ ] ] ...
literal
[ [ {' ' [ ] } ] ] ]
[ [ { [...] } ] ) ] ]
field name
[ [ { - [ ] } ] ] ]
989
Easytrieve® Report Generator 11.6
[row-number]
Row-number specifies the line on which the item on the screen is displayed. A ROW without a row-number is
assigned the next row number on the screen. Next is defined as the previous row-number plus one, not the
highest number used as yet.
A ROW without any fields or literals displays a blank line on the screen at the corresponding row-number.
Row-number cannot exceed the default ROWCOUNT value set in the site options or the value of the
ROWCOUNT parameter specified on the SCREEN statement, if coded.
[+offset-value|COL column-number] {field-name|'row-literal'}
The +offset-value or the COL column-number parameter allows you to control positioning of an item on the row.
+Offset-value is the number of columns (spaces) preceding a screen item. The default +offset-value is +1
because the space preceding each screen item is reserved for screen attributes. +Offset-value must be a signed
positive integer and can only be used for items other than the first in the row.
Use column-number to explicitly specify the column at which the screen item is displayed.
If you do not code a +offset-value or column-number, the next field-name or 'row-literal' is displayed one column
after the end of the previous field-name or 'row-literal.' If no previous item exists in the row, the item is displayed in
column one.
Field-name can be any defined field in your program.
'Row-literal' can be any text you want to display on the screen.
The sum of the length of all screen items (fields and literals) plus offset-values and column-numbers (if used)
cannot exceed the value of the default LINESIZE set in the site options, or the value of the LINESIZE parameter
on the SCREEN statement, if coded.
[ATTR {attribute-name|attribute-list)}]
ATTR specifies either a declared screen attribute name or one or more attribute keywords. For a list of attributes,
see ATTR Parameter. For more information about declared screen attributes, see DECLARE Statement.
The following attributes are invalid for literals and system-defined read-only fields:
• CURSOR
• NUMERIC
• INVISIBLE
• MUSTFILL
• MUSTENTER
• TRIGGER
• ALARM
They are ignored if used, but Easytrieve issues a warning message during compilation.
SENDONLY and ASKIP are assumed for literals and system-defined read-only fields.
[JUSTIFY {RIGHT|LEFT}]
Use the JUSTIFY parameter to specify whether the data in the field is left or right justified when displayed at the
terminal.
[FILL {'fill-character'|NULL}]
Specify FILL to translate trailing blanks into either 'fill-character' or NULL. 'Fill-character' must be a one-byte
alphanumeric literal.
Upon receiving data from the screen, Easytrieve translates all remaining fill characters to spaces.
You can use the FILL parameter to fill a field with underscores to illustrate the total length of the field. You can fill a
field with NULL on a 3270 display to allow insertion of characters.
Varying length fields with FILL NULL do not have trailing nulls translated to spaces. The first trailing null
terminates the varying length field, and then sets its length.
[MASK ({[mask-identifier] [BWZ] ['mask-literal']|HEX})]|[NOMASK]
The optional MASK parameter is used to format the field for display.
If MASK is not coded, the MASK coded on the field's definition is used. Use NOMASK to specify that the field's
default MASK is to be used instead of the field's definition MASK.
990
Easytrieve® Report Generator 11.6
Any letter from A to Y can be used as an optional mask-identifier. You can use the letter to identify a new mask
or to retrieve a mask that was previously defined either in the Site Options Table or by a mask parameter on a
previous field definition or ROW usage. If the new mask that you identify does not already exist, Easytrieve
retains the mask for future reference. Do not use the same identifier to establish more than one mask.
The BWZ (blank when zero) option suppresses the display of field-name when it contains all zeros. BWZ can be
used by itself or with other options on the MASK parameter.
'Mask-literal' defines an edit mask and must be enclosed within single quotes.
Specify HEX to display the field in double-digit hexadecimal format. You can display fields of up to 50 bytes with
the HEX mask.
When fields are received from the terminal, the mask is used as an editing template also. Special characters in
the MASK are stripped from the data before it is moved into the field data area. For more information, see the
Programming Guide.
NOTE
HEX edit masks are not allowed for VARYING fields.
[PATTERN {pattern-name|'pattern'}]
PATTERN allows you to specify a pattern against which each input character is edited. The pattern can be
specified as a literal or as the name of a declared pattern. See DECLARE Statement for more information.
The valid pattern characters and their meanings are as follows:
A
Represents a lower-case or an upper-case letter.
B
Represents a single blank.
D
Represents a digit.
E
Represents an empty string.
L
Represents a lower-case letter.
N
Represents an upper-case letter or a national character.
U
Represents an upper-case letter.
X
Represents any character.
"x"
Double quotes surrounding a character or a sequence of characters literally represent the character or
sequence of characters contained within. The x represents any character. To literally represent single or
double quotes, use two sets of quotes within the surrounding set of double quotes ('""""' or '"x""x"', '"''"', or
'"x''x"').
blank
Blanks (unless contained in double quotes) serve as delimiters but are otherwise ignored. They can be
inserted into the pattern to increase readability.
( )
Represents grouping to control the precedence of operators.
or | or ,
Represents a choice (or alternation operator).
991
Easytrieve® Report Generator 11.6
(m) or (m..n) or (m..*) or (*) or *
Represents the repetition of the preceding pattern expression. The m and n represent numbers and m
must be less than n. A single number with parentheses indicates the exact number of repetitions. (m..n)
represents a range of repetitions, minimum to maximum. An asterisk in a range, (m..*), represents an
infinite maximum. An asterisk by itself, (*) or *, represents a range from 0 to infinity.
# or /-/
Represents the remove (or toss) operation. This operation applies only to a single character set at a time
and must immediately follow that character set in the pattern. This operation removes the character that
matched the character set from the data.
+
Represents character set addition to form another character set.
-
Represents character set difference to form another character set.
concatenation
Concatenation is implied by proximity. For example, DDDU means 3 digits followed by an upper-case
letter.
The precedence of operators from highest to lowest is:
Grouping: () " "
Set construction: + -
Actions: #
Repetition: (n) (m..n) (m..*) (*)
Concatenation: proximity
Choice: |
The edit pattern is evaluated from left to right (the data from the screen is processed from left to right). Patterns
examine only one character at a time. They do not look ahead and they do not back track. For more information,
see the Programming Guide.
[UPPERCASE]
Specify UPPERCASE to translate the field coming from the terminal to upper case before placing it in the field
data area.
[VALUE (literal [THRU literal] [...])]
Use VALUE to specify a value, a series of values, or a range of values (or a combination) that constrain the
values accepted in the field. Values must be specified as literals of the correct type for the field. See Conditional
Expressions for more information.
[ERROR [ATTR {attribute-name|(attribute-list)}][{'literal'[ ]}|{field-name[ ]}]
ERROR specifies one or more fields or alphanumeric literals to be used as the error message issued by
Easytrieve in case of an automatically-detected error condition. The total length of the message text cannot
exceed the current screen size less two or the compiler issues an error message. Optionally, you can specify the
screen attribute to be used for the field in error.
Example
umber
ROW 5 'N ' COL 20 EMP-NUMBER ATTR PROTECT MASK 'ZZ9'
ame
ROW 'N ' COL 20 EMP-NAME UPPERCASE
ept
ROW 'D ' COL 20 EMP-DEPT VALUE (900 THRU 999) +
nvalid epartment
ERROR 'I D '
SCREEN Statement
The SCREEN statement in Easytrieve defines and initiates a SCREEN activity.
992
Easytrieve® Report Generator 11.6
A SCREEN activity defines a transaction-oriented processing activity under the control of keys pressed by the terminal
operator. Statements can also be inserted in screen procedures to retrieve and maintain files and databases.
NOTE
Screen processing is only available in Easytrieve Online.
The structure of a SCREEN activity is as follows:
SCREEN statement
Screen declaration statements:
DEFAULTs (first in declaration section)
KEYs, TITLEs, ROWs (in any order)
Screen procedures (both special-named and user-defined, in any order)
SCREEN activities can be executed by PROGRAM or other SCREEN activities. If a PROGRAM activity is not present, the
first SCREEN activity detected is automatically executed. A SCREEN activity continues processing until an EXIT, STOP,
or TRANSFER statement is executed. Easytrieve issues an error message when compiling a screen activity that does
not contain one of these statements.
If the LINESIZE and ROWCOUNT for a screen are less than the line size and number of rows on the terminal, the screen
is displayed as a pop-up window. Any fields from previous screens that are still displayed are given the ASKIP attribute to
prevent data entry on those screens.
When executing in TSO and CMS, if the terminal supports two presentation sizes, Easytrieve selects the presentation
size based on the size of the screen. When a pop-up window is displayed, the presentation space is based on the larger
of the previous display size or the size of the pop-up window.
This statement has the following format:
[ [ACTIVITY ] [TERMINAL ] ]
screen name
SCREEN [NAME - ] [COMMIT ([ ] [ ])] +
[ [NOACTIVITY] [NOTERMINAL] ]
rows columns
[UPPERCASE] [ROWCOUNT ] [LINESIZE ] +
screen start row screen start column
[ROW - - ] [COL - - ] +
attribute name
[ { - } ]
[BACKGROUND ATTR { } ] +
attribute list
[ {( - )} ]
[ {SINGLE } ]
attribute name
[ {DOUBLE } [ { - } ] ]
[BORDER ({ } [ATTR { } ] ] +
attribute list
[ {WIDE } [ {( - )} ] ]
border literal
[ {' '} ]
[SHADOW]
[NAME screen-name]
Optionally, specify a name for the SCREEN activity. Screen-name:
993
Easytrieve® Report Generator 11.6
• Can be up to 128 characters in length
• Can contain any character other than a delimiter
• Can begin with A to Z, 0 to 9, or a national character (#, @, $)
• Must not consist of all numeric characters
The screen-name can be used to identify the screen in an EXECUTE statement.
[COMMIT [ACTIVITY|NOACTIVITY] [TERMINAL|NOTERMINAL]]
Specify the COMMIT parameter to control the logical unit of work. COMMIT indicates when the activity commits
recoverable work. Each commit point posts all updates, additions and deletions, terminates holds, and closes
SQL cursors.
Specify ACTIVITY to commit all recoverable work during the normal termination of the activity. Specify
NOACTIVITY to tell Easytrieve not to commit at the end of the activity. NOACTIVITY is the default.
Specify TERMINAL to commit all recoverable work during any terminal I/O operation. In CICS, this results in
terminal I/O being performed in a pseudo-conversational mode. Specify NOTERMINAL to tell Easytrieve not to
commit during a terminal I/O. TERMINAL is the default.
If this activity is executed by an activity that has NOTERMINAL specified, this activity performs terminal I/O as if
NOTERMINAL was specified.
NOTE
You can also issue your own COMMIT and ROLLBACK statements to commit or recover on a controlled
basis.
[UPPERCASE]
Specify UPPERCASE to translate the data received from the terminal to upper case before it is processed. If
UPPERCASE is not specified, the data is processed as the user enters it.
[ROWCOUNT rows]
ROWCOUNT rows lets you override the default number of terminal rows for the screen display. The default is set
in the Site Options Table. For valid ROWCOUNT-LINESIZE combinations, see the next parameter, LINESIZE
columns.
[LINESIZE columns]
LINESIZE columns lets you override the default number of columns for the screen display. The default is set in the
Site Options Table.
On the mainframe, ROWCOUNT can be any value from 1 to 255. LINESIZE can be any value from 1 to 255. If the
dimensions of the screen exceed the screen size available on the display terminal, only a portion of the screen is
displayed.
[ROW screen-start-row] [COL screen-start-column]
Screen-start-row specifies the starting row of the screen. The default is 1.
Screen-start-column specifies the starting column of the screen. The default is 1.
[BORDER {SINGLE|DOUBLE|WIDE|'border literal'} [ATTR {attribute-name|(attribute-list)} ] ]
Use BORDER to specify that the screen has a border.
SINGLE, DOUBLE, or WIDE specifies that the border is built from a predefined line-drawing character set.
Borders on the mainframe are:
994
Easytrieve® Report Generator 11.6
'Border literal' specifies the character to be used for the screen border. This value must be a single character enclosed in
single quotes.
Optionally, specify a declared screen attribute name or a list of attribute keywords for the screen border. The following
attributes are ignored for BORDER:
• CURSOR
• NUMERIC
• INVISIBLE
• MUSTFILL
• MUSTENTER
• TRIGGER
• ALARM
For a list of attribute keywords, see ATTR Parameter . For more information about declared screen attributes, see the
DECLARE Statement .
Example
DEFINE WS-REPLY W 1 A
SCREEN NAME MAIN-MENU
TITLE 'Employee File Main Menu'
ROW 6 COL 10 'Type an option, then press Enter.'
ROW 8 COL 10 'Option ===>' WS-REPLY VALUE ('V' 'E' 'D' 'X') +
ERROR 'Please type V, E, D, or X'
ROW 10 COL 22 'V View employee'
ROW COL 22 'E Edit employee'
ROW COL 22 'D Delete employee'
ROW COL 22 'X Exit'
KEY F1 NAME 'Help' IMMEDIATE
KEY F3 NAME 'Exit' EXIT
KEY F12 NAME 'Cancel' EXIT IMMEDIATE
SEARCH Statement
The SEARCH statement in Easytrieve provides access to table information.
Special conditions of the IF statement can be used to validate the results of SEARCH operations.
After each SEARCH statement, you can code an IF file-name test to determine the success of the table search. When
the search is successful (IF file-name is true), result-field contains the table's descriptive data corresponding to the
search argument of search-field. When the search is unsuccessful (IF file-name is false), the contents of result-field are
unchanged.
You can code SEARCH statements any place in a PROGRAM, SCREEN, or JOB activity, and issue any number of
searches against any number of tables.
The file must be in ARG sequence and cannot contain any duplicates. The compare between the WITH field and the ARG
field in the table is a logical compare, that is, the compare ignores the data type and treats both fields as if they have a
data type of A.
When the table file is also an INDEXED file and the ARG field is the key, Easytrieve performs a keyed read of the file.
Otherwise, the entire file is read into memory and a binary search is performed. For more information on table processing,
see the Programming Guide.
995
Easytrieve® Report Generator 11.6
This statement has the following format:
file name search field result field
SEARCH - WITH - GIVING -
file-name
File-name is the name of the file that describes the table and its source. The file must have the TABLE parameter
on its FILE statement and must be a fixed length.
WITH search-field
Search-field identifies the field containing the search argument for the binary search. This parameter is defined in
any file, except for files with the TABLE parameter, or it can be defined in working storage.
The length and field type of search-field must match the length and field type of the ARG field defined for file-
name. Search-field cannot be a varying length field or a nullable field.
GIVING result-field
Result-field identifies the receiving field for the results of the table search. This parameter is defined in any file,
except for files with the TABLE parameter or it can be defined in working storage.
The length and field type of result-field must match the length and field type of the DESC field defined for file-
name. Result-field cannot be a varying length field or a nullable field.
Example
The following example illustrates the retrieval of high school class descriptions based upon class identification codes.
Statements:
DEFINE CODE W 4 A
DEFINE DESCRIPTION W 40 A
FILE CLASSES TABLE INSTREAM
ARG 1 4 A
DESC 10 40 A
1011 ENGLISH I
1012 ENGLISH II
1013 ENGLISH III
1014 ENGLISH IV
ENDTABLE
PROGRAM NAME MYPROG
MOVE '1012' TO CODE SEARCH CLASSES WITH CODE, GIVING
DESCRIPTION
IF CLASSES
DISPLAY DESCRIPTION
ELSE
DISPLAY 'CLASS NOT FOUND'
END-IF
Results:
ENGLISH II
SELECT Statement (File-based SQL)
The SELECT statement issued for an SQL file causes a cursor to be automatically declared and opened as an Easytrieve
file.
996
Easytrieve® Report Generator 11.6
The resulting cursor can then be fetched and updated by subsequent commands for the file. The cursor can also be the
subject of automatic input using the JOB statement.
NOTE
• If no SELECT statement is issued for an SQL file, a default SELECT is used (SELECT all defined columns
FROM file-name).
• If SELECT is the first statement in a JOB activity, the following happens:
– If the SELECT is for an automatic input file, the SELECT overrides the default SELECT.
– If the SELECT is for a file not used for automatic input, a DEFER should be coded on the SQL FILE
statement. If DEFER is not coded, the default SELECT is opened during the initialization processing, then
closed, and the coded SELECT processed. This causes unnecessary processing to occur.
• If a SELECT is specified for a file that has already been opened, either by the default SELECT or another
coded SELECT, then the existing SELECT for the file is closed and the new SELECT is used to open the file
again.
SELECT can be coded in a JOB's START procedure. However, since a file is normally opened before invoking the START
procedure, you should specify DEFER on the FILE statement. Otherwise, the default SELECT is opened before the
START procedure, and then the SELECT in the START procedure closes the default SELECT before it opens. This
causes extra processing that is not needed.
This statement has the following format:
file name
SELECT [DISTINCT] [FROM] - +
search condition
[WHERE - ] +
column name
[GROUP BY - + ] +
column name
[ [, - ...] ]
search condition
[HAVING - ] +
column name
[ { - } [ASC ] ]
[ORDER BY { } [ ] + ]
integer
[ { } [DESC] ]
[ ]
column name
[ [ { - } [ASC ] ] ]
[ [, { } [ ] ...] ] +
integer
[ [ { } [DESC] ] ]
[FOR UPDATE]
[DISTINCT]
DISTINCT eliminates duplicate rows. If DISTINCT is not specified, all rows are retrieved.
[FROM] file-name
Optionally, code FROM for statement readability.
file-name must be the name of an Easytrieve SQL file.
[WHERE search-condition]
Search-condition is used to specify conditions for the retrieval of data. The search-condition is applied to create
the result set for the file. For information about the search-condition, see your SQL vendor manuals.
[GROUP BY column-name]
GROUP BY is used to group data that is fetched into the file. For column-name syntax, see your SQL vendor
manuals.
997
Easytrieve® Report Generator 11.6
[HAVING search-condition]
Search-condition is used to specify the data to be provided to the user. HAVING can be used to compare the
results of all the returned data with a specific value in the data provided (such as the minimum or maximum
value). For information about the search-condition, see your SQL vendor manuals.
[ORDER BY {column-name|integer} [ASC|DESC]]
ORDER BY returns the rows of the result table in the order of the values of the specified column-names. Integer
references a column by its position in the result table rather than by a column-name. ASC returns the rows in
ascending order and is the default. DESC returns the rows in descending order.
[FOR UPDATE]
Specify FOR UPDATE to allow updates of the updatable fields defined in file-name. If used, FOR UPDATE must
be the last parameter specified on the SELECT statement. If FOR UPDATE is not coded and you attempt to
update file-name, you receive an error at execution.
Examples
The following code block is a file-based SQL SELECT statement example:
FILE PERSNL SQL (PERSONNEL)
EMPNAME * 20 A
WORKDEPT * 2 P 0
JOB NAME RETRIEVE-PERSONNEL INPUT PERSNL SELECT FROM PERSNL WHERE WORKDEPT = 921
DISPLAY EMPNAME +2 WORKDEPT
The next example shows a file-based SQL SELECT statement with DEFER:
FILE PERSNL SQL (PERSONNEL) DEFER
EMPNAME * 20 A
WORKDEPT * 2 P 0
JOB NAME RETRIEVE-PERSONNEL INPUT PERSNL START START-PROC
DISPLAY EMPNAME +2 WORKDEPT
START-PROC. PROC SELECT FROM PERSNL WHERE WORKDEPT = 921
END-PROC
SELECT Statement (Non-file SQL)
The non-file SQL SELECT statement allows Easytrieve to retrieve rows without a file.
This read-only method is retained from previous versions of Easytrieve .
The SELECT statement identifies the rows and columns that are to be input to the JOB activity. Only one SELECT
statement can be coded in each JOB activity, and it must be coded as the first statement in the JOB activity.
Code the SELECT statement immediately following the JOB INPUT SQL statement.
If this execution is for an SQL/DS system, a CONNECT statement is generated and executed by Easytrieve . This means
that the user does not need to include an SQL CONNECT statement when using Easytrieve automatic processing. The
user ID and password parameters are those that were specified in the USERID parameter of the PARM statement.
Easytrieve checks the SQLCODE field following each execution of the select-clause. If the SQLCODE indicates an error,
Easytrieve issues an error message based on the SQL error and terminates execution. An SQLCODE value indicating
end of data causes Easytrieve to initiate end of input processing: the FINISH PROC (if any) executes, spooled reports
are printed, and the current JOB activity ends. For a description of SQL codes, see your SQL vendor manuals.
The SQL cursor that is automatically defined by a SELECT statement is closed following the JOB activity referencing it.
998
Easytrieve® Report Generator 11.6
This statement has the following format:
{ {* }
expression
[DISTINCT] { { }
SELECT [ ] { { } +
table name
[ALL ] { { - .* }
correlation name
{ { - .*}
}
expression
[ { } ] }
table name
[, { - .* } . ..] } +
correlation name
[ { - .*} ] }
}
table name correlation name
FROM - [ - ] +
table name correlation name
[, - [ - ] ...] +
search condition
[WHERE - ] +
column name
[GROUP BY - + ] +
column name
[ [, - ...] ]
search condition
[HAVING - ] +
[ { {* } ]
expression
[ [DISTINCT] { { } ]
[UNION SELECT [ ] { { } + ]
table name
[ [ALL ] { { - .* } ]
correlation name
[ { { - .*} ]
[ ]
[ } ]
expression
[ [ { } ] } ]
table name
[ [, { - .* } ...] } + ]
correlation name
[ [ { - .*} ] } ]
[ } ]
[ ]
table name correlation name
[ FROM - [ - ] + ]
table name correlation name
[ [, - [ - ] ...] + ] +
[ ]
search condition
[ [WHERE - ] + ]
[ ]
column name
[ [GROUP BY - + ] + ]
column name
[ [ [, - ...] ] ]
[ ]
search condition
[ [HAVING - ] ]
column name
[ { - } [ASC ] ]
[ORDER BY { } [ ] + ]
integer
[ { } [DESC] ]
[ ]
column name
[ [ { - } [ASC ] ] ]
999
Easytrieve® Report Generator 11.6
[ [, { } [ ] ...] ] +
integer
[ [ { } [DESC] ] ]
host variable host variable
INTO : - [, : - ...]
[DISTINCT|ALL]
Specify DISTINCT to eliminate duplicate rows. ALL specifies that duplicate rows are not to be eliminated. ALL is
the default.
{*|expression|table-name.*|correlation-name.*}
These parameters are used to identify the columns to be retrieved from the specified table.
FROM table-name [correlation-name]
Table-name specifies the table from which data is to be retrieved. Correlation-name can be used to specify an
alternate qualifier for the table-name that immediately precedes it.
[WHERE search-condition]
Search-condition is used to specify conditions for the retrieval of data. The search-condition is applied to the result
of the FROM clause. For information about the search-condition, see your SQL vendor manuals.
[GROUP BY column-name]
GROUP BY is used to group data that is fetched into the file. Column-name must name a column in the file-name.
[HAVING search-condition]
Search-condition is used to specify the data to be provided to the user. HAVING can be used to compare the
results of all the returned data with a specific value in the data provided (such as the minimum or maximum
value). For information about the search-condition, see your SQL vendor manuals.
[UNION...]
The UNION clause is used to include rows from another table.
[ORDER BY {column-name|integer} [ASC|DESC]]
ORDER BY returns the rows of the result table in the order of the values of the specified column-names. Integer
references a column by its position in the result table rather than by a column-name. ASC returns the rows in
ascending order and is the default. DESC returns the rows in descending order.
INTO :host-variable [, :host-variable...]
INTO identifies where the column values are to be placed. The INTO clause must be the last clause coded on the
SELECT statement.
Example
The pseudo-code generated for automatic SQL processing is:
* IF SQL/DS
user id password
SQL CONNECT : - IDENTIFIED BY :
* END-IF
cursor select clause
SQL DECLARE CURSOR FOR
cursor
SQL OPEN
DO WHILE SQLCODE NE 100
cursor host variable
SQL FETCH INTO : - -1 +
host variable process <easy> code
[, : - -2...]
END-DO
cursor
SQL CLOSE
1000
Easytrieve® Report Generator 11.6
SELECT Statement (Report Selection)
A SELECT statement in Easytrieve can be executed in a REPORT-INPUT procedure to select report input data.
If the REPORT-INPUT procedure is not coded, all records selected with a PRINT statement are used in the report.
SELECT only sets a switch to cause record selection at a later time. If you SELECT a record twice, it appears only once
on the printed report.
If coded, a REPORT-INPUT procedure is performed for each PRINT statement (report input). To cause the data to
continue into report processing, you must execute a SELECT statement for the associated input data. In other words,
input that does not get selected is bypassed for continued processing. See REPORT-INPUT Report Procedure for more
information.
This statement has the following format:
SELECT
Example
REPORT-INPUT. PROC
IF ZIP NE HOLD-ZIP
HOLD-ZIP = ZIP SELECT
END-IF
END-PROC
SELECT Statement (Sort Selection)
Easytrieve supplies input records to your optional sort procedure one at a time. If a BEFORE procedure is used, a
SELECT statement must be executed for each record that you want to sort.
SELECT only sets a switch to cause record selection at a later time. If you SELECT a record twice, it appears only once
on the sorted file. If you SELECT a record and then issue a STOP, the record is not selected.
This statement has the following format:
SELECT
Example
The following example of a SORT activity shows an output file that contains only a reordered subset of the input file. The
output file contains only those records for which the SELECT statement is executed.
FILE PERSNL FB(150 1800)
%PERSNL
FILE SORTWRK FB(150 1800) VIRTUAL
COPY PERSNL
SORT PERSNL TO SORTWRK USING +
(REGION, BRANCH, DEPT, +
NAME-LAST, NAME-FIRST) +
NAME MYSORT BEFORE SCREENER
*
SCREENER. PROC
1001
Easytrieve® Report Generator 11.6
IF MARITAL-STAT = 'S' AND SEX = 1 SELECT
END-IF
END-PROC
SEQUENCE Statement
The SEQUENCE statement in Easytrieve optionally specifies the order of a report. You can order any report based on
the content of one or more fields.
The fields used to SEQUENCE a report do not have to be part of the printed report.
This statement has the following format:
field name
SEQUENCE - [D] ...
field-name
field-name identifies a field on which a report is ordered. You can specify multiple field-names for a report.
field-name must be in an active file or W-type working storage. Each field must be less than 256 bytes. The fields
specified are used as sort keys processed in major to minor order.
NOTE
Varying length, K, and M fields cannot be specified on a SEQUENCE statement.
[D]
An optional D following a field-name indicates that the field is sequenced into descending order. If you do not code
D after a field-name, by default the field is sorted in ascending order.
Examples
The following example illustrates using the SEQUENCE statement in a report declaration.
REPORT PERSNL-REPORT SEQUENCE REGION BRANCH PAY-NET D
CONTROL REGION BRANCH
TITLE 'PERSONNEL REPORT'
LINE REGION BRANCH EMPNAME PAY-NET
SET Statement
The SET statement in Easytrieve allows you to dynamically change screen attributes and to control the display of screen
errors.
You can code the SET statement in a screen procedure or in any procedure performed from a screen procedure, except
for SCREEN TERMINATION. If coded in a SCREEN TERMINATION procedure or if coded in a procedure called from a
SCREEN TERMINATION procedure, the SET statement is ignored at execution time.
The SET statement can be executed any number of times before displaying the screen. The last SET statement for field-
name determines the attributes or messages for that field.
The attributes or error message established by a SET statement remain for only one iteration of the SCREEN activity.
After the SCREEN is displayed, the attribute returns to its default as coded on the ROW statement. For changing field
attributes until they are modified further, use a declared attribute. For an example using dynamic screen attributes, see the
Programming Guide.
1002
Easytrieve® Report Generator 11.6
When multiple SET statements are coded for multiple field-names before the next display of a screen, the field-name that
is physically displayed first on the screen has its message displayed on the screen. All other field-names have only their
attributes displayed.
The SET statement overrides any ACTION messages defined in the MESSAGE statement, even if the MESSAGE
statement is executed after all SET statements.
The attributes and messages specified on the SET statement are evaluated when the statement is executed. If the
attributes or messages are variable, the value is saved and bound to the field-name when the SET statement is executed.
If the variables are later modified, the attributes or messages are not changed when the screen is redisplayed.
If you code SET field-name ERROR without any other parameters, the attributes and messages for field-name are
determined by the ROW statement. If the attributes and messages on the ROW statement are variable, the values
displayed for the SET statement are the same as the values determined when the ROW statement is evaluated.
When you execute a RESHOW, REFRESH, or GOTO SCREEN statement after a SET statement, the attributes or
messages specified in the SET statement are not affected.
This statement has the following format:
Format 1
field name
SET - ERROR +
attribute name literal
[ [ { - } ] [ {' ' [ ] } ] ]
[ [ATTR { } ] [ { [...] } ] ]
attribute list field name
[ [ {( - )} ] [ { - [ ] } ] ]
Format 2
attribute name
{ - }
field name
SET - ATTR { }
attribute list
{( - )}
field-name
Field-name specifies a field on a ROW statement in your screen declaration. Field-name can be indexed or
subscripted. If the index or subscript of field-name is evaluated and is not on the screen, the SET statement is
ignored.
ERROR
Use ERROR to indicate that you want to flag field-name as being in error and to specify attributes or messages
for field-name.
When you specify ERROR, the attributes or messages for field-name are determined by the hierarchy in the
following table. The priority is from highest to lowest.
Statement/ Area Attributes Message
1. SET statement ATTR parameter literal or field-name parameter(s)
2. ROW statement ERROR ATTR parameter ERROR 'literal' or field-name parameter(s)
3. DEFAULT statement FIELD ERROR ATTR parameter Default system message:
Value entered is not allowed. Type an
acceptable value.
4. Site Options Table FIELD ERROR ATTR parameter Default system message: Value entered is
not allowed. Type an acceptable value.
1003
Easytrieve® Report Generator 11.6
NOTE
If you code SET ERROR without the ATTR, 'literal' or field-name parameters, the attributes and messages are
determined by the next statement or area in the above hierarchy.
[ATTR {attribute-name|(attribute-list)}]
ATTR specifies either a declared screen attribute name or one or more attribute keywords. For a list of attributes,
see ATTR Parameter. For more information about declared screen attributes, see DECLARE Statement.
The following attributes are invalid for literals and system-defined read-only fields:
• ALARM
• CURSOR
• INVISIBLE
• MUSTENTER
• MUSTFILL
• NUMERIC
• TRIGGER
If you use these attributes, they are ignored, but Easytrieve Online issues a warning message during
compilation.
SENDONLY and ASKIP are assumed for literals and system-defined read-only fields.
{'literal'|field-name}
Use 'literal' to define the text you want displayed in the message. Use field-name to specify a field whose contents
you want displayed as part of the message. A message can consist of a combination of literals and field-names.
The maximum length of a message is 130 characters. If the message exceeds the message area for the screen
on which it is displayed, the message is truncated.
Examples
In the following example, when the department number is not found in the table, the field is flagged in error:
ROW DEPT ERROR 'Department in error'
...
AFTER-SCREEN. PROC
SEARCH DEPTBL WITH DEPT GIVING DEPT-DESC
IF NOT DEPTBL SET DEPT ERROR
END-IF
END-PROC
In the next example, when a user types a value greater than 50,000 into PAY-GROSS, PAY-GROSS is displayed in
yellow; otherwise PAY-GROSS is displayed in turquoise.
ROW PAY-GROSS
...
AFTER-SCREEN. PROC
IF PAY-GROSS > 50,000 SET PAY-GROSS ATTR (YELLOW)
ELSE SET PAY-GROSS ATTR (TURQ)
END-IF
END-PROC
In this example, five rows are displayed when the screen is displayed. Row 1 is displayed in blue and the cursor is
positioned in AFIELD. Rows 2 to 5 are displayed in yellow.
1004
Easytrieve® Report Generator 11.6
REPEAT 5 TIMES VARYING SUB1 FROM 1
ROW AFIELD(SUB1) ATTR (YELLOW)
END-REPEAT
...
BEFORE-SCREEN. PROC SET AFIELD(1) ATTR (BLUE CURSOR)
END-PROC
SKIP Statement
The SKIP Statement in Easytrieve is a listing control statement that spaces the printer a designated number of lines
before printing the next line of the statement listing.
You can code a SKIP statement anywhere in Easytrieve source code. SKIP must be on a record by itself. SKIP does not
appear in the printed output. However, the requested blank line appears.
This statement has the following format:
skip amount
SKIP -
skip-amount
Skip-amount must be an unsigned integer.
SORT Statement
The SORT statement in Easytrieve defines and initiates an activity that sorts a file that can be processed sequentially.
SORT sequences an input file in alphabetical or numerical order based on fields specified as keys.
SORT sequences an input file in alphabetical or numerical order based on fields specified as keys.
Easytrieve supplies input records to your sort procedure one at a time. If a BEFORE proc-name procedure is used:
• You must execute a SELECT statement for each record that you want returned to the output file.
• A selected record is written only once, even if selected more than once in the procedure.
• Any record not selected does not get written to the sorted file.
• If the file being sorted is a variable length record file, the output file is generated with a record length equal to the
maximum record length that is specified in the FILE statement.
SORT activities can be executed by PROGRAM and SCREEN activities. If a PROGRAM activity is not coded, JOB and
SORT activities are automatically executed sequentially until a SCREEN activity is encountered.
For more information about sorting files, see the Programming Guide.
This statement has the following format:
input file name sorted file name
SORT - - TO - - +
sort key field name
USING ( - - - [D] ...) +
[ [ACTIVITY ] [TERMINAL ] ]
[COMMIT ([ ] [ ])] +
[ [NOACTIVITY] [NOTERMINAL] ]
record count
[SIZE - ] +
1005
Easytrieve® Report Generator 11.6
number of work data sets
[WORK - - - - ] +
proc name
[BEFORE - ] +
sort name
[NAME - ]
input-file-name
input-file-name is the name of the input file for the SORT activity.
input-file-name must reference a FILE statement that defines a SEQUENTIAL, INDEXED, RELATIVE, or VFM
file. The record length of input-file-name controls the length of records to be sorted, except when both files are
fixed length. When this occurs, the length of the records is equal to that of input-file-name or sorted-file-name,
whichever is shorter.
TO sorted-file-name
sorted-file-name designates the name of the output file of the sort activity. Sorted-file-name must reference a FILE
statement that defines a SEQUENTIAL, INDEXED, RELATIVE, or VFM file.
If sorted-file-name is the same file name as input-file-name, the sorted output is written over the input file.
USING (sort-key-field-name [D] ...)
USING (sort-key-field-name) specifies key fields for sorting input-file-name.
You can code any number of fields up to the input limit of your installation's sort program. sort-key-field-name can
be any field less than 256 bytes long in the sort input file. (The only exceptions are variable length fields, which
cannot be used as keys.) sort-key-field-name cannot be a nullable field.
Code D to sort output in descending order. The default is ascending order.
NOTE
Varying length, K, and M fields cannot be specified as sort keys.
[COMMIT [ACTIVITY|NOACTIVITY] [TERMINAL|NOTERMINAL]]
Specify the COMMIT parameter to control the logical unit of work. COMMIT indicates when the activity commits
recoverable work. Each commit point posts all updates, additions, and deletions, and terminates holds. SQL
cursors may or may not be closed, depending on the underlying database and the cursor definition.
Specify ACTIVITY to commit all recoverable work during the normal termination of the activity. Specify
NOACTIVITY to tell Easytrieve not to commit at the end of the activity. NOACTIVITY is the default.
Specify TERMINAL to commit all recoverable work during any terminal I/O operation. In CICS, this results in
terminal I/O being performed in a pseudo-conversational mode. Specify NOTERMINAL to tell Easytrieve not to
commit during a terminal I/O. TERMINAL is the default.
If this activity is executed by an activity that has NOTERMINAL specified, this activity performs terminal I/O as if
NOTERMINAL was specified.
For more information, see the Programming Guide.
[SIZE record-count]
Because Easytrieve knows the number of records in files created by previous activities, it automatically supplies
that information to the sort program. If the file was not created by a previous activity, you can enhance sort
efficiency by supplying the approximate number of records as record-count on the optional SIZE parameter.
Record-count must be an unsigned integer.
[WORK number-of-work-data-sets]
Specifies the number of work data sets used by the sort program. Number-of-work-data-sets must be one of the
following:
• A zero -- to indicate that DD statements are supplied
• A value from 1 to 31 -- to indicate the number of work data sets that the sort program dynamically allocates
This parameter overrides the number of work data sets set in the Site Options Table.
1006
Easytrieve® Report Generator 11.6
[BEFORE proc-name]
Optionally, specify proc-name to identify your procedure that pre-screens, modifies, and selects input records for
the sort. See SELECT Statement (Sort Selection) for more information.
If you do not specify BEFORE proc-name, Easytrieve sorts all records in input-file-name and writes them to
sorted-file-name.
[NAME sort-name]
Optionally, specify sort-name to identify the SORT activity. Sort-name:
• Can be up to 128 characters in length
• Can contain any character other than a delimiter
• Can begin with A to Z, 0 to 9, or a national character (#, @, $)
• Must not consist of all numeric characters
The sort-name can be used to identify the sort in an EXECUTE statement.
Example
In the following example, the output file contains all of the records of the input file sorted into ascending sequence by the
values of fields REGION and BRANCH:
FILE PERSNL FB(150 1800)
%PERSNL
FILE SORTWRK FB(150 1800) VIRTUAL
COPY PERSNLSORT PERSNL TO SORTWRK USING + (REGION, BRANCH) NAME MYSORT
SQL Statement
The SQL statement in Easytrieve supports the SQL statements of various database management systems. Review the
SQL statements according you your database management system.
The SQL statement supports the SQL statements of the following database management systems:
• DB2
• SQL/DS
• Datacom/DB SQL
• IDMS SQL
• Ingres
• Oracle
• Sybase
• ODBC
This statement has the following format:
native sql statement
SQL - -
Usage Notes
For information about the syntax for native database statements, see the specific database management system manual.
Listed below are the SQL statements currently supported by the SQL interface. For more information about coding native
SQL statements, see the Programming section.
DB2 SQL Statements:
1007
Easytrieve® Report Generator 11.6
• ALTER
• CLOSE cursor-name
• COMMENT ON
• COMMIT {work}
• CONNECT
• CREATE
• DECLARE cursor-name {with hold}
• DELETE {where current of cursor-name}
• DROP
• EXPLAIN
• FETCH cursor-name
• GRANT
• INSERT
• LABEL
• LOCK
• OPEN cursor-name
• RELEASE
• REVOKE
• ROLLBACK {work}
• SELECT INTO *(for static-only processing)
• SET CONNECTION
• SET CURRENT DEGREE
• SET CURRENT PACKAGESET
• SET CURRENT QUERY ACCELERATION
• SET CURRENT SQLID
• SET host-variable
• UPDATE {where current of cursor-name}
Note: See SQLSYNTAX in PARM Statement for more information.
SQL/DS SQL Statements:
1008
Easytrieve® Report Generator 11.6
• ACQUIRE
• ALTER
• CLOSE cursor-name
• COMMENT
• COMMIT {work}
• CONNECT userid
• CONNECT TO database
• CREATE
• DECLARE CURSOR-NAME
• DELETE {where current of cursor-name}
• DROP
• EXPLAIN
• FETCH cursor-name
• GRANT
• INSERT
• LABEL
• LOCK
• OPEN cursor-name
• PUT
• REVOKE
• ROLLBACK {work}
• UPDATE {where current of cursor-name}
Datacom/DB SQL Statements:
• ALTER
• CLOSE cursor-name
• COMMENT
• COMMIT {work}
• CREATE
• DECLARE cursor-name
• DELETE {where current of cursor-name}
• DROP
• FETCH cursor-name
• GRANT
• INSERT
• LOCK
• OPEN cursor-name
• REVOKE
• ROLLBACK {work}
• SELECT INTO
• UPDATE {where current of cursor-name}
IDMS SQL Statements:
1009
Easytrieve® Report Generator 11.6
• ALTER
• CLOSE cursor-name
• COMMIT {work} {continue} {release}
• CONNECT TO dictionary-name
• CREATE
• DECLARE cursor-name
• DELETE*
• DROP
• EXPLAIN
• FETCH cursor-name
• GRANT
• INSERT
• OPEN cursor-name
• RELEASE
• RESUME
• REVOKE
• ROLLBACK {work}
• SET SESSION CURSOR STABILITY (**)
• SET SESSION READ ONLY (**)
• SET SESSION READ WRITE (**)
• SET SESSION TRANSIENT READ (**)
• SET TRANSACTION CURSOR STABILITY (**)
• SET TRANSACTION READ ONLY (**)
• SET TRANSACTION READ WRITE (**)
• SET TRANSACTION TRANSIENT READ **
• SUSPEND
• UPDATE*
These SET management statements (**) establish SQL characteristics at the SESSION or TRANSACTION level. They
are available with Easytrieve 11.6 New Function mode and Pan/SQL 2.6.
NOTE
WHERE CURRENT OF cursor cannot be dynamically processed by the SQL interface for IDMS. To perform
SQL updates, you must code native SQL statements using a search WHERE clause.
Ingres SQL Statements:
• CLOSE cursor-name
• COMMIT {work}
• CONNECT
• CREATE
• DECLARE cursor-name
• DELETE
• DISCONNECT
• DROP
• FETCH cursor-name
• INSERT
• OPEN cursor-name
• ROLLBACK {work}
• UPDATE
1010
Easytrieve® Report Generator 11.6
Oracle SQL Statements:
• CLOSE cursor-name
• COMMIT {work}
• CONNECT
• CREATE
• DECLARE cursor-name
• DELETE
• DISCONNECT
• DROP
• FETCH cursor-name
• INSERT
• OPEN cursor-name
• ROLLBACK {work}
• UPDATE
Sybase SQL Statements:
• CLOSE cursor-name
• COMMIT {work}
• CONNECT
• CREATE
• DECLARE cursor-name
• DELETE
• DISCONNECT
• DROP
• FETCH cursor-name
• INSERT
• OPEN cursor-name
• ROLLBACK {work}
• UPDATE
• USE
ODBC SQL Statements:
• CLOSE cursor-name
• COMMIT {work}
• CONNECT
• CREATE
• DECLARE cursor-name
• DELETE
• DISCONNECT
• DROP
• FETCH cursor-name
• INSERT
• OPEN cursor-name
• ROLLBACK {work}
• UPDATE
• USE
1011
Easytrieve® Report Generator 11.6
SQL INCLUDE Statement
The SQL INCLUDE statement in Easytrieve indicates that SQL table information is to be used to generate field
definitions.
This statement names the table and gives the location where the field definitions are generated.
This statement has the following format:
SQL INCLUDE +
column
[( ...)] +
starting position
[ { - } ]
offset
[ {* [+ ] } ]
[LOCATION { } ] +
[ {W } ]
[ {S } ]
[HEADING] +
[UPDATE] +
[NULLABLE] +
owner table
FROM [ .]
[(column ...)]
Specify a list of one or more column names for which field definitions are to be generated. The column name(s)
must be enclosed within parentheses. If no column names are specified, all columns from the table are used.
[LOCATION {starting-position|* [+offset]|W|S}]
Use this optional parameter to specify the location at which the field definitions are to be generated. This
parameter functions as the starting-location parameter of the DEFINE statement.
Starting-position specifies the starting position relative to position one of the record or file.
The * (asterisk) indicates that the field begins in the next available starting position (highest position assigned so
far, plus 1) within a file. The optional +offset is an offset you want added to the * value. There must be at least one
blank between the * and the optional +offset. Use * when this SQL INCLUDE is used to generate fields within a
FILE.
Coding W or S establishes a working storage field. W fields are spooled to report (work) files; S fields are not. W
is the default location if the LOCATION parameter is not coded.
[HEADING]
Optionally, code HEADING to cause remarks in the DBMS system catalog entry for a column to be copied into a
HEADING parameter on the generated DEFINE statement for the column. This parameter is ignored for Ingres.
[UPDATE]
Code UPDATE to designate a modifiable column.
When an Easytrieve SQL file does not contain the UPDATE parameter, only the specific columns defined with
UPDATE can be modified with an UPDATE statement. If UPDATE is coded on the FILE statement, all columns in
the file can be modified.
NOTE
You can use UPDATE only when the field definitions are generated for an Easytrieve file.
1012
Easytrieve® Report Generator 11.6
[NULLABLE]
Optionally, code NULLABLE to cause default indicator fields to be defined for columns that contain NULL. The
indicator field is defined as a 2 B 0 field preceding the field being defined. Easytrieve automatically uses the
default null indicator whenever the associated column is referenced. You can override the use of the default null
indicator by explicitly coding and referencing another indicator variable.
The indicator variable precedes the data portion of the field in storage. This field cannot be directly referenced. To
check this indicator variable, you must use the IF NULL statement.
FROM [owner.] table
FROM identifies the table definition to be defined to Easytrieve . Owner is the optional 1- to 18-character
alphanumeric qualifier, and table is the 1- to 32-character alphanumeric name. The period must be used as the
qualification separator for owner-qualified tables.
NOTE
If the owner is not specified, the current authorization ID is used.
Usage Notes
When used, the SQL INCLUDE statements must precede any other SQL or SELECT statements and must be coded in
the library definition section of your Easytrieve program.
The generated Easytrieve field names are the same as the SQL column names. If a name matches a reserved word, the
field definition is allowed, but all references to it must be qualified, using any applicable qualification.
Mask information is not retrieved from the DBMS system catalog.
Group qualification structures of owner.table are defined prior to the first included definition. The fields are defined under
the table entity, which is in turn under the owner level entity. This ensures that multiple tables with duplicate column
names do not produce duplicate field names.
Fields with SQL data types that do not have equivalent Easytrieve data types are defined as shown in the following
table. Fields of DATE, TIME, TIMESTAMP, and BINARY cannot be used in arithmetic operations. Fields of FLOAT,
DOUBLEPRECISION, REAL, and LONGINTEGER are defined as packed decimal fields. Non-zero FILE-STATUS and
SQLCODE values are returned if the data is truncated.
SQL Data Type Easytrieve Data Type Length Decimals
DATE Alphanumeric 10
TIME Alphanumeric 8
TIMESTAMP Alphanumeric 26
BINARY Alphanumeric Length of SQL field
FLOAT Packed Numeric 10 3
DOUBLEPRECISION Packed Numeric 10 3
REAL Packed Numeric 10 3
LONGINTEGER Packed Numeric 10 0
The DBMS system catalog must be referenced each time the program is compiled or interpreted. Therefore, to reduce
catalog contention and to improve performance, you should always create link-edited programs.
Field Reference
One of the advantages of using the SQL INCLUDE interface is the ability to reference host-variables ( Easytrieve fields)
using the group level TABLE definition.
When specifying the INTO clause on a native SQL FETCH or non-file SQL SELECT statement or the VALUES clause
of the native SQL INSERT statement, you can substitute the host variable TABLE definition in place of coding all host-
variables in the table.
1013
Easytrieve® Report Generator 11.6
If you require access to an indicator variable other than its use for NULL checking, you must define your own variable and
reference it with its host-variable. For some DBMSs, the indicator variable is examined to detect truncation.
When the host-variable is an Easytrieve group level definition of a table name, an array of type 2 B 0 should be specified
immediately following the host-table-name-variable. The number of array elements should match the number of fields in
the Easytrieve table name definition. Array elements are matched one-to-one with the fields defined in the table name.
STOP Statement
The STOP statement in Easytrieve terminates activities. Review examples of STOP and STOP EXECUTE.
In Easytrieve , activities with automatic file input automatically terminate when all input records have been processed.
You can terminate activities prematurely, however, with a STOP statement. You must use STOP to terminate JOB
activities without automatic file input (for example, JOB INPUT NULL).
NOTE
Use the EXIT statement to normally terminate SCREEN activities.
When used in a JOB activity, STOP completes all reports and executes a FINISH procedure, if coded. If you code STOP
EXECUTE, all Easytrieve activity procedures are immediately terminated. If STOP is coded in the START or FINISH
procedure, the procedure is terminated.
When used in a SORT activity procedure, a STOP terminates the record selection process and executes the sort
program. If you selected a record, the record is not accepted.
When COMMIT ACTIVITY is specified for the activity, a STOP statement causes a COMMIT of all recoverable work. A
STOP EXECUTE causes a ROLLBACK.
This statement has the following format:
STOP [EXECUTE]
[EXECUTE]
EXECUTE immediately terminates all Easytrieve execution and is considered an abnormal termination and
causes recoverable resources to be rolled back, etc.. STOP without EXECUTE terminates the current activity
only. Subsequent activities (if any) are executed normally.
Examples
The following example illustrates STOP in a SORT activity to limit the number of records being sorted. In this example,
only the first 50 records from PERSNL are sorted, because the STOP statement simulates end-of-file on PERSNL.
FILE PERSNL FB(150 1800)
%PERSNL
FILE SORTOUT FB(150 1800) VIRTUAL
COPY PERSNL
*
SORT PERSNL TO SORTOUT +
USING (PAY-GROSS D) +
NAME MYSORT BEFORE SORT1-PROC
*
SORT1-PROC. PROC
IF PERSNL:RECORD-COUNT GT 50
STOP
ELSE
1014
Easytrieve® Report Generator 11.6
SELECT
END-IF
END-PROC
Under certain circumstances, you might want to completely terminate all activities using a STOP EXECUTE statement, as
in the next example:
FILE INVENT FB(200 3200)
%INVMSTR
FILE SORTWRK F(200) VIRTUAL
COPY INVENT
*
JOB INPUT INVENT NAME MYPROG1 FINISH FINISH-PROC
PRINT MYREPORT
*
FINISH-PROC. PROC
IF RECORD-COUNT = 0
DISPLAY 'INPUT FILE NOT AVAILABLE'
DISPLAY 'HALTING EXECUTION...'
STOP EXECUTE
END-IF
END-PROC
*
REPORT MYREPORT
LINE PART-NUMBER PART-DESCRIPTION
*
SORT INVENT TO SORTWRK USING +
(LOCATION-STATE, +
LOCATION-CITY) NAME MYSORT
*
JOB INPUT SORTWRK NAME MYPROG2
PRINT MYREPORT
*
REPORT MYREPORT
LINE PART-NUMBER LOCATION-CITY LOCATION-STATE
NOTE
In 6.4, the STOP statement could be used with EXECUTE parm in the following format:
STOP (EXECUTE)
In 11.6 Easytrieve version, it is necessary that the STOP statement use the EXECUTE parm in the following
format:
STOP EXECUTE
Use to a different format for this statement results in an error message.
SUM Statement
The SUM statement in Easytrieve is a report definition statement that specifies the quantitative fields that are totaled for
a control report.
1015
Easytrieve® Report Generator 11.6
Normally, Easytrieve automatically totals all quantitative fields specified on LINE statements. The SUM statement
overrides this process; only the fields specified on the SUM statement are totaled. The fields specified on a SUM
statement do not have to be specified on a LINE statement. The SUM statement is valid only in a Control Report.
This statement has the following format:
field name
SUM - ...
field-name
Field-name is any quantitative field contained in an active file or W storage. You can specify multiple fields.
TERMINATION Report Procedure
A TERMINATION procedure in Easytrieve is invoked at the end of the report. This procedure can be used to print report
footing information, including control totals and distribution information.
You must use an END-PROC statement to delimit a TERMINATION procedure. See PROC Statement for more
information.
This statement has the following format:
TERMINATION. PROC
Example
The following is an example of report footing:
FILE FILE1
LAST-NAME 1 5 A
STATE 6 2 A
ZIP 8 5 N
PAY-NET 13 5 N 2
TOTAL-NET S 8 N 2
JOB INPUT FILE1 NAME MYPROG
TOTAL-NET = TOTAL-NET + PAY-NET
PRINT REPORT1
*
REPORT REPORT1 LINESIZE 65 +
SUMMARY SUMCTL DTLCOPY
SEQUENCE STATE ZIP LAST-NAME
CONTROL STATE NEWPAGE ZIP
TITLE 'REPORT FOR THE STATE OF' STATE
LINE 01 LAST-NAME STATE ZIP PAY-NET
*
TERMINATION. PROC
DISPLAY TITLE
DISPLAY SKIP 5 TOTAL-NET 'IS THE Y-T-D COMPANY NET PAY'
DISPLAY SKIP 5 'PLEASE ROUTE THIS REPORT TO CORPORATE OFFICERS'
END-PROC
TERMINATION Screen Procedure
A TERMINATION procedure in Easytrieve is invoked once during the end of the screen activity.
1016
Easytrieve® Report Generator 11.6
The TERMINATION procedure is performed when an EXIT action has been executed either by being assigned to a key or
by being executed in another screen procedure. It is used to perform actions that are to be executed only at the end of the
activity.
If GOTO SCREEN or EXIT is executed in a TERMINATION procedure, the activity is stopped at that point. REFRESH and
RESHOW are invalid in a TERMINATION activity.
You must use an END-PROC statement to delimit a TERMINATION procedure. See PROC Statement for more
information.
This statement has the following format:
TERMINATION. PROC
TITLE Statement (Reports)
One or more TITLE statements in Easytrieve define an optional report title. The TITLE statement defines the title items
and their position on the title line.
Easytrieve automatically positions the system date and current page count on title line one. This can be overridden by
options on the REPORT statement (NODATE and NOPAGE).
This statement has the following format:
field name
{[ ] - }
font number
{[# - ] }
title number literal
TITLE [ - ] {[ ] ' ' } ...
offset
{+ }
offset
{- }
column number
{COL - }
[title-number]
Title-number specifies the position of the title line in the title area. Title-number must be from 1 to 99 (default is 1).
You must specify title numbers in ascending order with no duplicates. The title-number of the first TITLE statement
must be 1 or unspecified.
[#font-number]
#Font-number defines a font index. The value of #font-number identifies a font whose specifications are to be
used for the next display item. You can only specify this option if the report has been associated with an extended
reporting printer. #Font-number identifies the font number of a font defined for the associated extended reporting
printer. If you do not code the font number, then the next display item uses the default font for the assigned
extended reporting printer.
{field-name}
Field-name specifies a field in any active file, working storage field, or system-defined field.
{'literal'}
'Literal' specifies a character string for a title item. It must be either a numeric literal, a hexadecimal literal, or an
alphanumeric literal. Alphanumeric literals must be enclosed in single quotes.
By default, each title line is formatted as a list of title items that are separated by the number of spaces defined by
the SPACE parameter of the REPORT statement. The +, -, and COL parameters modify this positioning.
NOTE
You must code at least one title item, specified by field-name or 'literal', on each TITLE statement.
1017
Easytrieve® Report Generator 11.6
{+offset|-offset}
The space adjustment parameters, +offset and -offset, modify the normal spacing between title items. Offset is
added to or subtracted from the SPACE parameter on the REPORT statement to get the absolute space between
title items. The absolute space value can range from zero to any amount that still allows the title line to fit within
the current LINESIZE value on the REPORT statement.
{COL column-number}
The COL parameter specifies the print column number where the next title item is placed. The value of column-
number has a valid range of 1 to nnn, where nnn cannot force the following title item beyond the end of the title
line LINESIZE.
Each title line is centered within the title area of the report unless you specify NOADJUST.
When the report is associated with an extended reporting printer, an error results if two or more fields or literals
overlap.
TITLE Statement (Screens)
The TITLE statement in Easytrieve is used to automatically center items on a screen.
TITLE items that are not located at a specific column (COL) are centered in the row based on the LINESIZE parameter of
the SCREEN statement.
This statement has the following format:
column number field name
[[COL - ] { - }
row number
TITLE [ - ] [[ ] { } +
offset literal
[[+ ] {' ' }
attribute name
[ { - } ] ]
[ATTR { } ] ] ...
attribute list
[ {( - )} ] ]
[row-number]
Specify the row-number on which you want the TITLE to be displayed. If row-number is not specified, the next
screen row is used for the title. The next screen row is not the highest row used, but the previously-specified row
plus one. If no rows are previously specified, row one is used.
[COL column-number][+offset]
Use COL to display a title item at a specific column (column-number) on the screen.
Titles are separated by one space on a screen. Use +offset to add additional spaces between titles.
NOTE
A syntax error occurs when a TITLE overlays another screen item.
{field-name|'literal'}
Specify a field-name or a 'literal' for the title. Field-name is the name of a field to be displayed as a title on the
screen. 'Literal' is an alphanumeric string to be displayed as a title on the screen.
[ATTR {attribute-name|(attribute-list)}]
Specify a declared screen attribute name or a list of attribute keywords. For a list of attributes, see ATTR
Parameter. For procedures to DECLARE screen attributes, see DECLARE Statement.
NOTE
The following attributes are invalid for TITLEs:
If you use these attributes, they are ignored, but Easytrieve issues a warning message during compilation.
SENDONLY and ASKIP are assumed for TITLE items.
Example
1018
Easytrieve® Report Generator 11.6
The following TITLE statement:
ate mployee aster
TITLE 1 COL 1 'D :' COL 7 SYSDATE 'E M ' +
ime
COL 67 'T :' COL 73 SYSTIME
produces:
Date: 12/31/09 Employee Master Time: 12:00:00
SYSDATE and SYSTIME are displayed starting in specific columns by using the COL parameter. 'Employee Master' is
automatically centered.
TRANSFER Statement
The TRANSFER statement in Easytrieve is used to transfer execution to a target program without returning to the
invoking program.
The TRANSFER statement completely terminates the current Easytrieve program and invokes the program specified by
program-name or the program field-name using the linkage conventions of the operating system in which the program
is executing. Issuing a TRANSFER statement is similar to issuing a STOP statement: reports are completed and a JOB
FINISH procedure is executed (if coded).
The screen is automatically cleared when the current program terminates. In CICS, you can request that the screen
remains displayed on the terminal by using the NOCLEAR parameter. In other environments, NOCLEAR is ignored and
the screen is cleared and left in a ready mode.
NOTE
The target program inherits the execution environment of the program issuing the TRANSFER statement.
TRANSFER can be used to invoke any program written in any language that is supported by the operating system in
which the program is executing; similarly, the program can issue any command supported by the operating system.
When the target program is another Easytrieve program and you want to pass a parameter, you must specify the USING
parameter on the target program's PROGRAM statement.
When transferring to another Easytrieve program in a CICS pseudo-conversational environment, you must specify the
TRANSID parameter on the PARM statement of the target program.
NOTE
Using the TRANSFER statement in interpretive execution causes the program execution to terminate. For more
information, see the Programming section.
This statement has the following format:
field-name field-name
{ } [ { } ]
TRANSFER { } [USING { } ] [NOCLEAR]
program-name literal
{' '} [ {' ' } ]
{field-name|'program-name'}
Specify the field-name that contains the name of the target program, or specify the name of the target program as
a 'literal' within single quotes. Field-name cannot be nullable.
[USING {field-name|'literal'}]
Optionally, specify USING to pass a single parameter to the target program.
Specify the name of a field that contains the value to pass to the target program, or specify a 'literal' to pass to the
target program. Field-name cannot be nullable.
1019
Easytrieve® Report Generator 11.6
[NOCLEAR]
Use NOCLEAR to specify that you do not want to clear the terminal screen when exiting an Easytrieve program in
CICS.
Example
CASE OPTION
WHEN 'V'
NEXT-PGM = 'VIEWCUST'
WHEN 'E'
NEXT-PGM = 'EDIT-CUST
WHEN 'D'
NEXT-PGM - 'DEL-CUST'
WHEN 'A'
NEXT-PGM = 'ADD-CUST'
END-CASE
TRANSFER NEXT-PGM USING EMP#
UPDATE Statement
The UPDATE statement in Easytrieve updates a row from an SQL file.
UPDATE issues an UPDATE WHERE CURRENT OF cursor.
When the file is defined with the UPDATE parameter, all defined columns are updated. Otherwise, only the columns that
contain the UPDATE parameter are updated. See SQL INCLUDE Statement>or DEFINE Statement for more information.
NOTE
UPDATE WHERE CURRENT OF cursor cannot be dynamically processed by the SQL interface for IDMS. To
perform SQL updates, you must code native SQL statements using a searched update statement.
This statement has the following format:
file name
UPDATE -
file-name
File-name is the name of an Easytrieve SQL file.
Example
The following example changes all employees in department 901 to department 921:
FILE PERSNL SQL PERSONNEL UPDATE
EMPNAME * 20 A
WORKDEPT * 2 P 0
EMPPHONE * 3 P 0
JOB NAME RETRIEVE-PERSONNEL INPUT PERSNL
SELECT FROM PERSNL WHERE WORKDEPT = 901 FOR UPDATE
WORKDEPT = 921
UPDATE PERSNL
WRITE Statement
WRITE statements in Easytrieve are used in the maintenance of SEQUENTIAL, INDEXED, and RELATIVE files (when
allowed by the underlying access method).
1020
Easytrieve® Report Generator 11.6
During random processing of these files, WRITE updates and deletes existing records and adds new records. The syntax
of this staement has two formats:
Format 1
input file name
[UPDATE] [ { - - }]
output file name
WRITE - - [ ] [FROM { }][STATUS]
input record name
[ADD ] [ { - - }]
Format 2
output file name
WRITE - - DELETE [STATUS]
output-file-name
Specify the name of the SEQUENTIAL, INDEXED or RELATIVE file to be updated, added, or deleted. You must
also code UPDATE on the FILE statement for output-file-name.
[UPDATE|ADD|DELETE]
Specify UPDATE, ADD, or DELETE to designate the type of file maintenance activity to be performed. UPDATE is
the default.
For SEQUENTIAL files, only UPDATE is allowed. For RELATIVE files, only UPDATE and DELETE are allowed.
[FROM {input-file-name|input-record-name}]
Specify input-file-name or input-record-name to identify an alternative data source for file UPDATE and ADD
operations. FROM is similar to coding a MOVE statement prior to a WRITE statement.
When input-file-name is specified, the current value of output-file-name:RECORD-LENGTH is the length of the
output data. However, if the output file length is greater than the input file or record length, the excess storage is
not initialized. Also, using the FROM parameter does not update the data area of the output file.
[STATUS]
Specify the STATUS parameter whenever the possibility exists for an unsatisfactory completion of the input/output
request.
STATUS checks input/output processing to see if it was performed properly. STATUS causes the file's FILE-
STATUS field to be set with the appropriate return code. Normally, a zero or non-zero test is sufficient.
NOTE
FILE-STATUS is not defined if you do not specify a file type parameter on the FILE statement.
If you do not code STATUS and the operating system returns a non-zero status, Easytrieve issues an
appropriate diagnostic message.
Usage Notes
Format 1
Format 1 of the WRITE statement updates an existing record or adds a new record to the file. When updating, which is the
default, the updated record is the current active record for the file.
Format 2
Format 2 of the WRITE statement deletes the current active record for the file.
Example
The following example illustrates the use of WRITE:
FILE PERSNL INDEXED UPDATE
%PERSNL
PROGRAM NAME MYPROG
1021
Easytrieve® Report Generator 11.6
READ PERSNL KEY '05807' STATUS
IF PERSNL:FILE-STATUS NE 0
DISPLAY 'FILE-STATUS= ' PERSNL:FILE-STATUS
DISPLAY 'UNSUCCESSFUL READ ON PERSNL FILE'
ELSE
DISPLAY HEX PERSNL
MOVE '3125059599' TO TELEPHONE
WRITE PERSNL UPDATE
IF PERSNL:FILE-STATUS NE 0
DISPLAY 'FILE-STATUS= ' PERSNL:FILE-STATUS
DISPLAY 'UNSUCCESSFUL UPDATE ON PERSNL FILE'
END-IF
END-IF
Symbols and Reserved Words
Review a list of symbols and reserved words used with Easytrieve Report Generator.
The reserved words are listed in alphabetical order. Associated with each symbol is one or more references. The
references describe the various ways you can use the symbol. An R in the column after the symbol indicates it is
reserved.
Symbol References
Special Symbol Reserved Reference
. Syntax delimiter (period)
Macro parameter concatenation (period)
< Conditional expression
<= Conditional expression
( Syntax delimiter (left parenthesis)
: Syntax delimiter (colon)
+ Assignment
Continuation of statements and words
DISPLAY
LINE
TITLE
& Macro variable prefix
* Assignment
Comment statement
DEFINE
) Syntax delimiter (right parenthesis)
Ø< Conditional expression POINT
Ø> Conditional expression
Ø= Conditional expression
1022
Easytrieve® Report Generator 11.6
- Assignment
Continuation of statements and words
DISPLAY
LINE
TITLE
** R Reserved for future use
/ Assignment
' Syntax delimiter (single quote)
% Macro invocation
> Conditional expression
>= Conditional expression
POINT
, Syntax delimiter (comma)
= Assignment
Conditional expression
POINT
@ R Reserved for future use
1023
Easytrieve® Report Generator 11.6
Reserved Words
The following list includes all Easytrieve reserved words:
ACCESS EOF LIST RESTART
AFTER-BREAK EQ LOGICAL-RECORD RETRIEVE
AFTER-LINE ERROR LOW-VALUES RETURN-CODE
AFTER-SCREEN EXECUTE LQ ROLLBACK
AND EXIT LS ROW
ATTR EXTERNAL LT S
BEFORE F1, F2,..F24 MASK SCREEN
BEFORE-BREAK FETCH MATCHED SEARCH
BEFORE-LINE FILE MEND SECONDARY
BEFORE-SCREEN FILE-STATUS MESSAGE SELECT
BREAK-LEVEL FILL MOVE SEQUENCE
BUSHU FINAL MSTART SET
BY FIRST NE SIZE
CALL FIRST-DUP NEWPAGE SKIP
CASE FOR NOMASK SOKAKU
CHECKPOINT GE NOPRINT SORT
CHKP GET NOT SQL
CHKP-STATUS GO NOTE STOP
CLEAR GOTO NOTITLE SUMMARY-INDEX
CLOSE GQ NOVERIFY SUM
COL GR NQ SYSDATE
COLOR GRAPH NULL SYSDATE-LONG
COMMIT GT OF SYSIN
CONTROL HEADING OR SYSIPT
COPY HEX OTHERWISE SYSLST
CURSOR HIGH-VALUES PA1..PA3 SYSPRINT
D IDD PAGE-COUNT SYSSNAP
DECLARE IDMS PAGE-NUMBER SYSTIME
DEFAULT IF PARM-REGISTER SYSUSERID
DEFINE IN PATH-ID TALLY
DELETE INITIATION PATTERN TERM-COLUMNS
DENWA INSERT PERFORM TERM-NAME
DISPLAY JOB POINT TERM-ROWS TERMINATION
DLI JUSTIFY POS TITLE
DO KANJI-DATE PRIMARY TO
DRAW KANJI-TIME PRINT TRANSFER
DUPLICATE KANJI-DATE-LONG PROC TRC
E KEY PROCEDURE UNIQUE
ELSE KEY-PRESSED PROGRAM UNTIL
ELSE-IF KOKUGO PUT UPDATE
ELEMENT-RECORD KUN READ UPPERCASE
END LAST-DUP RECORD VALUE
END-CASE LE RECORD-COUNT VERIFY W
END-DO LEVEL RECORD-LENGTH WHEN
END-IF LIKE REFRESH WORK 1024
END-PROC LINE RELEASE WRITE
ENDPAGE LINE-COUNT RENUM X
END-REPEAT LINE-NUMBER REPEAT XRST
ENDTABLE LINK REPORT
ENTER REPORT-INPUT
RESHOW
Easytrieve® Report Generator 11.6
Messages and Codes
Messages and codes issued by Easytrieve .
This section lists the codes and messages that can display during the execution of Easytrieve programs. You can use
these codes and messages to help correct a program error, or to help Broadcom Support in case of a system problem.
Messages and codes are in the following categories:
EZABXxxx
A program abends
EZACTxxx
A problem when linking, transferring, or calling another program is encountered
EZALTxxx
A problem in the ETALTSEQ utility is encountered
EZCM
A Configuration Manager problem is encountered
EZDLIxxx
A problem accessing DLI is encountered
EZEIPxxx
A program abends
EZIDMxxx
A problem accessing IDMS is encountered
EZIOExxx
An unrecoverable file I/O error is encountered
EZKXxxxx
A system initialization problem is encountered
EZOPTxxx
A problem in the ETOPLOAD utility is encountered
EZSHTxxx
A system termination problem is encountered
EZSQLxxx
A problem accessing your SQL database is encountered
EZSRTxxx
An error sorting records is encountered
EZTCxxxxx
Compile warnings and errors occur
Hundreds of new and explicit messages are available to pinpoint invalid syntax. These messages are designed to
illustrate exactly what is wrong and, where appropriate, the valid syntax you should use to correct the problem. Compiler
messages describe errors and warnings detected during compilation of Easytrieve source programs. In compiler listings,
these messages are formatted with a EZTCxxxxx prefix. Warnings are suffixed with W. Errors are suffixed with E. In non-
mainframe environments without a listing, the errors show the message number, suffix, and text.
Starting with r11, the compiler is enhanced to issue messages that are self explanatory. The following bullets describe
improvements starting with r11:
1025