    /*
        04
        Update Inventory
        
        Add or remove items from the overall inventory (all lcoations).
        This procedure also updates the average cost per unit whenever items are added.
        This procedure would be called whenever new items are recieved into the warehouse
        and also called for every item at the end of the day to remove items.
                
        The cost_sales_tracker table is slighlty redundant, however it improves speed when
        the supermarket needs to quickly check the inventory total for a product as well as 
        its current avg_cost_price. This is a query that is run very often in the business as
        prices change daily for the organization.
        
        p_product_id:   the product to update
        p_quantity:     the quantity to update, negative numbers for removing, positive for adding
        p_new_cost:     the cost per unit when adding new items, set to null when removing
    */
    PROCEDURE update_inventory (
        p_product_id IN cost_sales_tracker.product_id%TYPE,
        p_quantity IN NUMBER,
        p_new_cost IN cost_sales_tracker.cost_per_unit%TYPE
    )
    IS
        v_direction cost_sales_tracker.direction%TYPE := 'OUT';
        v_old_total cost_sales_tracker.total%TYPE;
        v_new_total cost_sales_tracker.total%TYPE;
        v_old_avg cost_sales_tracker.average_cost_per_unit%TYPE;
        v_new_avg cost_sales_tracker.average_cost_per_unit%TYPE;
        v_test_id products.product_id%TYPE;
        v_cost cost_sales_tracker.cost_per_unit%TYPE;
        
    BEGIN
    
        -- if zero quantity, raise error
        IF p_quantity = 0 THEN
            jta_error.throw(-20201, 'cannot update a zero amount to inventory');
        END IF;
        
        
        -- if not actual product raise error
        BEGIN
            -- see if product id exists in product table
            SELECT product_id INTO v_test_id FROM products WHERE product_id = p_product_id;
        EXCEPTION
            WHEN no_data_found THEN
                jta_error.throw(-20201, 'non existing product being updated to inventory');
            WHEN OTHERS THEN
                RAISE; -- outer procedure will deal with it
        END;
        
        
        -- get old total from db, if exists
        v_old_total := 0;
        BEGIN
            SELECT total INTO v_old_total
            FROM cost_sales_tracker
            WHERE product_id = p_product_id 
            AND transaction_id IN (
            SELECT MAX(transaction_id) FROM cost_sales_tracker WHERE product_id = p_product_id);
        EXCEPTION
            WHEN no_data_found THEN
                -- if a previous entry was not made for this product it will remain zero
                NULL; 
            WHEN OTHERS THEN
                RAISE;
        END;
        
        -- get old average if exists
        v_old_avg := 0;
        BEGIN
            SELECT average_cost_per_unit INTO v_old_avg
            FROM cost_sales_tracker
            WHERE product_id = p_product_id 
            AND transaction_id IN (SELECT MAX(transaction_id) FROM cost_sales_tracker 
            WHERE product_id = p_product_id);
        EXCEPTION
            WHEN no_data_found THEN
                -- if we never added a this product before, the old average is zero
                NULL;
            WHEN OTHERS THEN
                RAISE;
        END;
        

        -- update to new total, 
        IF p_quantity > 0 THEN
        
            -- if adding an item, the cost must be positive, otherwise it is ignored
            IF p_new_cost <= 0 OR p_new_cost IS NULL THEN
                jta_error.throw(-20201, 'cannot update inventory with non positive cost per unit');
            ELSE
                v_cost := p_new_cost;            
            END IF;
            
            -- switch direction 
            v_direction := 'IN';
            
            -- update new average
            v_new_avg := ROUND(((v_old_avg * v_old_total) + (p_quantity * p_new_cost) ) / (v_old_total + p_quantity), 2);
            
            -- calculate new total
            v_new_total := v_old_total + p_quantity; 
                
        ELSE
            -- cost is ignored if removing items,
            v_cost := NULL;
            -- average also remains the same
            
            -- reduce quantity (its a negative number)
            v_new_total := v_old_total + p_quantity; 

            -- throw error if negative
            IF v_new_total < 0 THEN
                jta_error.throw(-20201, 'cannot remove more items than already exists in inventory');
            END IF;
            
            -- set old average as new average, 
            -- if old average doesn't exist, the above negative error would have been thrown            
            v_new_avg := v_old_avg; 
            
        END IF;
        
        -- insert data into database
        INSERT INTO cost_sales_tracker (
            transaction_id, product_id, direction, date_time, quantity,
            total, average_cost_per_unit, cost_per_unit
        )
        VALUES (
            transaction_id_seq.NEXTVAL, p_product_id, v_direction, sysdate, p_quantity,
            v_new_total, v_new_avg, v_cost
        );
        
        COMMIT;
        
    EXCEPTION
        WHEN OTHERS THEN
            -- all exceptions will be logged into error table...
            jta_error.log_error(SQLCODE, SQLERRM);  
            ROLLBACK;
    END update_inventory;

